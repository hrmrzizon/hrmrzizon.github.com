<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Appocrypha</title>
  <meta name="description" content="store limitless knowledges">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/posts/2/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Appocrypha">
  <meta name="twitter:description" content="store limitless knowledges">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-1/">Frustum Traced Shadow With Irrelgular Z Buffer 1</a>
          </h1>

          <p class="post-meta">Jan 13, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/fts/">fts</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-0/">frustum Traced Shadow with Irregular Z-Buffer 0</a> 에서 기법의 아이디어를 둘러봄으러써 대강 이 알고리즘이 무엇인지 살펴보았다. 이번 글에서는 논문에 수록된 포괄적인 전체 시스템과 복잡도에 대하여 알아볼 것이다.</p>

<h3>전체 시스템</h3>

<p><a href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-0/">이전 글</a>에서 두가지 단계에 대해서 자세한 설명을 했었다. <em>Irregular Z-Buffer</em> 를 생성하고 <em>Visibility Test</em> 를 하는 것이였다. 실제 구현된 단계는 총 6개의 단계로 이루어진다고 한다.</p>

<p>첫번째로는 <em>Eye-Space Z-Prepass</em> 를 해준다. 요즘의 엔진들이나 큰 규모가 아닌 게임이더라도 <em>Z-Prepass</em><sup id="fnref:L1"><a href="#fn:L1" class="footnote">1</a></sup> 는 거의 대부분 해준다. <em>Geometry Pass</em> 가 두번 걸리기는 하지만 <em>Fill Rate</em> 의 부하가 <em>Geometry Pass</em> 의 부하보다 많이 커서 그런 듯하다. 중요한건 단순히 언급한 <em>Eye-Space Z-Prepass</em> 를 뜻하는게 아니다. 이전에 언급한 <em>μQuad</em> 의 빠른 계산을 위해 <em>G-Buffer</em> 에 3개의 실수 값들을 넣는다. 이 3개의 실수는 실제 그려지는 카메라의 위치와 <em>Tangent Plane</em> 의 4개의 코너중에 3개의 거리를 나타낸다. 이는 <em>μQuad</em> 를 다시 계산하기에 충분하다고 한다.</p>

<p>이 방법은 <em>Visibility Test</em> 의 속도를 빠르게 하는데 도움이 되지만, 당연히 <em>G-Buffer</em> 의 공간이 부족한 경우에는 쓰지 못한다. AAA 급의 게임들은 <em>G-Buffer</em> 를 bit 단위로 최대한 아껴쓰기 경우가 많기 때문에 이와 같은 상황이 일어날 수도 있다. 이런 경우에는 명시적으로 <em>Visibility Test</em> 를 할때 <em>μQuad</em> 를 계산한다고 한다. 아래 그림은 2009년에 발매된 <em>KillZone 2</em> 의 <em>G-Buffer</em> 사용을 나타내는 PT의 한 부분이다.</p>

<p><br />
<img src="/images/killzone2_g-buffer.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://www.slideshare.net/guerrillagames/deferred-rendering-in-killzone-2-9691589">Deferred Rendering in Killzone 2</a>
</center>
<p><br /></p>

<p>두번째로는 씬의 경계를 설정해주는 것이다. <em>Shadow Mapping</em> 에서 <em>Light-Space Projection</em> 행렬은 씬에 딱 맞게 해주어야 한다.<sup id="fnref:C1"><a href="#fn:C1" class="footnote">2</a></sup> 딱 맞지 않는 경우에는 <em>IZB</em> 에 쓸모없는 텍셀을 생기게 하기 때문이다. 그래서 <em>Light-Space Projection</em> 행렬을 계산하기 위해 <em>Compute Shader</em> 와 <em>Z-Buffer</em> 를 사용하여 <em>Bounding Box</em> 를 계산한다. 이 계산은 화면의 해상도에 따라서 달라진다. 하지만 논문의 저자는 이 비용이 병목의 큰 원인이 아니기 때문에 특별한 해결 방법을 제시하지는 않는다.</p>

<p>세번째는 <em>Irregular Z-Buffer</em> 를 만드는 것이다. 이전 글에서 <em>IZB</em> 에 대한 대략적인 아이디어는 언급했었다. 더 디테일하게 이를 말해보면, 우선 <em>Eye-Space Z Buffer</em> 를 참조해 <em>Light-Space</em> 로 변환한 후에 <em>Light-Space A-Buffer</em> 의 텍셀의 <em>Linked-List</em> 에 넣는다.</p>

<p><em>IZB</em> 의 발상은 <em>Eye-Space</em> 의 픽셀과 <em>Light-Space</em> 의 텍셀이 1:1 로 매칭되지 않고 하나의 텍셀이 참조당하는 횟수가 1을 넘을때 <em>allasing</em> 이 발생하는 것에서 시작되었다. 그래서 여기서 구현된 <em>IZB</em> 는 텍셀에 <em>Linked-List</em> 의 개념을 도입하여 보다 정확히 계산할 수 있게 하였다.</p>

<p>아래 그림은 <em>IZB</em> 의 데이터를 나타낸다.</p>

<p><br />
<img src="/images/fts_depth_length_cull.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>왼쪽의 그림은 일반적인 <em>Shadow Map</em> 을 나타내고, 중간의 그림은 <em>Linked-List</em> 의 크기를 나타낸다. 흰색은 <em>Linked-List</em> 의 크기가 0인 텍셀을 나타내고, 검은색에 가까워질수록 <em>Linked-List</em> 의 크기가 점점 커지는 것을 나타낸다. 오른쪽의 그림은 필요없는 부분을 0으로 나타내고, 나머지 부분은 0 이상의 숫자를 나타내는 방식이다. 이는 아래에서 언급할 <em>Light-Space Culling Prepass</em> 에서 쓰인다.</p>

<p>픽셀별로 여러개의 가시성(가려진 정도)를 나타내는 픽셀은 여러개의 <em>IZB Node</em> 를 필요로 한다. 일반적인 <em>Shadow Map</em> 과는 다르게 <em>μQuad</em> 는 다른 <em>Light-Space Texel</em> 에 <em>Projection</em> 이 가능하다.</p>

<p>대충 생각해보면, <em>N</em> 개의 픽셀별 쉐도우가 필요하면, <em>N</em> 개의 <em>IZB Node</em> 가 필요하다. 하지만 쓸데없는 데이터를(<em>Geometry</em> 가 없는 경우) 넣지 않을 수 있으므로 <em>M</em> 개의 <em>Light-Space Texel</em> 에 <em>μQuad</em> 를 투영한다면, 우리는 min(<em>N</em>, <em>M</em>)개의 <em>IZB Node</em> 가 필요하다고 알 수 있다.</p>

<p>아래 그림은 <em>IZB</em> 를 사용하는 디테일한 구조를 나타낸다.</p>

<p><br />
<img src="/images/fts_SimpleLayout.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p><em>IZB</em> 의 데이터 구조는 <em>Light-Space A-Buffer</em> : <em>Eye-Space A-Buffer</em> 의 <em>Node</em> 를 찾아가기 위한 데이터, <em>Eye-Space A-Buffer</em> : 리스트의 크기를 나타내는 버퍼와 같다. 출력되는 결과 : <em>Visibility Buffer</em> 또한 따로 존재한다. 이게 최종적으로 그려질때 사용된다.</p>

<p>다음은 <em>Light-Space Culling Prepass</em> 다. <em>Visibility Test</em> 를 위해 <em>Geometry</em> 의 <em>Light-Space Conservative Rasterization</em> 을 하게 되는데, GPU 에서 <em>Early-Z</em> 기능을 제공한다면 쓸데없는 부분(아무것도 없는 텍셀, 가장 끝)을 컬링할 수 있다.</p>

<p>하지만 <em>Early-Z</em> 하드웨어를 사용할때는 <em>Light-Space Z-Buffer</em> 를 필요로 한다. 이는 조금 당황스러운 상황을 만든다. 그래서 이 단계에서는 반드시 스텐실 버퍼를 만들어야 한다. 위에서 언급한 쓸데없는 부분(아무것도 없는 텍셀, 가장 끝)의 <em>Depth</em> 를 0으로 세팅한다. 나머지는 0 이상의 숫자로 세팅한다.</p>

<p>논문의 저자에 따르면, 엄청 큰 씬을 제외하고는 30% ~ 50% 의 성능 향상을 보였다고 한다. 이는 <em>Conservative Rasterization</em> 으로 생성된 <em>Fragment</em> 의 절대적인 숫자를 줄이고, 아무것도 없는 리스트를 스킵하면서 길이의 다양성을 없엔 효과다.</p>

<p>컬링을 된 이후에는 픽셀별로 <em>Visibility Test</em> 를 해준다. 이때 각각의 폴리곤들은 임의의 텍셀 집합을 가리기 된다. 그리고 각각의 텍셀이 가진 리스트를 순회하면서 <em>Visibility Test</em> 를 한다. 이때 <em>atomic OR</em> 을 사용하여 <em>Visibility Buffer</em> 에 기록한다. 여기서 가장 병목이 되는 구간은 각각의 폴리곤이 임의의 서로다른 길이를 가진 텍셀의 리스트를 커버링하여 각각의 쓰레드별로 실행되는 시간이 제각각이 된다. 문제는 시간이 제각각인 경우, 가장 느린 시간을 소모한 쓰레드를 기준으로 <em>divergence</em> 하여 각각의 텍셀의 리스트의 길이 중 가장 긴 길이의 시간으로 맞춰진다. 이는 최악의 상황을 유발할 수 있다.</p>

<p>마지막으로 <em>Visibility Buffer</em> 를 사용하여 실제 오브젝트들을 렌더링하면 된다.</p>

<h3>복잡도 계산</h3>

<p>위에서도 언급햇다시피 이 기법은 <em>N</em> 번의 <em>Visibility Test</em> 한다면, 시간 복잡도는 O(<em>N</em>) 과 같다. 여기서 <em>N</em> 을 분해하면 다음과 같다. O(<em>La</em> * <em>F</em>), <em>F</em> 는 <em>Light-Space</em> 의 <em>Fragment</em> 갯수이고, <em>La</em> 는 <em>Linked-List</em> 의 평균 길이다.</p>

<p><em>La</em> 또한 다른 요소로 나타낼 수 있다. <em>Visibility Test</em> 는 <em>Eye-Space</em> 에서 한다. 그래서 <em>IZB Node</em> 의 갯수는 <em>Eye-Space</em> 의 해상도에 비례한다. 그리고 <em>Eye-Space</em> 의 데이터는 전부 <em>Light-Space</em> 에 기록되므로 <em>La</em> ≈ (<em>Eye-Space Resolution</em>) / (<em>Light-Space Resolution</em>) 으로 계산될 수 있다.</p>

<p>하지만 위에서 언급했던 것과 같이 <em>SIMT</em> 기반의 GPU 에서는 O(<em>La</em> * <em>F</em>) 가 아닌 O(<em>Lm</em> * <em>F</em>) 이 될 수 밖에 없다. <em>Lm</em> 은 <em>Linked-List</em> 의 최대 길이다. 결국 퍼포먼스를 내기 위해선 <em>Lm</em> 의 길이를 줄이는 것이 가장 중요하다는 것이 된다.</p>

<p>이번 글에서는 전체 시스템과 복잡도에 대해서 알아보았다. 다음은 더 디테일한 구현 부분의 내용을과 <em>Alpha</em> 처리에 대한 부분을 알아볼것이다.</p>

<h2>참조</h2>
<ul>
  <li><a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:L1">
      <p>https://ypchoi.gitbooks.io/rendering-techniques/content/z_prepass.html <a href="#fnref:L1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:C1">
      <p>Cascaded Shadow Map 의 Crop Matrix 를 떠올리면 된다. <a href="#fnref:C1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-0/">Frustum Traced Shadow With Irrelgular Z Buffer 0</a>
          </h1>

          <p class="post-meta">Jan 13, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/fts/">fts</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/12/27/percentage-closer-soft-shadows/">Percentage-Closer Filtering Shadows</a> 에서 <em>PCF</em> 를 응용한 <em>PCSS</em> 라는 <em>Soft Shadow</em> 를 나타내는 기법에 대해서 알아보았다. 이번 글에서는 여태까지 알아본 것들에 비해 굉장히 최근에 나온 기법인 <em>frustum-Traced Shadow</em> 에 대해서 알아볼것이다.</p>

<p>해당 기법은 2015년에 <em>Siggraph</em>, <em>Interactive 3D</em> 같은 컨퍼런스에서 발표되었으며, 현재 <em>Tom Clansy’s the Division</em> 에 <em>PCSS</em> 와 혼합된 형태(<em>Hybrid frustum Traced Shadow</em>)로 적용되어 있다. <em>Frame Rate</em> 에 조금 영향을 미쳐 대부분의 게이머들은 아직은 <em>HFTS</em> 를 사용하지 않는듯 하다.(<a href="https://www.reddit.com/r/nvidia/comments/49idz3/nvidia_hfts_the_division/">Reddit : Nvidia HFTS (The Division)</a>) 하지만 컴퓨팅 파워가 늘어나는 것을 가정한다면 앞으로 하이엔드 게임의 주 옵션이 될수도 있겠다.</p>

<p>이 기법의 저자는 <em>Shadow Map</em> 처럼 따로 붙은 기법없이 <em>Aliasing</em> 이 없어야 했으며, 현세대의 GPU 와 해상도를 <em>Interactive</em> 하게 지원하는 것이 완벽한 <em>Hard Shadow</em> 를 목표로 <em>FTS</em> 를 고안했다. 가장 많이 쓰이는 <em>Shadow Map</em> 기법은 공간적(<em>Light-Space</em> 와 <em>Clipping-Space</em> 의 <em>Discretize</em> 된 결과의 차이), 일시적인(필터링이 필요한 <em>Aliasing</em>)인 문제들이 산재한다. 이는 이 기법을 고안한 시발점이였다.</p>

<p><em>FTS</em> 의 이론적인 뿌리를 정하기 위해 저자는 여태까지 존재하는 여러 기법을 언급한다. 빛을 하나의 직선단위로 시뮬레이팅 하는 <em>Ray-Tracing</em>, 볼륨을 통한 각각의 폴리곤들을 테스트 하는 <em>Shadow Volume</em>, <em>Irregular Z-Buffers</em> 를 언급했다.</p>

<p><em>Shadow Volume</em> 은 3차원상으로 <em>Shadow</em> 가 생기는 부분을 정해 그 부분을 테스트해서 <em>Shadow</em> 를 정해주는 기법이다. 이는 <em>Shadow Map</em> 보다 픽셀 단위로 처리할 수 있지만, 여러 단점이 있다고 한다. 한번에 해결되는 깔끔한 방법이 없으며, 보이지 않는 부분도 처리하기 때문에 <em>Fill-Rate</em> 를 많이 소모한다. 게다가 처리 자체가 간단하지 않기 때문에 개발자들도 많이 쓰는 기법이 아니라고 한다. 필자도 <em>Shadow Map</em> 에 대한 자료는 굉장히 많이 봤지만 <em>Shadow Volume</em> 은 거의 본적이 없다.</p>

<p><br /></p>

<p><img src="/images/NVidia_ShadowVolume.jpg" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch09.html">GPU Gems : Efficient Shadow Volume Rendering</a>
</center>
<p><br /></p>

<p><em>Ray-Tracing</em> 은 빛을 직선 단위로 시뮬레이팅을 하는 기법으로, 계산 비용 자체가 비싸기 때문에 하드웨어와 구조에 굉장히 의존적이라고 한다. 게임에서도 쓰일 수 있는 기법이 있었지만 다른 후보에 밀려났다. 바로 <em>Irregular Z-Buffer</em> 다. 현대 GPU 의 <em>Geometry</em> -&gt; <em>Rasterize</em> 구조에 맞춰 가장 걸맞는 방법이라고 한다. 자세한 설명은 아래에서 보자.</p>

<h3>Key Idea</h3>

<p>이 기법의 중요한 아이디어는 앞에서 소개한 <em>Irregular Z-Buffer</em> 와 <em>frustum-Triangle Test</em> 이 두가지다. <em>Irregular Z-Buffer</em> 는 앞서 <em>Shadow Map</em> 의 단점중에 공간적 괴리를 해결하는 데이터 구조이고, <em>frustum-Triangle Test</em> 는 논문에서 한 말을 이용하면 <em>Sub-Pixel Accurate Pixel</em> 을 구성하기 위한 시뮬레이션 테스트다. 이 두가지를 간단하게 살펴보자.</p>

<p>첫번째로는 바로 위에서 언급했던 <em>Irregular Z-Buffer</em> 다. 여기서의 <em>IZB</em> 는 우리가 알던 일반적인 <em>Buffer</em> 의 쓰임새와는 조금 다르게 쓰인다. 이 기법에서의 <em>IZB</em> 는 일반적인 <em>Shadow Map</em> 에서의 <em>Eye-Space</em> 와 <em>Light-Space</em> 의 괴리를 없에기 위해 <em>Light-Space</em> 를 기준으로 <em>Depth</em> 를 쭉 저장하는게 아닌, <em>Eye-Space</em> 의 각각 픽셀별로 표현하는 물체에 영향을 미치는 광원을 방향으로 <em>Ray</em> 를 쏜다. 그리고 <em>Light-Space</em> 를 기준으로 만든 <em>Grid</em> 버퍼에 <em>Ray</em> 가 부딫치고, 부딫친 부분에서 가장 가까운 텍셀에 데이터를 저장한다. 위에서 설명한 <em>IZB</em> 를 구성하는 방법에 대한 그림이 아래에 있다.</p>

<p><br />
<img src="/images/fts_IZB.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>간단하게 이런식으로 <em>IZB</em> 가 구성되는 것을 알 수 있다. 이제 <em>Geometry</em> 와 비교하는 <em>Visibility Test</em> 가 필요하다. 일반적인 <em>Shadow Mapping</em> 의 <em>Visibility Test</em> 와는 조금 다르다. 기존의 <em>Shadow Mapping</em> 은 정점을 <em>Light-Space</em> 로 바꾸어 <em>Z</em> 값을 비교하여 <em>Visibility Test</em> 를 한다. 하지만 이 기법에서의 <em>Visibility Test</em> 는 다르다. 위에서 언급한 것과 같이 <em>IZB</em> 를 만든다. 그 다음 <em>Occlluder Geometry</em> 들을 <em>Light-Space</em> 를 기준으로 <em>Conservative Rasterization</em> 을 해준다.<sup id="fnref:C1"><a href="#fn:C1" class="footnote">1</a></sup> 그렇게 나온 결과를 통해 <em>IZB</em> 와 함께 <em>Visibility Test</em> 를 한다. <em>Conservative Rasterization</em> 의 결과는 거의 <em>Flag</em> 로 사용될것으로 예측되고, <em>Eye-Space</em> 픽셀의 그림자 계산은 복잡한 계산을 통해 구한다. 아래는 논문에 있던 <em>IZB</em> 를 기준으로 쓰여진 수도 코드다.</p>

<p><br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Step 1: Identify pixel locations we need to shadow
G(x, y) ← RenderGBufferFromEye()

// Step 2: Add pixels to our light-space IZB data structure
for pixel p ∈ G(x, y) do
    lsTexelp ← ShadowMapXform[ GetEyeSpacePos( p ) ]
    izbNodep ← CreateIZBNode[ p ]
    AddNodeToLightSpaceList[ lsTexelp, izbNodep ]
end for

// Step 3: Test each triangle with pixels in lists it covers
for tri t ∈ SceneTriangles do
    for frag f ∈ ConservateLightSpaceRaster( t ) do
        lsTexelf ← FragmentLocationInRasterGrid[ f ]
        for node n ∈ IZBNodeList( lsTexelf ) do
            p ← GetEyeSpacePixel( n )
            visMask[p] = visMask[p] | TestVisibility[ p, t ]
        end for
    end for
end for
</code></pre></div></div>

<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>다음은 <em>Visibility Test</em> 다. 논문에서는 <em>frustum-Triangle Test</em> 라고 부르는데, 이는 조금 복잡한 과정으로 구성된다. 아래 그림을 보면서 알아보자.</p>

<p><br />
<img src="/images/fts_VisibilityTest.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>가장 처음에는 <em>μQuad</em> 라는 것을 생성한다. <em>μQuad</em> 는 <em>Tangent-Space</em> 를 기준으로 설정하며 각 픽셀별로 생성한다. 위 그림에서는 중간 그림에 구 위에있는 평면을 뜻한다. 그 다음 가리는 <em>Geometry</em> 의 폴리곤들의 각각의 <em>Edge</em> 를 사용하여 <em>Shadow Plane</em> 을 생성한다. 마지막으로 만들어진 <em>Shadow Plane</em> 을 <em>μQuad</em> 에 <em>Projection</em> 한다. 이때 가지고 있던 <em>LUT</em> 를 통해 가려짐을 계산한다. 그리고 다른 <em>Edge</em> 들도 계속해서 누적시킨다.</p>

<p>간단하게 <em>frustum-Triangle Test</em> 의 단계에 대해 설명해보았다. 이제 각각의 과정 : <em>μQuad Construction</em>, <em>Shadow Plane Construction</em>, <em>Visibility Computation</em> 에 대해 조금 더 자세히 써보겠다.</p>

<p><em>μQuad</em> 의 생성은 <em>Geometry</em> 의 <em>Tangent-Space</em> 를 기준으로 계산되는 것 빼고는 특이한 점이 없다. 하지만 생성되는 시기에 대해선 조금 특별한게 있다. 가시성을 계산할 때 생성할 수도 있지만 <em>G-Buffer</em> 를 생성할 때 미리 계산하는 것이 더 효율적이라고 한다.</p>

<p>가시성을 계산할 때 <em>ray-triangle intersection</em> 을 계산하기 보다는 앖에서 언급한 각각의 폴리곤의 <em>Shadow Volume</em> 을 각 점마다 계산한다고 한다. <em>Shadow Volume</em> 은 그림자를 생성하는 <em>Occluder Triangle</em> 을 기준으로 각각의 <em>Edge</em> 에서 뻗어나오는 직사각형 면으로 구성된다. 아래 그림을 보면 쉽게 이해할 수 있다. 그리고 <em>μQuad</em> 에서 샘플링한 각각의 점들을 기준으로 가시성을 계산한다면 한다면, 4번의 내적으로 가시성을 테스트할 수 있다는 것을 의미한다.</p>

<p><br />
<img src="/images/HFTS_frustumTracing.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/gameworks/events/  GDC2016/jstory_hfts.pdf">NVidia : Advanced Geometrically Correct Shadows for Modern Game Engines</a>
</center>
<p><br /></p>

<p>또한 그림자를 멀티샘플링 하기 위해서는 여기서 언급한 <em>Shadow Volume</em> 의 <em>Shadow Plane</em> 들을 이용한다고 한다.</p>

<p>마지막으로 <em>Visibility Computation</em> 이 남아있다. 이 부분의 대략적인 것은 위에서 언급했다. 자세한 계산방식을 말해보겠다. 위에서 언급한 <em>μQuad</em> 와 <em>Shadow Plane</em> 사용해서 해당 폴리곤들의 데이터 누적을 위해서는 <em>μQuad</em> 에서 이산화된 <em>binary</em> 샘플링이 필요하다. 논문의 저자는 32 번의 <em>Halton sampling</em><sup id="fnref:C2"><a href="#fn:C2" class="footnote">2</a></sup> 을 사용했다고 한다.</p>

<p>가시성을 계산하기 위해서는 <em>Shadow Plane</em> 을 <em>μQuad</em> 에 <em>Projection</em> 해줘야 한다. 그러면 <em>μQuad</em> 는 최대 3개의 <em>line</em> 을 얻게 된다. 논문에서는 이 <em>line</em> 을 <em>μQuad</em> 를 기준으로 극좌표계<sup id="fnref:C3"><a href="#fn:C3" class="footnote">3</a></sup> 데이터로 저장한다고 한다. 반지름과 각도가 5bit 크기로 저장된다. 해당 10bit 데이터를 사용하여 미리 계산된 테이블에서 32개의 이진 가시성 샘플을 가져온다. 결과와  bit 단위의 and 연산을 통해 <em>μQuad</em> 의 가시성을 계산할 수 있다고 한다.</p>

<p>해당 기법을 고안한 사람은 두가지의 아이디어 : <em>Irregular Z-Buffer</em> 와 <em>frustum-Triangle Test</em> 를 통해  <em>Sub-pixel Hard Shadow</em> 의 이론을 만들었다. 하지만 이 아이디어들과 구현을 위한 노력의 차이는 꽤 큰듯하다. 논문을 보면 아이디어에 대한 텍스트보다 최적화를 위한 텍스트가 2배가 될정도로 많다. 다음 글에서는 논문에서 나온 전체 과정과 디테일한 구현 사항에 대해 적어보겠다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Irregular_Z-buffer">Wikipedia : Irregular Z-Buffer</a></li>
  <li><a href="http://cwyman.org/videos/sig1657-chris-wyman-magic-behind-gameworks-hybrid-frustum-traced-shadows-hfts.mp4">cywman.org : HFTS Presentation Video</a></li>
  <li><a href="https://developer.nvidia.com/content/dont-be-conservative-conservative-rasterization">NVidia : Don’t be conservative with Conservative Rasterization</a></li>
  <li><a href="http://developer.download.nvidia.com/gameworks/events/GDC2016/jstory_hfts.pdf">NVidia : Advanced Geometrically Correct Shadows for Modern Game Engines</a></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:C1">
      <p>일반적으로 오브젝트를 그리는 것과 다른 <em>Conservative Rasterization</em> 을 해주는 이유는 일반적인 <em>Rasterization</em> 은 픽셀의 반이상을 차지해야 해당 픽셀을 처리해준다. 하지만 정확한 <em>Visibility</em> 를 계산하기 위해서는 폴리곤이 해당되는 모든 픽셀들을 처리해주어야 한다. <em>Conservative Rasterization</em> 은 앞에서 말한바와 같이 모든 부분을 픽셀로 처리한다. <em>Conservative Rasterization</em> 에 대한 자세한 정보는 <a href="https://developer.nvidia.com/content/dont-be-conservative-conservative-rasterization">NVidia : Don’t be conservative with Conservative Rasterization</a> 에서 확인할 수 있다. <a href="#fnref:C1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:C2">
      <p>몬테카를로 시뮬레이션과 같은 방식의 점을 생성하는 방식이다. 쉽게 말하면 랜덤하게 생성하는 것이라고 생각하면 된다. 자세한 정보는 <a href="https://en.wikipedia.org/wiki/Halton_sequence">Wikipedia : Halton sequence</a> 에서 확인할 수 있다. <a href="#fnref:C2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:C3">
      <p>여기서는 각도와 반지름(거리)를 사용하여 나나탠다. 극좌표계에 대한 자세한 정보는 <a href="https://ko.wikipedia.org/wiki/%EA%B7%B9%EC%A2%8C%ED%91%9C%EA%B3%84">위키피디아 : 극좌표계</a> 에서 확인할 수 있다. <a href="#fnref:C3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/01/11/unity-scripted-importer/">Unity Scripted Importer</a>
          </h1>

          <p class="post-meta">Jan 11, 2018 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 의 에디터 시스템은 꽤나 유연하다. 이번 글에서는 <em>AssetImporter</em> 에 대한 기능들에 대하여 알아볼 것이다.</p>

<p>Unity 의 각각의 Asset 들은 확장자의 이름에 따라서 <em>AssetImporter</em> 가 하나씩 만들어지고, 해당 <em>AssetImporter</em> 에 따라서 <em>Post-Process</em> 가 진행된다. 필자가 많이 봤던 <em>AssetImporter</em> 는 <a href="https://docs.unity3d.com/ScriptReference/TextureImporter.html"><em>TextureImporter</em></a> 와 <a href="https://docs.unity3d.com/ScriptReference/ModelImporter.html"><em>ModelImporter</em></a> 가 있었다. 확인할 당시에는 당연히 <em>AssetImporter</em> 를 커스터마이징 할 수 있겠다는 생각이 들어 찾아봤지만 전혀 없었다.(Unity 5 버젼을 사용할 때다.) 이렇게 시스템을 만들어 놓고 왜 없냐는 의문이 들었지만 이는 정말 할수있는게 없었기에 넘어갔었다.</p>

<p>그런데 이번에 Unity 2018.1 베타가 릴리즈 되면서 SRP 를 살펴보던 도중 <em>Expremental</em> 기능들 중에 <a href="https://docs.unity3d.com/2018.1/Documentation/Manual/ScriptedImporters.html"><em>ScriptedImporter</em></a> 라는 기능이 있는 것을 발견했다.</p>

<p>이 기능은 말그대로 예전의 내가 원하던 기능이였다. <em>AssetImporter</em> 클래스와 다른점은 딱 한가지다. 가상 <em>OnImportAsset</em> 메소드가 존재하는 것이다. 즉 <em>ScriptedImporter</em> 를 상속하여 <em>OnImportAsset</em> 를 구현하면 간단하게 에셋을 <em>Customize</em> 할 수 있는 것이다. 또한 에디터 기능을 지원하는 <a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporterEditor.html">ScriptedImporterEditor </a> 라는 클래스를 사용하면 에디터를 손쉽게 바꿀 수 있다. 자세한 사항은 글에서 언급된 링크를 통해 보면 된다.</p>

<h2>참조</h2>
<ul>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/Manual/ScriptedImporters.html">Unity Documentation : ScriptedImporter </a></li>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporter.html">Unity Reference : ScriptedImporter</a></li>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporterEditor.html">Unity Reference : ScriptedImporterEditor </a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/27/percentage-closer-soft-shadows/">Percentage Closer Soft Shadows</a>
          </h1>

          <p class="post-meta">Dec 27, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/pcss/">pcss</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/12/19/shadow-map-filtering/">Shadow Map Filtering</a> 에서 <em>PCF</em> 와 <em>VSM</em> 에 대하여 간단히 알아보았다. 이번 글에서 설명할 것은 <em>PCF</em> 를 활용한 <em>PCSS</em> 다.</p>

<p><em>PCSS</em> 는 <em>Soft Shadow</em> 를 구현하는 기법 중 하나로써 2005년에 발표되어 여태까지도 꽤나 알려진 기법이다. 우선 <em>Soft Shadow</em> 가 무엇인지 알아보자.</p>

<p><br /></p>

<p><img src="/images/soft_vs_hardshadow.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.assignmentpoint.com/science/computer/real-time-soft-shadow-rendering.html">assignmentpoint.com : Real Time Soft Shadow Rendering</a>
</center>
<p><br /></p>

<p>위와 같이 빛을 가린 물체와 거리가 멀어지면 멀어질수록 밝아지는 그림자를 <em>Soft Shadow</em> 라고 한다. 완전한 <em>Hard Shadow</em> 는 어색하기 때문에 보통 <em>PCF</em> 를 사용하여 끝부분을 부드럽게 처리했으나, 태양광 처럼 길게 그림자를 만드는 경우가 있으면 끝 부분이 가면 갈수록 부드러워져야 한다.</p>

<p><br /></p>

<p><img src="/images/tree_shadow.jpg" alt="" class="center-image" /></p>
<center>출처 : <a href="https://www.youtube.com/watch?v=Ax8G8P3tA28">Youtube
</a>
</center>
<p><br /></p>

<p>태양 빛에의해 만들어진 나무의 그림자다. 짧은 길이의 그림자는 적당히 <em>PCF</em> 로 대략 표현이 가능하나 이런 길은 그림자를 고정된 사이즈의 <em>PCF</em> 로 표현하기엔 무리가 있다. 그래서 나온것이 <em>PCSS</em> 다.</p>

<p><em>PCSS</em> 를 보기전에, 우리가 알아야할 용어들이 있다. 바로 <em>Umbra</em> 와 <em>Penumbra</em> 다.</p>

<p><br /></p>

<p><img src="/images/umbra_penumbra_antumbra.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://en.wikipedia.org/wiki/Umbra,_penumbra_and_antumbra">Wikipedia : Umbra, penumbra and antumbra </a>
</center>
<p><br /></p>

<p><em>Soft Shadow</em> 가 표현하는 부드러운 부분의 그림자는 위 그림에서도 보이듯이 <em>Penumbra</em> 라고 한다. <em>PCSS</em> 에서는 부드러운 부분의 그림자를 <em>Penumbra</em> 라고 한다. <em>PCSS</em> 에서는 <em>Penumbra</em> 의 크기를 사용하여 <em>PCF</em> 의 샘플링 범위를 정해준다. 우선 <em>PCSS</em> 의 <em>Penumbra</em> 를 계산하는 방법을 보자.</p>

<p><br /></p>

<p><img src="/images/PCSS_PenumbraSizeEstimation.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://http.download.nvidia.com/developer/presentations/2005/SIGGRAPH/Percentage_Closer_Soft_Shadows.pdf">Siggraph 2005 : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>맨위의 노란색으로 표시된 부분은 광원을 뜻하며, 일정한 범위로 빛을 비추는 <em>Area Light</em> 로 가정한 후 계산한다. W - light 는 <em>Area Light</em> 의 범위를 뜻한다. 중간에 있는 <em>Blocker</em> 는 빛을 가리는 물체를 뜻하며, d blocker 는 가리는 물체와 빛과의 거리, d receiver 는 그림자가 비추는 물체와 광원 사이의 거리를 뜻한다. 그림자를 받는 부분과 빛을 가리는 물체와 광원을 서로 평행하다고 가정해서 계산한다. 2차원의 그림을 3차원으로 바꿔보자.</p>

<p><br /></p>

<p><img src="/images/PCSS_Scheme.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>보통 <em>Pixel Shader</em> 에서 그림자의 비춘 정도를 계산하기 때문에 <em>Receiver</em> 의 작은 부분을 기준으로 그림이 그려져 있다. 작은 부분을 기준으로 <em>Area Light</em> 와의 <em>frustum</em> 과 <em>Blocker</em> 가 얼마나 충돌되는지 체크한다. 우리는 <em>Shadow Map</em> 을 사용하기 때문에 아래 그림이 조금 더 실제 계산과 비슷하다.</p>

<p><br /></p>

<p><img src="/images/PCSS_Scheme2.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>그래서 <em>Shadow Map</em> 의 빨간색으로 하이라이트 된 부분을 샘플링해 얼마나 가리고 있는지를 확인한다. 그러면 빛을 받는 정도를 알 수 있게 되는것이다. 해당 부분을 적당히 샘플링한 다음 평균을 구해서 <em>PCF</em> 로 샘플링하는 범위를 계산한다. 계산하여 <em>PCF</em> 에서 범위를 사용해 계산한다. 코드를 보면서 이해해보자.</p>

<p><br /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">PCSS_Shadow</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="n">float2</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="kt">float</span> <span class="n">zEye</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 1: blocker search</span>
	<span class="c1">// ------------------------</span>
	<span class="kt">float</span> <span class="n">accumBlockerDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">numBlockers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">float2</span> <span class="n">searchRegionRadiusUV</span> <span class="o">=</span> <span class="n">SearchRegionRadiusUV</span><span class="p">(</span><span class="n">zEye</span><span class="p">);</span>
	<span class="n">FindBlocker</span><span class="p">(</span><span class="n">accumBlockerDepth</span><span class="p">,</span> <span class="n">numBlockers</span><span class="p">,</span> <span class="n">g_shadowMap</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="n">searchRegionRadiusUV</span><span class="p">);</span>

	<span class="c1">// Early out if not in the penumbra</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numBlockers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">numBlockers</span> <span class="o">==</span> <span class="n">BLOCKER_SEARCH_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 2: penumbra size</span>
	<span class="c1">// ------------------------</span>
	<span class="kt">float</span> <span class="n">avgBlockerDepth</span> <span class="o">=</span> <span class="n">accumBlockerDepth</span> <span class="o">/</span> <span class="n">numBlockers</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">avgBlockerDepthWorld</span> <span class="o">=</span> <span class="n">ZClipToZEye</span><span class="p">(</span><span class="n">avgBlockerDepth</span><span class="p">);</span>
	<span class="n">float2</span> <span class="n">penumbraRadiusUV</span> <span class="o">=</span> <span class="n">PenumbraRadiusUV</span><span class="p">(</span><span class="n">zEye</span><span class="p">,</span> <span class="n">avgBlockerDepthWorld</span><span class="p">);</span>
	<span class="n">float2</span> <span class="n">filterRadiusUV</span> <span class="o">=</span> <span class="n">ProjectToLightUV</span><span class="p">(</span><span class="n">penumbraRadiusUV</span><span class="p">,</span> <span class="n">zEye</span><span class="p">);</span>

	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 3: filtering</span>
	<span class="c1">// ------------------------</span>
	<span class="k">return</span> <span class="n">PCF_Filter</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="n">filterRadiusUV</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<center>출처 : <a href="https://github.com/NVIDIAGameWorks/D3DSamples">Github NVIDIAGameWorks : D3DSamples</a>
</center>
<p><br /></p>

<p>해당 픽셀이 어두워지는 정도를 반환하는 <em>PCSS</em> 계산 함수다. 코드의 주석에서는 계산을 세단계로 나눈다. 첫번째로는 <em>Shadow Map</em> 을 샘플링해서 얼마나 빛이 얼마나 가려지는지 계산한다. 이를 <em>STEP 1: blocker search</em> 라고 표기해놓았고, 두번째는 <em>PCF</em> 에서 샘플링할 범위를 결정하는 넓이를 계산한다. 이를 <em>STEP 2: penumbra size</em> 라고 한다. 세번째로는 <em>PCF</em> 를 계산해서 가려지는 정도를 반환한다. 자세한 코드는 출처에서 <em>SoftShadows</em> 항목을 들어가면 볼 수 있다.</p>

<p><em>PCSS</em> 의 장점은 아무래도 확실한 <em>Soft Shadow</em> 를 구현했다는 점이다. 비록 대략적으로 가정한 부분이 많지만 장면별로 잘 맞춰주기만 한다면 괜찮은 결과가 나올것 같다. 하지만 샘플링 횟수가 꽤나 된다. <em>PCF</em> 만 하더라도 가볍지는 않은 편인데, <em>Blocker</em> 를 계산하느라 더 많이 샘플링을 한다. 하지만 잘 만들어진 게임과 요즘의 GPU 에서는 아주 큰 오버헤드는 없는걸로 보인다. (<a href="https://www.reddit.com/r/nvidia/comments/49idz3/nvidia_hfts_the_division/">Redit : Nvidia HFTS (The Division)</a>)</p>

<h2>참조</h2>
<ul>
  <li><a href="https://http.download.nvidia.com/developer/presentations/2005/SIGGRAPH/Percentage_Closer_Soft_Shadows.pdf">Siggraph 2005 : Percentage-Closer Soft Shadows</a></li>
  <li><a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a></li>
  <li><a href="https://github.com/NVIDIAGameWorks/D3DSamples">Github NVidiaGameWorks : D3DSample</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/19/shadow-map-filtering/">Shadow Map Filtering</a>
          </h1>

          <p class="post-meta">Dec 19, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/vsm/">vsm</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/11/30/what-is-shadow-mapping/">What is Shadow Mapping</a> 에서 <em>Shadow Mapping</em> 에 대한 간단한 번역 &amp; 설명을 적어놓았다. 해당 글에서 <em>PCF</em> 를 잠깐 언급했었다. 이 글에서는 <em>PCF</em> 를 포함해서 <em>Shadow Map</em> 을 필터링하는 방법에 대해서 알아보겠다.</p>

<p>첫번째는 <em>PCF</em> 다. 풀어쓰면 <em>Percentage Closer Filtering</em> 이라는 단어가 되며, <em>Shadow Map</em> 을 여러번 샘플링해 <em>Percentage</em> 를 소숫점으로 나타내서 <em>Shadow</em> 가 생긴 정도를 나타내주는 <em>Filtering</em> 기법이다. 쉽게 이해할 수 있도록 아래 그림을 보자.</p>

<p><br />
<img src="/images/PCF_Scheme.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://graphics.pixar.com/library/ShadowMaps/paper.pdf">Pixar : Rendering Antialiased Shadows with Depth Maps</a>
</center>
<p><br /></p>

<p>위의 a) 는 아무것도 필터링 하지 않을 때의 <em>ShadowMap</em> 샘플링하는 것을 보여주고, 아래 b) 는 <em>PCF</em> 를 사용해 샘플링하는 것을 보여준다. 위 그림에서 <em>Surface at z = 49.8</em> 은 그림자를 처리할 표면의 <em>Depth</em> 또는 <em>Z</em> 을 뜻한다. 그리고 <em>Light-Space</em> 를 기준으로 해당 값보다 <em>Depth</em> 값이 멀다고 판단될시에는 처리하지 않고, 가깝다고 판단될 때는 처리하는 걸로 해준다. <em>Shadow Map</em> 에서 한 부분만 샘플링해서 하는 것이 윗 부분의 그림이고, 한 부분이 아닌 근처의 여러 부분을 샘플링해서 값을 구하는 것이 <em>PCF</em> 다.</p>

<p>아래에 <em>PCF</em> 를 사용하는 코드가 있다.</p>

<p><br /></p>

<pre><code class="language-HLSL">float PCF_FILTER( float2 tex, float fragDepth )
{
    //PreShader - This should all be optimized away by the compiler
    //====================================
    float fStartOffset = BoxFilterStart( fFilterWidth );
    float texOffset = 1.0f / fTextureWidth;
    //====================================

    fragDepth -= 0.0001f;
    tex -= fStartOffset * texOffset;

    float lit = 0.0f;
		for( int i = 0; i &lt; fFilterWidth; ++i )
			for( int j = 0; j &lt; fFilterWidth; ++j )
			{
				lit += texShadowMap.SampleCmpLevelZero(
                                FILT_PCF,
                                float2( tex.x + i * texOffset, tex.y + j * texOffset ),
                                fragDepth
                              );
			}
	return lit / ( fFilterWidth * fFilterWidth );
}
</code></pre>

<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a>
</center>
<p><br /></p>

<p>자세한 코드는 위의 출처에서 코드를 구해서 보면 될듯하다. <em>Texture2D::SampleCmpLevelZero</em> 는 <em>MipMap</em> 참조 레벨은 0으로 한채 텍스쳐의 값을 샘플링하여 주어진 인자와 비교하여 <em>Sampler</em> 에 정해준 방식에 적합하면 1, 적합하지 않으면 0을 반환해준다.</p>

<p>해당 그림에서는 평균을 구하는 방법을 표기해놓았으나 다른 <em>NDF</em> 를 써서 구현할 수도 있다.(<em>Gaussian Distribution</em>) 또한 규칙적으로 샘플링하는게 아닌 <em>jitter</em> 를 사용해서 샘플링할 수도 있다고 한다. 일반적으로 <em>Poisson disk Distribution</em> 을 사용한다고 한다.</p>

<p><em>PCF</em> 의 단순한 방법으로 <em>Shadow Map</em> 을 <em>AntiAliasing</em> 할 수 있다. 하지만 <em>Shadow Map</em> 의 샘플링 횟수가 <em>PCF Kernel</em>(3x3, 5x5..) 이 커지면 커질수록 많아지기 때문에 꽤나 큰 <em>PCF Kernel</em> 에서는 샘플링 부하가 걸릴 수 있다. 성능상 단점이 크나 <em>PCF</em> 는 굉장히 많이 사용되는 기법 중에 하나라고 한다.</p>

<p>다음은 <em>Variance Shadow Map</em> 이다. 이는 <a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality"><em>Chebyshev’s Inequality</em></a> 라는 통계학의 개념을 사용해 <em>Filtering</em> 해준다. 먼저 <em>Shadow Map</em> 을 저장할 때 <em>Depth</em> 만 저장하는게 아닌 <em>Depth</em> 의 제곱값 또한 같이 저장한다. <em>Filtering</em> 에 쓰일 공식을 위해 같이 넣는다.</p>

<p>다음은 아래 코드와 같이 공식을 계산해준다.</p>

<p><br /></p>

<pre><code class="language-HLSL">float VSM_FILTER( float2 tex, float fragDepth )
{
    float lit = (float)0.0f;
    float2 moments = texShadowMap.Sample( FILT_LINEAR,    float3( tex, 0.0f ) );

    float E_x2 = moments.y;
    float Ex_2 = moments.x * moments.x;
    float variance = E_x2 - Ex_2;    
    float mD = (moments.x - fragDepth );
    float mD_2 = mD * mD;
    float p = variance / (variance + mD_2 );
    lit = max( p, fragDepth &lt;= moments.x );

    return lit;
}
</code></pre>

<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a>
</center>
<p><br /></p>

<p>눈여겨 볼것은 샘플러를 <em>Linear</em> 하게 설정해놓는 것이다.</p>

<p>하지만 <em>VSM</em> 은 큰 단점이 하나 있다. 바로 <em>Light Leaking</em> 이 일어나는 것이다. 이는 <a href="https://http.download.nvidia.com/developer/presentations/2006/gdc/2006-GDC-Variance-Shadow-Maps.pdf">GDC 2006 : Variance Shadow Map</a> 에서 참조할 수 있다. 이를 해결 하는 근본적인 방법은 없다고 한다.</p>

<p>두가지 기법의 차이는 텍스쳐 샘플링을 더 많이 하느냐, 메모리를 2배로 늘려주느냐의 차이에 있다. 속도를 따지면 <em>VSM</em> 이 빠르다고 한다. 하지만 굳이 퍼포먼스를 낼 필요가 없다면 <em>PCF</em> 를 사용하는 것도 나쁜 선택은 아닐것 같다. 선택에 대한 궁금증은 <a href="https://www.opengl.org/discussion_boards/showthread.php/177219-Shadow-filtering-PCF-better-than-VSM">OpenGL Forum : Shadow filtering: PCF better than VSM? </a> 글을 참조하길 바란다.</p>

<h2>참조</h2>
<ul>
  <li><a href="https://graphics.pixar.com/library/ShadowMaps/paper.pdf">Pixar : Rendering Antialiased Shadows with Depth Maps</a></li>
  <li><a href="https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb509697.aspx">MSDN : SampleCmpLevelZero</a></li>
  <li><a href="http://www.punkuser.net/vsm/">Variance Shadow Maps</a></li>
  <li><a href="https://http.download.nvidia.com/developer/presentations/2006/gdc/2006-GDC-Variance-Shadow-Maps.pdf">GDC 2006 : Variance Shadow Maps</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality">Wikipedia : Chebyshev’s inequality</a></li>
  <li><a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">GPU Gems : Shadow Map Antialiasing</a></li>
  <li><a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a></li>
  <li><a href="https://github.com/TheRealMJP/Shadows">Github : TheRealMJP - Shadows</a></li>
  <li><a href="https://www.opengl.org/discussion_boards/showthread.php/177219-Shadow-filtering-PCF-better-than-VSM">OpenGL Forum : Shadow filtering: PCF better than VSM? </a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/17/cascaded-shadow-mapping/">Cascaded Shadow Mapping</a>
          </h1>

          <p class="post-meta">Dec 17, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/csm/">csm</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/11/30/what-is-shadow-mapping/">What is Shadow Mapping</a> 에서 <em>Shadow Mapping</em> 에 대한 간단한 번역 &amp; 설명을 적어놓았다. 이번 글에서는 <em>Shadow Mapping</em> 을 효과적으로 사용하기 위한 <em>Cascaded Shadow Mapping</em> 에 대하여 적어보겠다.</p>

<p><em>Cascaded Shadow Mapping</em> 을 구글 번역기에 돌려보면 <em>“계단식 그림자 매핑”</em> 이라고 나온다. 조금 직관적이지 않은 말이지만 뜻 자체는 맞다. 간단하게 <em>Cascaded Shadow Mapping</em> 에 대하여 말하자면 넓은 환경의 그림자를 위해 거리에(거의 <em>Depth</em>) 따라서 여러개의 <em>Shadow Map</em> 을 생성하는 방법이다.</p>

<p>넓은 범위의 <em>Directional Light</em> 가 닿는 그림자를 정확하게 표현하려면 꽤나 큰 크기의 <em>Shadow Map</em> 을 사용해야 한다. 하지만 <em>Cascaded Shadow Mapping</em> 을 사용한다면 여러개의 <em>Shadow Map</em> 을 사용하여 보다 조금의 메모리를 사용하여 넓은 범위의 그림자를 표현할 수 있다.</p>

<h2>Shadow-map generation</h2>

<p><em>Cascaded Shadow Mapping</em> 을 위한 <em>Shadow Map</em> 생성은 앞서쓴 <a href="/2017/11/30/what-is-shadow-mapping/">글</a>에서 설명한 방법과 거의 유사하다. 앞서 여러개의 <em>Shadow Map</em> 을 생성하여 그림자를 표현한다고 언급했었다. 여러개의 <em>Shaodw Map</em> 을 생성하는 기준은 <em>View frustum</em> 을 <em>Depth</em> 를 기준으로 여러개로 쪼개어 각 쪼개진 <em>frustum</em> 을 기준으로 <em>Shadow Map</em> 을 그린다.</p>

<p><em>frustum</em> 은 보통 <em>Depth</em> 값을 정하거나 어떤 알고리즘을 사용하여 쪼갠다. 이는 다음 포스팅에서 언급할 예정이다. <em>frustum</em> 을 쪼개주면 다음은 쪼개진 <em>Camera View frustum</em> 의 각각의 8개의 꼭지점들을 <em>Light-Space</em> 로 변환한다. 변환된 각각 꼭지점으로 2차원의 <em>aligned axis bounding box</em> 의 위치를 구해준다. 가장 작은 X,Y 값과 가장 큰 X, Y 값을 구해주면 된다.</p>

<p><br />
<img src="/images/CSM_EffectOfCropMatrix.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>위 그림에서 XY 평면에서의 빨간색 선으로 되어있는 사각형이 언급한 <em>aligned axis bounding box</em> 를 말한다. 이 <em>AABB</em> 는 아래에서 특정한 행렬을 만들때 쓰인다.</p>

<p><a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Maps  </a> 에서는 이 <em>Light-Space</em> 로 변환하는 <em>MVP 변환</em> 에서 <em>Projection</em> 변환을 바꿔준다고 설명한다. 두개의 행렬이 나오는데, 하나는 직교 투영 행렬로(<em>orthogonal projection</em>) 나눠진 <em>frustum</em> 의 <em>Far</em> 값과 <em>Near</em> 값을 통해 생성해준다. 그리고 나머지 하나는 <em>Crop Matrix</em> 라는 변환 행렬이다.</p>

<p>위에서 구한 <em>Light-Space</em> 의 <em>AABB</em> 값을 통해 <em>Crop Matrix</em> 를 계산한다. 아래 그림에서나오는 Mx, My 와 mx, my 는 각각 Maximum X,Y, Minimum X,Y 를 뜻한다.</p>

<p><br />
<img src="/images/CSM_CropMatrixCalc.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>이렇게 계산된 <em>Crop Matrix</em> 의 역할은 해당 <em>AABB</em> 로 <em>Shadow Map</em> 이 그려질 범위를 결정해주는 역할을 한다. 다만 범위가 아주 정확하지는 않다. 아래 그림을 보자.</p>

<p><br />
<img src="/images/CSM_FarMiddleNear.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://ogldev.atspace.co.uk/www/tutorial49/tutorial49.html">OGLdev : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>위 그림과 같이 보통은 겹치는 부분이 생긴다. 사용시에는 <em>Depth</em> 에 따라서 다르게 사용하기 때문에 크게 문제는 없다. 사용시에는 <em>Depth</em> 값에 따라서 다른 텍스쳐를 가져오는 것과 텍스쳐를 샘플링할때 UV 값을 정점의 위치를 <em>Light-Space</em> 로 변환해서 변환된 정점의 위치의 X,Y 좌표를 UV 값으로 사용하면 된다. 다만 각각의 <em>Shadow Map</em> 마다 변환 행렬은 <em>Crop Matrix</em> 때문에 다르기 때문에 따로 접근해야 한다.</p>

<p>자세한 사용법을 알고 싶으면 <a href="http://developer.download.nvidia.com/SDK/10/Samples/cascaded_shadow_maps.zip">NVidia : Cascaded Shadow Map Example</a>에서 소스를 받아 보면 된다.</p>

<h2>추가</h2>

<p><em>Cascaded Shadow Map</em> 을 <em>1 pass</em> 로 그리는 방법은 간단하다. 우선 <em>Shadow Map</em> 들을 <em>TextureArray</em> 를 통해 저장하고, <em>RenderTarget</em> 을 <em>Geometry Shader</em> 에서 각각의 렌더타겟별로 지오메트리를 추가해주어 각각의 <em>Pixel Shader</em> 를 실행시키면 된다. 자세한 코드는 <a href="https://www.slideshare.net/dgtman/implements-cascaded-shadow-maps-with-using-texture-array">여기</a>에서 볼 수 있다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Maps  </a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416307.aspx">MSDN : Cascaded Shadow Maps</a></li>
  <li><a href="https://github.com/TheRealMJP/Shadows">Github : TheRealMJP - Shadows</a></li>
  <li><a href="http://ogldev.atspace.co.uk/www/tutorial49/tutorial49.html">OGLDev : Cascaded Shadow Mapping</a></li>
  <li><a href="https://www.slideshare.net/dgtman/implements-cascaded-shadow-maps-with-using-texture-array">Slideshare : implements Cascaded Shadow Maps with using TexturArray(한글)</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/30/what-is-shadow-mapping/">What Is Shadow Mapping</a>
          </h1>

          <p class="post-meta">Nov 30, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>※ 이 글은 <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial : shadow mapping</a> 게시물을 참고하여 쓰여졌습니다. 자세한 내용은 원문을 보는게 좋습니다.</p>

<p><em>Shadow Mapping</em> 실시간으로 그림자를 구현하기 위한 방법 중에 가장 널리 알려진 방법이다. 다른 방법들보다 구현하기 조금 쉬운편이긴 하나 이 방법은 완벽하지가 않기 때문에 방법 자체로는 완벽한 모습을 보이기 어렵고 다른 방법과 같이 사용하여 부족한 부분을 보완하여 사용해야 한다.</p>

<p>일반적으로 <em>Shadow Mapping</em> 이라 말하면 아는 사람은 머릿속에 쉽게 떠오르는 방식이 있다. 빛의 반대쪽 방향에서 충분히 멀리 떨어져 한번 오브젝트를 그린다. 이때 <em>Pixel Shader</em> 를 null 로 설정해서 <em>Depth Buffer</em> 의 데이터만 가져온다. 또는 <em>Pixel Shader</em> 의 출력을 <em>Depth</em> 로 해도 된다. 그러면 보통 아래와 비슷한 2D 텍스쳐를 얻게 된다.</p>

<p><br />
<img src="/images/OGLTuto_DepthTexture.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>검은색에 가까워질수록(0에 가까워질수록) 해당 오브젝트의 위치가 가깝고, 흰색에 가까워질수록(1에 가까워질수록) 물체가 먼것이다. 오브젝트의 <em>Depth</em> 를 렌더링할 때 정점에 사용되는 <em>MVP</em> 변환 중 <em>View</em> 변환은 임의의 위치와 빛의 방향을 계산하여 적용해준다. <em>Camera</em> 를 기준으로 한게 아닌 <em>Light</em> 의 방향을 기준으로 하여 관련된 것을 <em>Light-Space</em> 라고 명명하는 경우도 더러 있다.</p>

<p>이제 생성된 <em>Shadow Map</em> 을 사용하는 방법에 대해 알아보자.</p>

<p><br />
<img src="/images/OGLTuto_lightandshadow.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>위 그림에서 노란색으로 보이는 표면은 빛이 닿는 부분이고, 검은색으로 보이는 표면은 어떤 오브젝트에 의해 가려져 그림자가 드리운 표면이다. 해당 그림 위의 <em>Depth Buffer</em> 를 응용하여 위처럼 가려지는 표면과 안가려지는 표면을 알아낼 수 있다.</p>

<p><em>Depth Buffer</em> 는 <em>Light-Space</em> 를 기준으로 데이터를 저장하고 있다. 그리고 <em>Shader</em> 에서는 <em>Local-Space</em> 로 정점의 위치가 들어오기 때문에 <em>Depth</em> 값을 비교하려면 두 값을 같은 공간으로 맞춰주어야 한다. <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial : Shadow Mapping</a> 에서는 <em>bias</em> 행렬과 <em>Light-Space</em> 가 적용된 행렬을 합성하여 입력으로 들어온 정점 데이터를 <em>Light-Space</em> 기준으로 바꿔준다.</p>

<p>그 다음 정점의 <em>Depth</em>(<em>Z</em>) 값과 <em>Depth Buffer</em> 에서 샘플링한 <em>Depth</em>(<em>Z</em>) 값을 비교하여 현재 정점의 <em>Depth</em> 값이 더 크면(멀면) 그림자를 적용시킨다. 이러면 기본적인 <em>Shadwo Mapping</em> 의 이론은 끝이다. 아래 간단한 <em>GLSL</em> 코드가 있다.</p>

<pre><code class="language-C">vec4 ShadowCoord = DepthBiasMVP * vec4(vertexPosition_modelspace, 1);

float visibility = 1.0;

if (texture( shadowMap, ShadowCoord.xy ).z &lt; ShadowCoord.z) {
    visibility = 0.5;
}
</code></pre>

<p>정점의 위치를 변환시키고, <em>Depth</em> 값에 따라 <em>visibility</em> 값을 변경시켜 그림자를 적용시킨다. 하지만 위에서도 언급했지만 <em>Shadow Mapping</em> 자체에는 조금 문제가 있다고 언급했다. 해당 코드의 결과를 보자.</p>

<p><br />
<img src="/images/OGLTuto_1rstTry.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>위 그림은 굉장히 난장판이다. 세가지의 문제가 있는데 사진의 전체를 봐도 쉽게 알 수 있는 빛이 닿는 영역이 그림자 처리되는 것, <em>Shadow acne</em> 가 생겼다고 말한다. 그리고 왼쪽아래 구석부분에 아주 조금 빛이 들어오는 것처럼 처리되는 것이 있다. 이는 <em>Peter Panning</em> 이라고 부른다. 그리고 마지막으로 그림자와 빛이 닿는 부분의 경계가 울퉁불퉁한게 보일 것이다. 이를 계단현상, <em>aliasing</em> 이라고 부르는데 흔히 게임에서 적용되는 <em>antialiasing</em> 의 반대말이 맞다.</p>

<p>첫번째로 해결할 문제는 <em>Shadow acne</em> 다. 이 문제는 아래 그림을 보면 쉽게 이해가 된다.</p>

<p><br />
<img src="/images/OGLTuto_shadow-acne.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>사선으로 나와있는 노란색 선들은 <em>Shadow Map</em> 을 기준으로 <em>Light-Space</em> 로 변환한 정점의 <em>Depth</em> 값의 기준을 뜻한다. 그리고 표면 자체는 <em>Shadow Map</em> 의 기준이 된다. 그림의 검은색 부분은 빛이 닿는 부분임에도 불구하고 그림자로 처리되는 부분인데, 이를 없에기 위해서는 값을 비교할때 단순하게 <em>bias</em> 를 더해주면 된다.</p>

<pre><code class="language-C">float bias = 0.005;
float visibility = 1.0;

if (texture( shadowMap, ShadowCoord.xy ).z &lt; ShadowCoord.z-bias) {
    visibility = 0.5;
}
</code></pre>

<p>이렇게 적용시키면 평면에서의 <em>acne</em> 들은 제거가 가능하지만 곡면에서의 <em>acne</em> 들이 제거가 안되기 때문에 <em>bias</em> 를 조금 수정해준다.</p>

<pre><code class="language-C">float bias = 0.005*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1
bias = clamp(bias, 0,0.01);
</code></pre>

<p>이러면 <em>Shadow acne</em> 들은 제거된다.</p>

<p><br />
<img src="/images/OGLTuto_VariableBias.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>다음은 <em>Peter Panning</em> 을 언급할 차례다. <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial</a> 에서는 이 문제의 해결책으로 굉장히 단순한 방법을 제시한다. <em>Peter Panning</em> 이 생기지 않도록 충분히 두꺼운 오브젝트를 배치하는 것이다.</p>

<p><br />
<img src="/images/OGLTuto_NoPeterPanning.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>이렇게 쉽게 해결된다.</p>

<p>마지막으로 다룰 문제는 <em>aliasing</em> 이다. 이는 <em>Shadow Mapping</em> 의 고질적인 문제로써 <em>anti-alisasing</em> 기법을 통해 해결해왔다.</p>

<p>첫번째로 <em>Shadow Map</em> 을 샘플링할 때 일반적인 색을 가져오는 샘플링이 아닌 다른 방식을 사용한다. <em>Shadow Map</em> 을 한번 샘플링할 때 하드웨어에서 주변의 텍셀을 샘플링해 주변 텍셀과 비교를 수행해 모든 비교결과를 이중선형 보간을 적용한 결과를 주는 샘플링 방식을 사용한다고 한다. 만약 이중선형 보간을 사용하지 않는다면 <em>Point Sampling</em> 을 여러번 하여 결과들을 사용해 <em>PCF</em> 를 적용시켜주면 된다. 이렇게 해주면 조금 부드러운 결과가 나오게 된다.</p>

<p>하지만 이로써는 만족할만한 결과를 얻을 수 없어 주변을 여러번 샘플링해 값을 가져온다. 미리 생성된 <em>offset</em> 을 사용해 기준 <em>UV</em> 주변을 샘플링한다.</p>

<pre><code class="language-C">for (int i=0;i&lt;4;i++){
  if ( texture( shadowMap, ShadowCoord.xy + poissonDisk[i]/700.0 ).z  &lt;  ShadowCoord.z-bias ){
    visibility-=0.2;
  }
}
</code></pre>

<p>미리 생성된 <em>offset</em> 은 <em>Poisson Disc</em> 방식으로 생성된듯하다. <em>visibility</em> 변수는 색의 어두움을 결정하는 변수로 한번 <em>Depth Test</em> 에 걸리면 0.2를 줄여 0.2 ~ 1 사이의 값을 가진다.</p>

<p>이렇게 두가지 방식으로 <em>anti-aliasing</em> 을 해주면 제법 그럴듯한 결과가 나온다.</p>

<p><br />
<img src="/images/OGLTuto_SoftShadows_Wide.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>또한 <em>UV</em> 좌표에 <em>offset</em> 을 주는 방법은 꽤나 많다. 위의 방법은 랜덤으로 고정된 부분만 체크하지만 이 방법에 임의로 <em>offset</em> 돌려주는 방법도 있다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://www.opengl-tutorial.org/kr/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial : Tutorial 16 Shadow mapping</a></li>
  <li><a href="http://ogldev.atspace.co.uk/www/tutorial42/tutorial42.html">OGLdev : Percentage Closer Filtering</a></li>
  <li><a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">GPU Gems : Chapter 11. Shadow Map Antialiasing</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Supersampling#Poisson_disc">Wikipedia : SuperSampling#poisson_disc</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/29/using-compute-shader-in-unity/">Using Compute Shader In Unity</a>
          </h1>

          <p class="post-meta">Nov 29, 2017 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>Compute Shader</em> 는 <em>DirectX 11</em> 의 등장과 함께 본격적으로 쓰이기 시작했다. 지금은 <em>GPGPU</em> 의 본격적인 기능으로 CPU 에서 처리하기 힘든 계산량을 책임지는 중요한 기능으로 자리잡았다. 실시간으로 현실적인 그래픽을 구현하기 위해 요즘의 게임들은 <em>Compute Shader</em> 를 사용해서 여러 계산을 한다. 조금이라도 퍼포먼스가 필요하다면 당연히 쓰게되는 것이다.</p>

<p>사용하는 방법 자체는 간단하지만 <em>Compute Shader</em> 를 사용해 어떤 기능을 구현하는지가 중요하다. 간단하게 사용방법부터 알아보자. Unity 에서는 <em>Compute Shader</em> 를 위한 파일을 생성해야 한다.</p>

<p><img src="/images/create_computeshader.png" alt="create computeshader" class="center-image" /></p>

<p>프로젝트창에서 위 그림과 같이 생성해주면 된다. 그러면 아래와 같은 기본소스로 파일이 생성된다.</p>

<pre><code class="language-C">// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D&lt;float4&gt; Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!

	Result[id.xy] = float4(id.x &amp; id.y, (id.x &amp; 15)/15.0, (id.y &amp; 15)/15.0, 0.0);
}
</code></pre>

<p>위의 소스는 <em>HLSL</em> 로 코딩된 소스로 <em>DirectX 11</em> 을 기준으로 코딩되어 있다. <em>UnityCG</em> 파일안의 코드를 이용하면 <em>GLSL</em> 로 자동 컨버팅이 되기도 한다. 직접 <em>GLSL</em> 코드로 코딩하고 싶다면 <em>GLSLPROGRAM</em> 과 <em>ENDGLSL</em> 로 코드를 감싸주면 간단하게 해결된다.</p>

<p>내용은 간단하다. 각 텍셀별로 접근이 가능한 <em>Texture</em> 를 이용해서(<em>DirectX</em> 에서는 UAV 라고 칭한다.) <em>Texture</em> 에 값을 채운다. <em>HLSL</em> 의 자세한 문법과 사용방법은 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a> 들을 참고하길 바란다.</p>

<p>또한 쉐이더에서 뿐만아니라 <em>Unity</em> 스크립트상에서도 데이터들을 연결해주어야 한다. 사용하는 유형은 간단하다. <strong>UnityEngine.Texture</strong> 에서 파생된 텍스쳐들, <strong>UnityEngine.RenderTexture</strong>, <strong>UnityEngine.ComputeBuffer</strong> 정도면 모든 활용이 가능하다. <strong>UnityEngine.RenderTexture</strong> 에서는 <em>Cubemap</em> 도 지원하니 간단하게 쓸 수 있다. 해당 인스턴스를 넘겨주는 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;

shader.SetTexture("Result", rt);
</code></pre>

<p>코드에서의 변수명을 맞추어 넣어주거나 해쉬값을 미리 가져와 넣어주면 된다. 다른 유형의 데이터들도 이런 방법으로 넣을 수 있다. 데이터를 넣어주면 다음은 <em>Compute Shader</em> 를 실행하여 결과를 얻어야 한다. 간단하게 함수호출만 해주면 된다. 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;
int kernelIndex = shader.FindKernel("CSMain");

shader.Dispatch(kernelIndex, rt.width / 8, rt.height / 8, 1);
</code></pre>

<p>해당 <em>Compute Shader</em> 소스는 텍스쳐안에 값을 채우는 코드이기 때문에 위와같이 해주었다. <a href="https://docs.unity3d.com/ScriptReference/ComputeShader.Dispatch.html">Unity Reference : ComputeShader.Dispatch</a> 와 위의 <em>Compute Shader</em> 소스를 참고하면 알겠지만 최대 3차원의 방식으로 <em>Compute Shader</em> 의 그룹을 설정하여 계산이 가능하다.  <em>Compute Shader</em> 소스의 <em>[numthreads(8,8,1)]</em> 는 한 그룹의 <em>Thread</em> 갯수를 나타내고, <em>ComputeShader.Dispatch</em> 메소드는 몇개의 그룹을 실행시키는지 넘겨주는 메소드다. 아래 그림을 보면 조금더 쉽게 이해가 가능하다.</p>

<p><br />
<img src="https://msdn.microsoft.com/dynimg/IC520438.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN</a>
</center>
<p><br /></p>

<p><em>Compute Shader</em> 는 <em>DirectX 11</em> 이상, <em>Vulkan</em>,  <em>OpenGL 4.3</em> 이상, <em>OpenGL ES 3.0</em> 이상, <em>Metal</em> 에서 사용가능하다. 그 아래의 플랫폼은 지원하지 않는다. 또 유의해야 할점은 그래픽 드라이버별로 지원 기능이 조금씩 다를 수 있으니 기능을 유의하며 사용해야한다. <a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a> 에서 조금 참고할 수 있다.</p>

<p><a href="/2017/08/01/using-compute-buffer-in-unity/">Using Compute Buffer in Unity</a> 에서 관련된 내용을 언급했으니 같이 보면 좋을듯 하다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a></li>
  <li><a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/18/DrawInstanced-vs-Merged-Instancing/">Drawinstanced Vs Merged Instancing</a>
          </h1>

          <p class="post-meta">Nov 18, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a> 슬라이드에 따르면 <em>DrawInstanced</em> 함수를 사용하여 인스턴싱을 하는것보다 <em>vertexID</em> 를 사용하여 인스턴싱을 하는것이 빠르다고 한다. <em>vertexID</em> 를 쓰는 방법은 굉장히 단순하다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VSOutput VS(uint id : SV_VertexID)
{
    VSOutput output;

    /*
        ...
    */

    return output;
}
</code></pre></div></div>

<p><em>SV_VertexID</em> <em>Semantic</em> 을 사용하여 값을 접근하기만 하면 된다. <em>vertexID</em> 는 말그대로 버텍스별 인덱스를 뜻한다. <em>SRV</em> 나 <em>UAV</em> 와 함께 사용하여 <em>Instancing</em> 을 하면된다.</p>

<p><br />
<img src="/images/gdc2014_vertexshadertricks_23.png" alt="Merge Instancing Performance" /></p>
<center>출처 : <a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a>
</center>
<p><br /></p>

<p>그림을 보면 AMD GPU 에서 확실히 퍼포먼스 차이가 난것을 확인할 수 있다. <del>스피커가 AMD 소속이라는 게 포인트</del></p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-3/">Hbao Plus Analysis 3</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-2/">hbao plus analysis 2</a> 글에서 <em>Horizon based ambient occlusion</em> 와 <em>Cross Bilateral Filter</em> 대해서 알아보았다. 이번 글에서는 부록의 느낌으로 <em>HLSL</em> 코드를 읽으면서 생소했던 기타 기법들에 대해서 써볼 것이다.</p>

<p>첫번째로 <em>Full Screen Triangle</em> 이라는 기법이다. 알고마면 굉장히 단순한 개념으로, 화면을 모두 덮는 한개의 삼각형을 그려서 모든 픽셀에 쉐이더를 돌릴 수 있게 해주는 기법이다. 아래 슬라이드를 보면 쉽게 이해가 갈것이다.</p>

<p><br />
<img src="/images/vertex-shader-tricks-by-bill-bilodeau-amd-at-gdc14-14-638.jpg" alt="Full Screen Triangle" class="center-image" /></p>
<center>출처 : <a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a>
</center>
<p><br /></p>

<p>단순하지만 처음 봤을 때는 조금 신박하게 느껴질 수도 있다. 두번째로는 모든 계산에 최대한 <em>HLSL Intrisic</em> 을 사용한다. 특히 벡터와 벡터사이의 거리를 계산할때 <em>dot product</em> 를 써서 하는게 정말 많았다. 어셈블리 레벨에서 달라지는것 같긴하나 정확한 이유는 알지 못했다. 추측해보면 GPU 에서 해당 명령어가 있지 않을까.. 라고 생각한다.</p>

<p>세번째도 위의 것과 비슷하다. 대부분의 데이터에 <em>MAD</em> 방식을 사용해서 계산한다. 하지만 이는 거의 공식적으로 정해진게 있다. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471418.aspx">MSDN : mad  function</a> 레퍼런스에서도 나오듯이 어떤 GPU 에서는 위에서 추측한대로 하드웨어에서 지원하는 명령어라고 한다.</p>

<blockquote>
  <p>…
Shaders can then take advantage of potential performance improvements by using a native mad instruction (versus mul + add) on some hardware.
…</p>
</blockquote>

<p>또한 <em>HBAO+</em> 소스에서 찾은 주석에는 <em>GK104</em> 부터 특정 구간에서 10% 퍼포먼스 이득이 있다고 쓰여져 있다.</p>

<p>네번째는 나누기를 절대 쓰지 않는다. 나머지 연산(mod, A % B)는 간혹 쓰이지만 나누기는 절대로 쓰이지 않았었다. 혹시라도 필요하다면 전부 <em>Constant Buffer</em> 에 CPU 에서 역수를 취해서 넘겨주는 방식으로 되어 있었다. 이도 역시 하드웨어에서 동작하는 부분을 알고 짠듯하다.</p>

<p>다섯번째는 <em>HLSL</em> 코드를 <em>cpp</em> 소스에 <em>include</em> 하여 <em>Constant Buffer</em> 값을 갱신하는 코드였다. 여태까지 예전의 <em>DirectX</em> 소스만 보거나 <em>Unity</em> 에서만 작업을 해서 그런지 이런 기능은 굉장히 낯설었다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a></li>
  <li><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471418.aspx">MSDN : mad function</a></li>
</ul>

        </div>

        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/3/">&laquo; Older</a>
    

    
      <a class="next" href="/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2018 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
