<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Appocrypha</title>
  <meta name="description" content="store limitless knowledges">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/posts/2/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Appocrypha">
  <meta name="twitter:description" content="store limitless knowledges">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/01/11/unity-scripted-importer/">Unity Scripted Importer</a>
          </h1>

          <p class="post-meta">Jan 11, 2018 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 의 에디터 시스템은 꽤나 유연하다. 이번 글에서는 <em>AssetImporter</em> 에 대한 기능들에 대하여 알아볼 것이다.</p>

<p>Unity 의 각각의 Asset 들은 확장자의 이름에 따라서 <em>AssetImporter</em> 가 하나씩 만들어지고, 해당 <em>AssetImporter</em> 에 따라서 <em>Post-Process</em> 가 진행된다. 필자가 많이 봤던 <em>AssetImporter</em> 는 <a href="https://docs.unity3d.com/ScriptReference/TextureImporter.html"><em>TextureImporter</em></a> 와 <a href="https://docs.unity3d.com/ScriptReference/ModelImporter.html"><em>ModelImporter</em></a> 가 있었다. 확인할 당시에는 당연히 <em>AssetImporter</em> 를 커스터마이징 할 수 있겠다는 생각이 들어 찾아봤지만 전혀 없었다.(Unity 5 버젼을 사용할 때다.) 이렇게 시스템을 만들어 놓고 왜 없냐는 의문이 들었지만 이는 정말 할수있는게 없었기에 넘어갔었다.</p>

<p>그런데 이번에 Unity 2018.1 베타가 릴리즈 되면서 SRP 를 살펴보던 도중 <em>Expremental</em> 기능들 중에 <a href="https://docs.unity3d.com/2018.1/Documentation/Manual/ScriptedImporters.html"><em>ScriptedImporter</em></a> 라는 기능이 있는 것을 발견했다.</p>

<p>이 기능은 말그대로 예전의 내가 원하던 기능이였다. <em>AssetImporter</em> 클래스와 다른점은 딱 한가지다. 가상 <em>OnImportAsset</em> 메소드가 존재하는 것이다. 즉 <em>ScriptedImporter</em> 를 상속하여 <em>OnImportAsset</em> 를 구현하면 간단하게 에셋을 <em>Customize</em> 할 수 있는 것이다. 또한 에디터 기능을 지원하는 <a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporterEditor.html">ScriptedImporterEditor </a> 라는 클래스를 사용하면 에디터를 손쉽게 바꿀 수 있다. 자세한 사항은 글에서 언급된 링크를 통해 보면 된다.</p>

<h2>참조</h2>
<ul>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/Manual/ScriptedImporters.html">Unity Documentation : ScriptedImporter </a></li>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporter.html">Unity Reference : ScriptedImporter</a></li>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporterEditor.html">Unity Reference : ScriptedImporterEditor </a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/27/percentage-closer-soft-shadows/">Percentage Closer Soft Shadows</a>
          </h1>

          <p class="post-meta">Dec 27, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/pcss/">pcss</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/12/19/shadow-map-filtering/">Shadow Map Filtering</a> 에서 <em>PCF</em> 와 <em>VSM</em> 에 대하여 간단히 알아보았다. 이번 글에서 설명할 것은 <em>PCF</em> 를 활용한 <em>PCSS</em> 다.</p>

<p><em>PCSS</em> 는 <em>Soft Shadow</em> 를 구현하는 기법 중 하나로써 2005년에 발표되어 여태까지도 꽤나 알려진 기법이다. 우선 <em>Soft Shadow</em> 가 무엇인지 알아보자.</p>

<p><br /></p>

<p><img src="/images/soft_vs_hardshadow.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.assignmentpoint.com/science/computer/real-time-soft-shadow-rendering.html">assignmentpoint.com : Real Time Soft Shadow Rendering</a>
</center>
<p><br /></p>

<p>위와 같이 빛을 가린 물체와 거리가 멀어지면 멀어질수록 밝아지는 그림자를 <em>Soft Shadow</em> 라고 한다. 완전한 <em>Hard Shadow</em> 는 어색하기 때문에 보통 <em>PCF</em> 를 사용하여 끝부분을 부드럽게 처리했으나, 태양광 처럼 길게 그림자를 만드는 경우가 있으면 끝 부분이 가면 갈수록 부드러워져야 한다.</p>

<p><br /></p>

<p><img src="/images/tree_shadow.jpg" alt="" class="center-image" /></p>
<center>출처 : <a href="https://www.youtube.com/watch?v=Ax8G8P3tA28">Youtube
</a>
</center>
<p><br /></p>

<p>태양 빛에의해 만들어진 나무의 그림자다. 짧은 길이의 그림자는 적당히 <em>PCF</em> 로 대략 표현이 가능하나 이런 길은 그림자를 고정된 사이즈의 <em>PCF</em> 로 표현하기엔 무리가 있다. 그래서 나온것이 <em>PCSS</em> 다.</p>

<p><em>PCSS</em> 를 보기전에, 우리가 알아야할 용어들이 있다. 바로 <em>Umbra</em> 와 <em>Penumbra</em> 다.</p>

<p><br /></p>

<p><img src="/images/umbra_penumbra_antumbra.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://en.wikipedia.org/wiki/Umbra,_penumbra_and_antumbra">Wikipedia : Umbra, penumbra and antumbra </a>
</center>
<p><br /></p>

<p><em>Soft Shadow</em> 가 표현하는 부드러운 부분의 그림자는 위 그림에서도 보이듯이 <em>Penumbra</em> 라고 한다. <em>PCSS</em> 에서는 부드러운 부분의 그림자를 <em>Penumbra</em> 라고 한다. <em>PCSS</em> 에서는 <em>Penumbra</em> 의 크기를 사용하여 <em>PCF</em> 의 샘플링 범위를 정해준다. 우선 <em>PCSS</em> 의 <em>Penumbra</em> 를 계산하는 방법을 보자.</p>

<p><br /></p>

<p><img src="/images/PCSS_PenumbraSizeEstimation.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://http.download.nvidia.com/developer/presentations/2005/SIGGRAPH/Percentage_Closer_Soft_Shadows.pdf">Siggraph 2005 : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>맨위의 노란색으로 표시된 부분은 광원을 뜻하며, 일정한 범위로 빛을 비추는 <em>Area Light</em> 로 가정한 후 계산한다. W - light 는 <em>Area Light</em> 의 범위를 뜻한다. 중간에 있는 <em>Blocker</em> 는 빛을 가리는 물체를 뜻하며, d blocker 는 가리는 물체와 빛과의 거리, d receiver 는 그림자가 비추는 물체와 광원 사이의 거리를 뜻한다. 그림자를 받는 부분과 빛을 가리는 물체와 광원을 서로 평행하다고 가정해서 계산한다. 2차원의 그림을 3차원으로 바꿔보자.</p>

<p><br /></p>

<p><img src="/images/PCSS_Scheme.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>보통 <em>Pixel Shader</em> 에서 그림자의 비춘 정도를 계산하기 때문에 <em>Receiver</em> 의 작은 부분을 기준으로 그림이 그려져 있다. 작은 부분을 기준으로 <em>Area Light</em> 와의 <em>frustum</em> 과 <em>Blocker</em> 가 얼마나 충돌되는지 체크한다. 우리는 <em>Shadow Map</em> 을 사용하기 때문에 아래 그림이 조금 더 실제 계산과 비슷하다.</p>

<p><br /></p>

<p><img src="/images/PCSS_Scheme2.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>그래서 <em>Shadow Map</em> 의 빨간색으로 하이라이트 된 부분을 샘플링해 얼마나 가리고 있는지를 확인한다. 그러면 빛을 받는 정도를 알 수 있게 되는것이다. 해당 부분을 적당히 샘플링한 다음 평균을 구해서 <em>PCF</em> 로 샘플링하는 범위를 계산한다. 계산하여 <em>PCF</em> 에서 범위를 사용해 계산한다. 코드를 보면서 이해해보자.</p>

<p><br /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">PCSS_Shadow</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="n">float2</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="kt">float</span> <span class="n">zEye</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 1: blocker search</span>
	<span class="c1">// ------------------------</span>
	<span class="kt">float</span> <span class="n">accumBlockerDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">numBlockers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">float2</span> <span class="n">searchRegionRadiusUV</span> <span class="o">=</span> <span class="n">SearchRegionRadiusUV</span><span class="p">(</span><span class="n">zEye</span><span class="p">);</span>
	<span class="n">FindBlocker</span><span class="p">(</span><span class="n">accumBlockerDepth</span><span class="p">,</span> <span class="n">numBlockers</span><span class="p">,</span> <span class="n">g_shadowMap</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="n">searchRegionRadiusUV</span><span class="p">);</span>

	<span class="c1">// Early out if not in the penumbra</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numBlockers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">numBlockers</span> <span class="o">==</span> <span class="n">BLOCKER_SEARCH_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 2: penumbra size</span>
	<span class="c1">// ------------------------</span>
	<span class="kt">float</span> <span class="n">avgBlockerDepth</span> <span class="o">=</span> <span class="n">accumBlockerDepth</span> <span class="o">/</span> <span class="n">numBlockers</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">avgBlockerDepthWorld</span> <span class="o">=</span> <span class="n">ZClipToZEye</span><span class="p">(</span><span class="n">avgBlockerDepth</span><span class="p">);</span>
	<span class="n">float2</span> <span class="n">penumbraRadiusUV</span> <span class="o">=</span> <span class="n">PenumbraRadiusUV</span><span class="p">(</span><span class="n">zEye</span><span class="p">,</span> <span class="n">avgBlockerDepthWorld</span><span class="p">);</span>
	<span class="n">float2</span> <span class="n">filterRadiusUV</span> <span class="o">=</span> <span class="n">ProjectToLightUV</span><span class="p">(</span><span class="n">penumbraRadiusUV</span><span class="p">,</span> <span class="n">zEye</span><span class="p">);</span>

	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 3: filtering</span>
	<span class="c1">// ------------------------</span>
	<span class="k">return</span> <span class="n">PCF_Filter</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="n">filterRadiusUV</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<center>출처 : <a href="https://github.com/NVIDIAGameWorks/D3DSamples">Github NVIDIAGameWorks : D3DSamples</a>
</center>
<p><br /></p>

<p>해당 픽셀이 어두워지는 정도를 반환하는 <em>PCSS</em> 계산 함수다. 코드의 주석에서는 계산을 세단계로 나눈다. 첫번째로는 <em>Shadow Map</em> 을 샘플링해서 얼마나 빛이 얼마나 가려지는지 계산한다. 이를 <em>STEP 1: blocker search</em> 라고 표기해놓았고, 두번째는 <em>PCF</em> 에서 샘플링할 범위를 결정하는 넓이를 계산한다. 이를 <em>STEP 2: penumbra size</em> 라고 한다. 세번째로는 <em>PCF</em> 를 계산해서 가려지는 정도를 반환한다. 자세한 코드는 출처에서 <em>SoftShadows</em> 항목을 들어가면 볼 수 있다.</p>

<p><em>PCSS</em> 의 장점은 아무래도 확실한 <em>Soft Shadow</em> 를 구현했다는 점이다. 비록 대략적으로 가정한 부분이 많지만 장면별로 잘 맞춰주기만 한다면 괜찮은 결과가 나올것 같다. 하지만 샘플링 횟수가 꽤나 된다. <em>PCF</em> 만 하더라도 가볍지는 않은 편인데, <em>Blocker</em> 를 계산하느라 더 많이 샘플링을 한다. 하지만 잘 만들어진 게임과 요즘의 GPU 에서는 아주 큰 오버헤드는 없는걸로 보인다. (<a href="https://www.reddit.com/r/nvidia/comments/49idz3/nvidia_hfts_the_division/">Redit : Nvidia HFTS (The Division)</a>)</p>

<h2>참조</h2>
<ul>
  <li><a href="https://http.download.nvidia.com/developer/presentations/2005/SIGGRAPH/Percentage_Closer_Soft_Shadows.pdf">Siggraph 2005 : Percentage-Closer Soft Shadows</a></li>
  <li><a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a></li>
  <li><a href="https://github.com/NVIDIAGameWorks/D3DSamples">Github NVidiaGameWorks : D3DSample</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/19/shadow-map-filtering/">Shadow Map Filtering</a>
          </h1>

          <p class="post-meta">Dec 19, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/vsm/">vsm</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/11/30/what-is-shadow-mapping/">What is Shadow Mapping</a> 에서 <em>Shadow Mapping</em> 에 대한 간단한 번역 &amp; 설명을 적어놓았다. 해당 글에서 <em>PCF</em> 를 잠깐 언급했었다. 이 글에서는 <em>PCF</em> 를 포함해서 <em>Shadow Map</em> 을 필터링하는 방법에 대해서 알아보겠다.</p>

<p>첫번째는 <em>PCF</em> 다. 풀어쓰면 <em>Percentage Closer Filtering</em> 이라는 단어가 되며, <em>Shadow Map</em> 을 여러번 샘플링해 <em>Percentage</em> 를 소숫점으로 나타내서 <em>Shadow</em> 가 생긴 정도를 나타내주는 <em>Filtering</em> 기법이다. 쉽게 이해할 수 있도록 아래 그림을 보자.</p>

<p><br />
<img src="/images/PCF_Scheme.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://graphics.pixar.com/library/ShadowMaps/paper.pdf">Pixar : Rendering Antialiased Shadows with Depth Maps</a>
</center>
<p><br /></p>

<p>위의 a) 는 아무것도 필터링 하지 않을 때의 <em>ShadowMap</em> 샘플링하는 것을 보여주고, 아래 b) 는 <em>PCF</em> 를 사용해 샘플링하는 것을 보여준다. 위 그림에서 <em>Surface at z = 49.8</em> 은 그림자를 처리할 표면의 <em>Depth</em> 또는 <em>Z</em> 을 뜻한다. 그리고 <em>Light-Space</em> 를 기준으로 해당 값보다 <em>Depth</em> 값이 멀다고 판단될시에는 처리하지 않고, 가깝다고 판단될 때는 처리하는 걸로 해준다. <em>Shadow Map</em> 에서 한 부분만 샘플링해서 하는 것이 윗 부분의 그림이고, 한 부분이 아닌 근처의 여러 부분을 샘플링해서 값을 구하는 것이 <em>PCF</em> 다.</p>

<p>아래에 <em>PCF</em> 를 사용하는 코드가 있다.</p>

<p><br /></p>

<pre><code class="language-HLSL">float PCF_FILTER( float2 tex, float fragDepth )
{
    //PreShader - This should all be optimized away by the compiler
    //====================================
    float fStartOffset = BoxFilterStart( fFilterWidth );
    float texOffset = 1.0f / fTextureWidth;
    //====================================

    fragDepth -= 0.0001f;
    tex -= fStartOffset * texOffset;

    float lit = 0.0f;
		for( int i = 0; i &lt; fFilterWidth; ++i )
			for( int j = 0; j &lt; fFilterWidth; ++j )
			{
				lit += texShadowMap.SampleCmpLevelZero(
                                FILT_PCF,
                                float2( tex.x + i * texOffset, tex.y + j * texOffset ),
                                fragDepth
                              );
			}
	return lit / ( fFilterWidth * fFilterWidth );
}
</code></pre>

<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a>
</center>
<p><br /></p>

<p>자세한 코드는 위의 출처에서 코드를 구해서 보면 될듯하다. <em>Texture2D::SampleCmpLevelZero</em> 는 <em>MipMap</em> 참조 레벨은 0으로 한채 텍스쳐의 값을 샘플링하여 주어진 인자와 비교하여 <em>Sampler</em> 에 정해준 방식에 적합하면 1, 적합하지 않으면 0을 반환해준다.</p>

<p>해당 그림에서는 평균을 구하는 방법을 표기해놓았으나 다른 <em>NDF</em> 를 써서 구현할 수도 있다.(<em>Gaussian Distribution</em>) 또한 규칙적으로 샘플링하는게 아닌 <em>jitter</em> 를 사용해서 샘플링할 수도 있다고 한다. 일반적으로 <em>Poisson disk Distribution</em> 을 사용한다고 한다.</p>

<p><em>PCF</em> 의 단순한 방법으로 <em>Shadow Map</em> 을 <em>AntiAliasing</em> 할 수 있다. 하지만 <em>Shadow Map</em> 의 샘플링 횟수가 <em>PCF Kernel</em>(3x3, 5x5..) 이 커지면 커질수록 많아지기 때문에 꽤나 큰 <em>PCF Kernel</em> 에서는 샘플링 부하가 걸릴 수 있다. 성능상 단점이 크나 <em>PCF</em> 는 굉장히 많이 사용되는 기법 중에 하나라고 한다.</p>

<p>다음은 <em>Variance Shadow Map</em> 이다. 이는 <a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality"><em>Chebyshev’s Inequality</em></a> 라는 통계학의 개념을 사용해 <em>Filtering</em> 해준다. 먼저 <em>Shadow Map</em> 을 저장할 때 <em>Depth</em> 만 저장하는게 아닌 <em>Depth</em> 의 제곱값 또한 같이 저장한다. <em>Filtering</em> 에 쓰일 공식을 위해 같이 넣는다.</p>

<p>다음은 아래 코드와 같이 공식을 계산해준다.</p>

<p><br /></p>

<pre><code class="language-HLSL">float VSM_FILTER( float2 tex, float fragDepth )
{
    float lit = (float)0.0f;
    float2 moments = texShadowMap.Sample( FILT_LINEAR,    float3( tex, 0.0f ) );

    float E_x2 = moments.y;
    float Ex_2 = moments.x * moments.x;
    float variance = E_x2 - Ex_2;    
    float mD = (moments.x - fragDepth );
    float mD_2 = mD * mD;
    float p = variance / (variance + mD_2 );
    lit = max( p, fragDepth &lt;= moments.x );

    return lit;
}
</code></pre>

<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a>
</center>
<p><br /></p>

<p>눈여겨 볼것은 샘플러를 <em>Linear</em> 하게 설정해놓는 것이다.</p>

<p>하지만 <em>VSM</em> 은 큰 단점이 하나 있다. 바로 <em>Light Leaking</em> 이 일어나는 것이다. 이는 <a href="https://http.download.nvidia.com/developer/presentations/2006/gdc/2006-GDC-Variance-Shadow-Maps.pdf">GDC 2006 : Variance Shadow Map</a> 에서 참조할 수 있다. 이를 해결 하는 근본적인 방법은 없다고 한다.</p>

<p>두가지 기법의 차이는 텍스쳐 샘플링을 더 많이 하느냐, 메모리를 2배로 늘려주느냐의 차이에 있다. 속도를 따지면 <em>VSM</em> 이 빠르다고 한다. 하지만 굳이 퍼포먼스를 낼 필요가 없다면 <em>PCF</em> 를 사용하는 것도 나쁜 선택은 아닐것 같다. 선택에 대한 궁금증은 <a href="https://www.opengl.org/discussion_boards/showthread.php/177219-Shadow-filtering-PCF-better-than-VSM">OpenGL Forum : Shadow filtering: PCF better than VSM? </a> 글을 참조하길 바란다.</p>

<h2>참조</h2>
<ul>
  <li><a href="https://graphics.pixar.com/library/ShadowMaps/paper.pdf">Pixar : Rendering Antialiased Shadows with Depth Maps</a></li>
  <li><a href="https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb509697.aspx">MSDN : SampleCmpLevelZero</a></li>
  <li><a href="http://www.punkuser.net/vsm/">Variance Shadow Maps</a></li>
  <li><a href="https://http.download.nvidia.com/developer/presentations/2006/gdc/2006-GDC-Variance-Shadow-Maps.pdf">GDC 2006 : Variance Shadow Maps</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality">Wikipedia : Chebyshev’s inequality</a></li>
  <li><a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">GPU Gems : Shadow Map Antialiasing</a></li>
  <li><a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a></li>
  <li><a href="https://github.com/TheRealMJP/Shadows">Github : TheRealMJP - Shadows</a></li>
  <li><a href="https://www.opengl.org/discussion_boards/showthread.php/177219-Shadow-filtering-PCF-better-than-VSM">OpenGL Forum : Shadow filtering: PCF better than VSM? </a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/17/cascaded-shadow-mapping/">Cascaded Shadow Mapping</a>
          </h1>

          <p class="post-meta">Dec 17, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/csm/">csm</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/11/30/what-is-shadow-mapping/">What is Shadow Mapping</a> 에서 <em>Shadow Mapping</em> 에 대한 간단한 번역 &amp; 설명을 적어놓았다. 이번 글에서는 <em>Shadow Mapping</em> 을 효과적으로 사용하기 위한 <em>Cascaded Shadow Mapping</em> 에 대하여 적어보겠다.</p>

<p><em>Cascaded Shadow Mapping</em> 을 구글 번역기에 돌려보면 <em>“계단식 그림자 매핑”</em> 이라고 나온다. 조금 직관적이지 않은 말이지만 뜻 자체는 맞다. 간단하게 <em>Cascaded Shadow Mapping</em> 에 대하여 말하자면 넓은 환경의 그림자를 위해 거리에(거의 <em>Depth</em>) 따라서 여러개의 <em>Shadow Map</em> 을 생성하는 방법이다.</p>

<p>넓은 범위의 <em>Directional Light</em> 가 닿는 그림자를 정확하게 표현하려면 꽤나 큰 크기의 <em>Shadow Map</em> 을 사용해야 한다. 하지만 <em>Cascaded Shadow Mapping</em> 을 사용한다면 여러개의 <em>Shadow Map</em> 을 사용하여 보다 조금의 메모리를 사용하여 넓은 범위의 그림자를 표현할 수 있다.</p>

<h2>Shadow-map generation</h2>

<p><em>Cascaded Shadow Mapping</em> 을 위한 <em>Shadow Map</em> 생성은 앞서쓴 <a href="/2017/11/30/what-is-shadow-mapping/">글</a>에서 설명한 방법과 거의 유사하다. 앞서 여러개의 <em>Shadow Map</em> 을 생성하여 그림자를 표현한다고 언급했었다. 여러개의 <em>Shaodw Map</em> 을 생성하는 기준은 <em>View frustum</em> 을 <em>Depth</em> 를 기준으로 여러개로 쪼개어 각 쪼개진 <em>frustum</em> 을 기준으로 <em>Shadow Map</em> 을 그린다.</p>

<p><em>frustum</em> 은 보통 <em>Depth</em> 값을 정하거나 어떤 알고리즘을 사용하여 쪼갠다. 이는 다음 포스팅에서 언급할 예정이다. <em>frustum</em> 을 쪼개주면 다음은 쪼개진 <em>Camera View frustum</em> 의 각각의 8개의 꼭지점들을 <em>Light-Space</em> 로 변환한다. 변환된 각각 꼭지점으로 2차원의 <em>aligned axis bounding box</em> 의 위치를 구해준다. 가장 작은 X,Y 값과 가장 큰 X, Y 값을 구해주면 된다.</p>

<p><br />
<img src="/images/CSM_EffectOfCropMatrix.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>위 그림에서 XY 평면에서의 빨간색 선으로 되어있는 사각형이 언급한 <em>aligned axis bounding box</em> 를 말한다. 이 <em>AABB</em> 는 아래에서 특정한 행렬을 만들때 쓰인다.</p>

<p><a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Maps  </a> 에서는 이 <em>Light-Space</em> 로 변환하는 <em>MVP 변환</em> 에서 <em>Projection</em> 변환을 바꿔준다고 설명한다. 두개의 행렬이 나오는데, 하나는 직교 투영 행렬로(<em>orthogonal projection</em>) 나눠진 <em>frustum</em> 의 <em>Far</em> 값과 <em>Near</em> 값을 통해 생성해준다. 그리고 나머지 하나는 <em>Crop Matrix</em> 라는 변환 행렬이다.</p>

<p>위에서 구한 <em>Light-Space</em> 의 <em>AABB</em> 값을 통해 <em>Crop Matrix</em> 를 계산한다. 아래 그림에서나오는 Mx, My 와 mx, my 는 각각 Maximum X,Y, Minimum X,Y 를 뜻한다.</p>

<p><br />
<img src="/images/CSM_CropMatrixCalc.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>이렇게 계산된 <em>Crop Matrix</em> 의 역할은 해당 <em>AABB</em> 로 <em>Shadow Map</em> 이 그려질 범위를 결정해주는 역할을 한다. 다만 범위가 아주 정확하지는 않다. 아래 그림을 보자.</p>

<p><br />
<img src="/images/CSM_FarMiddleNear.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://ogldev.atspace.co.uk/www/tutorial49/tutorial49.html">OGLdev : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>위 그림과 같이 보통은 겹치는 부분이 생긴다. 사용시에는 <em>Depth</em> 에 따라서 다르게 사용하기 때문에 크게 문제는 없다. 사용시에는 <em>Depth</em> 값에 따라서 다른 텍스쳐를 가져오는 것과 텍스쳐를 샘플링할때 UV 값을 정점의 위치를 <em>Light-Space</em> 로 변환해서 변환된 정점의 위치의 X,Y 좌표를 UV 값으로 사용하면 된다. 다만 각각의 <em>Shadow Map</em> 마다 변환 행렬은 <em>Crop Matrix</em> 때문에 다르기 때문에 따로 접근해야 한다.</p>

<p>자세한 사용법을 알고 싶으면 <a href="http://developer.download.nvidia.com/SDK/10/Samples/cascaded_shadow_maps.zip">NVidia : Cascaded Shadow Map Example</a>에서 소스를 받아 보면 된다.</p>

<h2>추가</h2>

<p><em>Cascaded Shadow Map</em> 을 <em>1 pass</em> 로 그리는 방법은 간단하다. 우선 <em>Shadow Map</em> 들을 <em>TextureArray</em> 를 통해 저장하고, <em>RenderTarget</em> 을 <em>Geometry Shader</em> 에서 각각의 렌더타겟별로 지오메트리를 추가해주어 각각의 <em>Pixel Shader</em> 를 실행시키면 된다. 자세한 코드는 <a href="https://www.slideshare.net/dgtman/implements-cascaded-shadow-maps-with-using-texture-array">여기</a>에서 볼 수 있다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Maps  </a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416307.aspx">MSDN : Cascaded Shadow Maps</a></li>
  <li><a href="https://github.com/TheRealMJP/Shadows">Github : TheRealMJP - Shadows</a></li>
  <li><a href="http://ogldev.atspace.co.uk/www/tutorial49/tutorial49.html">OGLDev : Cascaded Shadow Mapping</a></li>
  <li><a href="https://www.slideshare.net/dgtman/implements-cascaded-shadow-maps-with-using-texture-array">Slideshare : implements Cascaded Shadow Maps with using TexturArray(한글)</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/30/what-is-shadow-mapping/">What Is Shadow Mapping</a>
          </h1>

          <p class="post-meta">Nov 30, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>※ 이 글은 <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial : shadow mapping</a> 게시물을 참고하여 쓰여졌습니다. 자세한 내용은 원문을 보는게 좋습니다.</p>

<p><em>Shadow Mapping</em> 실시간으로 그림자를 구현하기 위한 방법 중에 가장 널리 알려진 방법이다. 다른 방법들보다 구현하기 조금 쉬운편이긴 하나 이 방법은 완벽하지가 않기 때문에 방법 자체로는 완벽한 모습을 보이기 어렵고 다른 방법과 같이 사용하여 부족한 부분을 보완하여 사용해야 한다.</p>

<p>일반적으로 <em>Shadow Mapping</em> 이라 말하면 아는 사람은 머릿속에 쉽게 떠오르는 방식이 있다. 빛의 반대쪽 방향에서 충분히 멀리 떨어져 한번 오브젝트를 그린다. 이때 <em>Pixel Shader</em> 를 null 로 설정해서 <em>Depth Buffer</em> 의 데이터만 가져온다. 또는 <em>Pixel Shader</em> 의 출력을 <em>Depth</em> 로 해도 된다. 그러면 보통 아래와 비슷한 2D 텍스쳐를 얻게 된다.</p>

<p><br />
<img src="/images/OGLTuto_DepthTexture.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>검은색에 가까워질수록(0에 가까워질수록) 해당 오브젝트의 위치가 가깝고, 흰색에 가까워질수록(1에 가까워질수록) 물체가 먼것이다. 오브젝트의 <em>Depth</em> 를 렌더링할 때 정점에 사용되는 <em>MVP</em> 변환 중 <em>View</em> 변환은 임의의 위치와 빛의 방향을 계산하여 적용해준다. <em>Camera</em> 를 기준으로 한게 아닌 <em>Light</em> 의 방향을 기준으로 하여 관련된 것을 <em>Light-Space</em> 라고 명명하는 경우도 더러 있다.</p>

<p>이제 생성된 <em>Shadow Map</em> 을 사용하는 방법에 대해 알아보자.</p>

<p><br />
<img src="/images/OGLTuto_lightandshadow.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>위 그림에서 노란색으로 보이는 표면은 빛이 닿는 부분이고, 검은색으로 보이는 표면은 어떤 오브젝트에 의해 가려져 그림자가 드리운 표면이다. 해당 그림 위의 <em>Depth Buffer</em> 를 응용하여 위처럼 가려지는 표면과 안가려지는 표면을 알아낼 수 있다.</p>

<p><em>Depth Buffer</em> 는 <em>Light-Space</em> 를 기준으로 데이터를 저장하고 있다. 그리고 <em>Shader</em> 에서는 <em>Local-Space</em> 로 정점의 위치가 들어오기 때문에 <em>Depth</em> 값을 비교하려면 두 값을 같은 공간으로 맞춰주어야 한다. <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial : Shadow Mapping</a> 에서는 <em>bias</em> 행렬과 <em>Light-Space</em> 가 적용된 행렬을 합성하여 입력으로 들어온 정점 데이터를 <em>Light-Space</em> 기준으로 바꿔준다.</p>

<p>그 다음 정점의 <em>Depth</em>(<em>Z</em>) 값과 <em>Depth Buffer</em> 에서 샘플링한 <em>Depth</em>(<em>Z</em>) 값을 비교하여 현재 정점의 <em>Depth</em> 값이 더 크면(멀면) 그림자를 적용시킨다. 이러면 기본적인 <em>Shadwo Mapping</em> 의 이론은 끝이다. 아래 간단한 <em>GLSL</em> 코드가 있다.</p>

<pre><code class="language-C">vec4 ShadowCoord = DepthBiasMVP * vec4(vertexPosition_modelspace, 1);

float visibility = 1.0;

if (texture( shadowMap, ShadowCoord.xy ).z &lt; ShadowCoord.z) {
    visibility = 0.5;
}
</code></pre>

<p>정점의 위치를 변환시키고, <em>Depth</em> 값에 따라 <em>visibility</em> 값을 변경시켜 그림자를 적용시킨다. 하지만 위에서도 언급했지만 <em>Shadow Mapping</em> 자체에는 조금 문제가 있다고 언급했다. 해당 코드의 결과를 보자.</p>

<p><br />
<img src="/images/OGLTuto_1rstTry.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>위 그림은 굉장히 난장판이다. 세가지의 문제가 있는데 사진의 전체를 봐도 쉽게 알 수 있는 빛이 닿는 영역이 그림자 처리되는 것, <em>Shadow acne</em> 가 생겼다고 말한다. 그리고 왼쪽아래 구석부분에 아주 조금 빛이 들어오는 것처럼 처리되는 것이 있다. 이는 <em>Peter Panning</em> 이라고 부른다. 그리고 마지막으로 그림자와 빛이 닿는 부분의 경계가 울퉁불퉁한게 보일 것이다. 이를 계단현상, <em>aliasing</em> 이라고 부르는데 흔히 게임에서 적용되는 <em>antialiasing</em> 의 반대말이 맞다.</p>

<p>첫번째로 해결할 문제는 <em>Shadow acne</em> 다. 이 문제는 아래 그림을 보면 쉽게 이해가 된다.</p>

<p><br />
<img src="/images/OGLTuto_shadow-acne.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>사선으로 나와있는 노란색 선들은 <em>Shadow Map</em> 을 기준으로 <em>Light-Space</em> 로 변환한 정점의 <em>Depth</em> 값의 기준을 뜻한다. 그리고 표면 자체는 <em>Shadow Map</em> 의 기준이 된다. 그림의 검은색 부분은 빛이 닿는 부분임에도 불구하고 그림자로 처리되는 부분인데, 이를 없에기 위해서는 값을 비교할때 단순하게 <em>bias</em> 를 더해주면 된다.</p>

<pre><code class="language-C">float bias = 0.005;
float visibility = 1.0;

if (texture( shadowMap, ShadowCoord.xy ).z &lt; ShadowCoord.z-bias) {
    visibility = 0.5;
}
</code></pre>

<p>이렇게 적용시키면 평면에서의 <em>acne</em> 들은 제거가 가능하지만 곡면에서의 <em>acne</em> 들이 제거가 안되기 때문에 <em>bias</em> 를 조금 수정해준다.</p>

<pre><code class="language-C">float bias = 0.005*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1
bias = clamp(bias, 0,0.01);
</code></pre>

<p>이러면 <em>Shadow acne</em> 들은 제거된다.</p>

<p><br />
<img src="/images/OGLTuto_VariableBias.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>다음은 <em>Peter Panning</em> 을 언급할 차례다. <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial</a> 에서는 이 문제의 해결책으로 굉장히 단순한 방법을 제시한다. <em>Peter Panning</em> 이 생기지 않도록 충분히 두꺼운 오브젝트를 배치하는 것이다.</p>

<p><br />
<img src="/images/OGLTuto_NoPeterPanning.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>이렇게 쉽게 해결된다.</p>

<p>마지막으로 다룰 문제는 <em>aliasing</em> 이다. 이는 <em>Shadow Mapping</em> 의 고질적인 문제로써 <em>anti-alisasing</em> 기법을 통해 해결해왔다.</p>

<p>첫번째로 <em>Shadow Map</em> 을 샘플링할 때 일반적인 색을 가져오는 샘플링이 아닌 다른 방식을 사용한다. <em>Shadow Map</em> 을 한번 샘플링할 때 하드웨어에서 주변의 텍셀을 샘플링해 주변 텍셀과 비교를 수행해 모든 비교결과를 이중선형 보간을 적용한 결과를 주는 샘플링 방식을 사용한다고 한다. 만약 이중선형 보간을 사용하지 않는다면 <em>Point Sampling</em> 을 여러번 하여 결과들을 사용해 <em>PCF</em> 를 적용시켜주면 된다. 이렇게 해주면 조금 부드러운 결과가 나오게 된다.</p>

<p>하지만 이로써는 만족할만한 결과를 얻을 수 없어 주변을 여러번 샘플링해 값을 가져온다. 미리 생성된 <em>offset</em> 을 사용해 기준 <em>UV</em> 주변을 샘플링한다.</p>

<pre><code class="language-C">for (int i=0;i&lt;4;i++){
  if ( texture( shadowMap, ShadowCoord.xy + poissonDisk[i]/700.0 ).z  &lt;  ShadowCoord.z-bias ){
    visibility-=0.2;
  }
}
</code></pre>

<p>미리 생성된 <em>offset</em> 은 <em>Poisson Disc</em> 방식으로 생성된듯하다. <em>visibility</em> 변수는 색의 어두움을 결정하는 변수로 한번 <em>Depth Test</em> 에 걸리면 0.2를 줄여 0.2 ~ 1 사이의 값을 가진다.</p>

<p>이렇게 두가지 방식으로 <em>anti-aliasing</em> 을 해주면 제법 그럴듯한 결과가 나온다.</p>

<p><br />
<img src="/images/OGLTuto_SoftShadows_Wide.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>또한 <em>UV</em> 좌표에 <em>offset</em> 을 주는 방법은 꽤나 많다. 위의 방법은 랜덤으로 고정된 부분만 체크하지만 이 방법에 임의로 <em>offset</em> 돌려주는 방법도 있다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://www.opengl-tutorial.org/kr/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial : Tutorial 16 Shadow mapping</a></li>
  <li><a href="http://ogldev.atspace.co.uk/www/tutorial42/tutorial42.html">OGLdev : Percentage Closer Filtering</a></li>
  <li><a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">GPU Gems : Chapter 11. Shadow Map Antialiasing</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Supersampling#Poisson_disc">Wikipedia : SuperSampling#poisson_disc</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/29/using-compute-shader-in-unity/">Using Compute Shader In Unity</a>
          </h1>

          <p class="post-meta">Nov 29, 2017 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>Compute Shader</em> 는 <em>DirectX 11</em> 의 등장과 함께 본격적으로 쓰이기 시작했다. 지금은 <em>GPGPU</em> 의 본격적인 기능으로 CPU 에서 처리하기 힘든 계산량을 책임지는 중요한 기능으로 자리잡았다. 실시간으로 현실적인 그래픽을 구현하기 위해 요즘의 게임들은 <em>Compute Shader</em> 를 사용해서 여러 계산을 한다. 조금이라도 퍼포먼스가 필요하다면 당연히 쓰게되는 것이다.</p>

<p>사용하는 방법 자체는 간단하지만 <em>Compute Shader</em> 를 사용해 어떤 기능을 구현하는지가 중요하다. 간단하게 사용방법부터 알아보자. Unity 에서는 <em>Compute Shader</em> 를 위한 파일을 생성해야 한다.</p>

<p><img src="/images/create_computeshader.png" alt="create computeshader" class="center-image" /></p>

<p>프로젝트창에서 위 그림과 같이 생성해주면 된다. 그러면 아래와 같은 기본소스로 파일이 생성된다.</p>

<pre><code class="language-C">// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D&lt;float4&gt; Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!

	Result[id.xy] = float4(id.x &amp; id.y, (id.x &amp; 15)/15.0, (id.y &amp; 15)/15.0, 0.0);
}
</code></pre>

<p>위의 소스는 <em>HLSL</em> 로 코딩된 소스로 <em>DirectX 11</em> 을 기준으로 코딩되어 있다. <em>UnityCG</em> 파일안의 코드를 이용하면 <em>GLSL</em> 로 자동 컨버팅이 되기도 한다. 직접 <em>GLSL</em> 코드로 코딩하고 싶다면 <em>GLSLPROGRAM</em> 과 <em>ENDGLSL</em> 로 코드를 감싸주면 간단하게 해결된다.</p>

<p>내용은 간단하다. 각 텍셀별로 접근이 가능한 <em>Texture</em> 를 이용해서(<em>DirectX</em> 에서는 UAV 라고 칭한다.) <em>Texture</em> 에 값을 채운다. <em>HLSL</em> 의 자세한 문법과 사용방법은 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a> 들을 참고하길 바란다.</p>

<p>또한 쉐이더에서 뿐만아니라 <em>Unity</em> 스크립트상에서도 데이터들을 연결해주어야 한다. 사용하는 유형은 간단하다. <strong>UnityEngine.Texture</strong> 에서 파생된 텍스쳐들, <strong>UnityEngine.RenderTexture</strong>, <strong>UnityEngine.ComputeBuffer</strong> 정도면 모든 활용이 가능하다. <strong>UnityEngine.RenderTexture</strong> 에서는 <em>Cubemap</em> 도 지원하니 간단하게 쓸 수 있다. 해당 인스턴스를 넘겨주는 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;

shader.SetTexture("Result", rt);
</code></pre>

<p>코드에서의 변수명을 맞추어 넣어주거나 해쉬값을 미리 가져와 넣어주면 된다. 다른 유형의 데이터들도 이런 방법으로 넣을 수 있다. 데이터를 넣어주면 다음은 <em>Compute Shader</em> 를 실행하여 결과를 얻어야 한다. 간단하게 함수호출만 해주면 된다. 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;
int kernelIndex = shader.FindKernel("CSMain");

shader.Dispatch(kernelIndex, rt.width / 8, rt.height / 8, 1);
</code></pre>

<p>해당 <em>Compute Shader</em> 소스는 텍스쳐안에 값을 채우는 코드이기 때문에 위와같이 해주었다. <a href="https://docs.unity3d.com/ScriptReference/ComputeShader.Dispatch.html">Unity Reference : ComputeShader.Dispatch</a> 와 위의 <em>Compute Shader</em> 소스를 참고하면 알겠지만 최대 3차원의 방식으로 <em>Compute Shader</em> 의 그룹을 설정하여 계산이 가능하다.  <em>Compute Shader</em> 소스의 <em>[numthreads(8,8,1)]</em> 는 한 그룹의 <em>Thread</em> 갯수를 나타내고, <em>ComputeShader.Dispatch</em> 메소드는 몇개의 그룹을 실행시키는지 넘겨주는 메소드다. 아래 그림을 보면 조금더 쉽게 이해가 가능하다.</p>

<p><br />
<img src="https://msdn.microsoft.com/dynimg/IC520438.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN</a>
</center>
<p><br /></p>

<p><em>Compute Shader</em> 는 <em>DirectX 11</em> 이상, <em>Vulkan</em>,  <em>OpenGL 4.3</em> 이상, <em>OpenGL ES 3.0</em> 이상, <em>Metal</em> 에서 사용가능하다. 그 아래의 플랫폼은 지원하지 않는다. 또 유의해야 할점은 그래픽 드라이버별로 지원 기능이 조금씩 다를 수 있으니 기능을 유의하며 사용해야한다. <a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a> 에서 조금 참고할 수 있다.</p>

<p><a href="/2017/08/01/using-compute-buffer-in-unity/">Using Compute Buffer in Unity</a> 에서 관련된 내용을 언급했으니 같이 보면 좋을듯 하다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a></li>
  <li><a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/18/DrawInstanced-vs-Merged-Instancing/">Drawinstanced Vs Merged Instancing</a>
          </h1>

          <p class="post-meta">Nov 18, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a> 슬라이드에 따르면 <em>DrawInstanced</em> 함수를 사용하여 인스턴싱을 하는것보다 <em>vertexID</em> 를 사용하여 인스턴싱을 하는것이 빠르다고 한다. <em>vertexID</em> 를 쓰는 방법은 굉장히 단순하다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VSOutput VS(uint id : SV_VertexID)
{
    VSOutput output;

    /*
        ...
    */

    return output;
}
</code></pre></div></div>

<p><em>SV_VertexID</em> <em>Semantic</em> 을 사용하여 값을 접근하기만 하면 된다. <em>vertexID</em> 는 말그대로 버텍스별 인덱스를 뜻한다. <em>SRV</em> 나 <em>UAV</em> 와 함께 사용하여 <em>Instancing</em> 을 하면된다.</p>

<p><br />
<img src="/images/gdc2014_vertexshadertricks_23.png" alt="Merge Instancing Performance" /></p>
<center>출처 : <a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a>
</center>
<p><br /></p>

<p>그림을 보면 AMD GPU 에서 확실히 퍼포먼스 차이가 난것을 확인할 수 있다. <del>스피커가 AMD 소속이라는 게 포인트</del></p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-3/">Hbao Plus Analysis 3</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-2/">hbao plus analysis 2</a> 글에서 <em>Horizon based ambient occlusion</em> 와 <em>Cross Bilateral Filter</em> 대해서 알아보았다. 이번 글에서는 부록의 느낌으로 <em>HLSL</em> 코드를 읽으면서 생소했던 기타 기법들에 대해서 써볼 것이다.</p>

<p>첫번째로 <em>Full Screen Triangle</em> 이라는 기법이다. 알고마면 굉장히 단순한 개념으로, 화면을 모두 덮는 한개의 삼각형을 그려서 모든 픽셀에 쉐이더를 돌릴 수 있게 해주는 기법이다. 아래 슬라이드를 보면 쉽게 이해가 갈것이다.</p>

<p><br />
<img src="/images/vertex-shader-tricks-by-bill-bilodeau-amd-at-gdc14-14-638.jpg" alt="Full Screen Triangle" class="center-image" /></p>
<center>출처 : <a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a>
</center>
<p><br /></p>

<p>단순하지만 처음 봤을 때는 조금 신박하게 느껴질 수도 있다. 두번째로는 모든 계산에 최대한 <em>HLSL Intrisic</em> 을 사용한다. 특히 벡터와 벡터사이의 거리를 계산할때 <em>dot product</em> 를 써서 하는게 정말 많았다. 어셈블리 레벨에서 달라지는것 같긴하나 정확한 이유는 알지 못했다. 추측해보면 GPU 에서 해당 명령어가 있지 않을까.. 라고 생각한다.</p>

<p>세번째도 위의 것과 비슷하다. 대부분의 데이터에 <em>MAD</em> 방식을 사용해서 계산한다. 하지만 이는 거의 공식적으로 정해진게 있다. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471418.aspx">MSDN : mad  function</a> 레퍼런스에서도 나오듯이 어떤 GPU 에서는 위에서 추측한대로 하드웨어에서 지원하는 명령어라고 한다.</p>

<blockquote>
  <p>…
Shaders can then take advantage of potential performance improvements by using a native mad instruction (versus mul + add) on some hardware.
…</p>
</blockquote>

<p>또한 <em>HBAO+</em> 소스에서 찾은 주석에는 <em>GK104</em> 부터 특정 구간에서 10% 퍼포먼스 이득이 있다고 쓰여져 있다.</p>

<p>네번째는 나누기를 절대 쓰지 않는다. 나머지 연산(mod, A % B)는 간혹 쓰이지만 나누기는 절대로 쓰이지 않았었다. 혹시라도 필요하다면 전부 <em>Constant Buffer</em> 에 CPU 에서 역수를 취해서 넘겨주는 방식으로 되어 있었다. 이도 역시 하드웨어에서 동작하는 부분을 알고 짠듯하다.</p>

<p>다섯번째는 <em>HLSL</em> 코드를 <em>cpp</em> 소스에 <em>include</em> 하여 <em>Constant Buffer</em> 값을 갱신하는 코드였다. 여태까지 예전의 <em>DirectX</em> 소스만 보거나 <em>Unity</em> 에서만 작업을 해서 그런지 이런 기능은 굉장히 낯설었다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a></li>
  <li><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471418.aspx">MSDN : mad function</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-2/">Hbao Plus Analysis 2</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/bilateral-filter/">bilateral_filter</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-1/">hbao plus analysis 1</a> 글에서 <em>HBAO+</em> 에서 <em>Linearize Depth</em> 와 <em>Deinterleaved Texturing</em> 에 대해서 알아보았다. 이번 글에서는 <em>HBAO+</em> 의 핵심 알고리즘인 <em>Horizon Based Ambient Occlusion</em> 와 AO 블러에 사용되는 <em>Cross Bilateral Filter</em> 에 대해서 알아볼것이다.</p>

<h2>Horizon Based Ambient Occlusion</h2>

<p><em>Horizon Based Ambient Occlusion</em> 은 xy 평면과(horizon) Depth 값을 사용해서 <em>AO</em> 를 계산한다. 슬라이드에서 가져온 일부를 보자.</p>

<p><br />
<img src="/images/hbao_siggraph08_05.png" alt="Horizon Mapping" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Siggraph 2008 : Image-Space Horizon-Based Ambient Occlusion</a>
</center>
<p><br /></p>

<p>해당 슬라이드에서는 xy평면을 단순하게 1차원인 x축만으로 나타냈다. <em>HBAO</em> 는 그림에 나오는 <em>horizon angle</em> 을 사용하여 <em>AO</em> 값을 구한다. 자세한 방법은 아래 슬라이드를 보자.</p>

<p><br />
<img src="/images/hbao_siggraph08_12.png" alt="Horizon-Based AO" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Siggraph 2008 : Image-Space Horizon-Based Ambient Occlusion</a>
</center>
<p><br /></p>

<p>슬라이드에서는 표면의 접선을 나타내는 <em>Tangent</em> 벡터와 <em>Horizon</em> 벡터를 사용해서 <em>sin</em> 의 차이로 <em>AO</em> 를 계산한다고 설명되어 있다. <em>Horizon</em> 벡터는 <em>Depth</em> 와 화면의 좌표를 구해서 샘플링하는 위치값을 구하고 기준이 되는 위치값의 차이를 통해 구한다. <em>HBAO+</em> 코드에서는 입력을 받은 <em>Normal</em> 벡터와 <em>Horizon</em> 벡터에 <em>dot</em> 을 사용해 <em>cos</em> 값을 구하고 변환해준다. 이렇게 한번 <em>AO</em> 값을 구한다.</p>

<p>보다 정확한 <em>AO</em> 값을 구하기 위해서는 전방위로 탐색할 필요가 있다. 정해진 방향으로 샘플링을 해도 오차가 생길 수 있고 완전히 랜덤하게 방향을 정해도 부정확한 결과를 얻을 수 있다. 그래서 <em>HBAO</em> 는 랜덤하게 방향을 정하나 그 방향 벡터를 정해진 각도로 돌려주어 그나마 정확한 결과를 얻으려 한다. 슬라이드를 보고 넘어가자.</p>

<p><br />
<img src="/images/hbao_siggraph08_14.png" alt="Sampling the Depth Image" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Siggraph 2008 : Image-Space Horizon-Based Ambient Occlusion</a>
</center>
<p><br /></p>

<p>핵심적인 개념은 모두 설명했지만 만족할만한 결과를 얻기 위해 여러가지 보정 방법들이 필요하다. 그래서 <em>HBAO</em> 에서는 두가지 보정을 해주는 개념을 설명한다. <em>HBAO</em> 는 방향을 설정해주고 해당 방향으로 한번만 샘플링 하는게 아니라 여러번 샘플링 한다. 그러므로 거리에 따른 감쇠(attenuation)가 필요하다. 방법은 간단하다. <em>AO</em> 를 계산할때 구했던 <em>Horizon</em> 벡터의 크기에 따라서 <em>AO</em> 값을 줄여준다. 나머지 한가지는 <em>Horizon</em> 벡터와 <em>Tangent</em> 벡터를 이용해 구하는 실질적인 <em>AO</em> 값에 <em>Bias</em> 로 낮은 <em>AO</em> 값들을 무시하는 방법이다. <em>Bias</em> 가 없이 <em>AO</em> 를 생성하게 되면 노이즈가 생기기 때문이다. 또한 <em>Bias</em> 로 생긴 수학적 오차는 코드에서 따로 보정해주기 때문에 크게 문제는 없다.</p>

<h2>Cross Bilateral Filter</h2>

<p><em>SSAO</em> 의 결과에는 일반적으로 블러를 먹이게 된다. 대부분 근사에 기반한 계산이기 때문이다. <em>HBAO</em> 에서는 <em>Depth</em> 를 이용한 방법을 소개한다. 바로 <em>Cross Bilateral Filter</em> 다.</p>

<p><em>Cross Bilateral Filter</em> 은 <em>Gaussian Filter</em> 와 비슷한 필터로, <em>Gaussian Filter</em> 는 샘플링할 위치의 거리에 따라 점차 가중치가 줄어드는 필터라면, <em>Bilateral Filter</em> 는 위치에 따라 가중치가 줄어드는게 아닌 각 위치별로 가지고 있는 한개의 스칼라값에 차이에 따라서 가중치를 정하는 필터다. <em>Cross</em> 단어를 붙인 이유는 왼쪽과 오른쪽 방향의 필터와 위와 아래의 필터를 따로하기 때문에 <em>Cross</em> 라는 단어를 붙인 듯 하다. <em>HBAO+</em> 코드에서도 X 축과 Y 축을 기준으로 하는 블러 소스가 나누어져 있다. <em>HBAO</em> 에는 한개의 스칼라 값을 <em>Depth</em> 를 기준으로 계산한다. 그래서 크게 튀는 부분의 결과는 많이 반영하지 않아 전체적으로 뿌옇게 바뀐다.</p>

<p><br />
<img src="/images/hbao_siggraph08_28.png" alt="Sampling the Depth Image" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Siggraph 2008 : Image-Space Horizon-Based Ambient Occlusion</a>
</center>
<p><br /></p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVidia HBAO+</a></li>
  <li><a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Image-Space Horizon Based Ambient Occlusion</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Gaussian_filter">Wikipedia : Gaussian Filter</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Bilateral_filter">Wikipedia : Bilateral Filter</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-1/">Hbao Plus Analysis 1</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/linearize-depth/">linearize_depth</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/deintereaved-texturing/">deintereaved_texturing</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-0/">hbao plus analysis 0</a> 글에서 <em>HBAO+</em> 을 알기위한 기본적인 개념들에 대해서 살펴보았다. 이번 글에서는 <em>HBAO+</em> 의 구조와 <em>Linearize Depth</em> 와 <em>Deinterleaved Texturing</em> 에 대해서 알아보겠다.</p>

<h2><em>HBAO+</em> Pipeline</h2>

<p><br />
<img src="/images/hbao+_pipeline_with_input_normals.png" alt="hbao+ with input normal" class="center-image" /></p>
<center>출처 : <a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a>
</center>

<p><br />
<img src="/images/hbao+_pipeline_without_input_normals.png" alt="hbao+ without input normal" class="center-image" /></p>
<center>출처 : <a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a>
</center>
<p><br /></p>

<p>그림이 두개가 있다. 하나는 <em>GBuffer</em> 를 사용할 시 <em>World-Space Normal</em> 버퍼와 <em>Depth Buffer</em> 를 넘겨주어 계산하는 방식과 입력으로 <em>Depth Buffer</em> 만 넘겨서 <em>Normal</em> 데이터를 계산하는 두가지 방식에 대한 파이프라인이다. 두가지의 차이는 <em>Normal</em> 데이터에 대한 처리방식만 다르다. 나머지 계산은 다를게 없다.</p>

<h2>Linearize Depths</h2>

<p>코드를 보면 가장 처음에 시작하는 단계는 바로 <em>Linearize Depths</em> 다. 이는 꽤나 알려진 방법이다. 하지만 필자는 <em>HBAO+</em> 를 볼때 처음 봤기에 어느 정도의 설명을 해놓아야겠다. <em>Linearize Depths</em> 를 알기 위해선 입력된 정점의 위치를 <em>Clipping-Space</em> 로 변환하는 방법이 어떻게 이루어지는지 알고 있어야 한다.</p>

<p>일반적인 오브젝트를 렌더링 할때는 <em>Shader</em> 에 입력으로 들어오는 정점의 기준 공간은 <em>Model-Space</em>(또는 <em>Local-Space</em>) <em>Position</em> 이다. 그래서 <em>MVP</em> 변환을 통해 <em>Rasterizer</em> 가 처리할 수 있도록 <em>Clipping-Space</em> 로 <em>Rasterizer</em> 로 넘어가기 전에 변환해주어야 한다.(전체적인 내용은 <a href="https://docs.google.com/presentation/d/10VzsjfifKJlRTHDlBq7e8vNBTu4D5jOWUF87KYYGwlk/edit#slide=id.g25f88339be_0_0">Model, View, Projection 변환</a> 에서 확인할 수 있다.
) 그래서 <em>Pixel Shader</em> 로 넘어간 데이터들은 픽셀별로 들어가고, 픽셀별로 들어간 정점들의 위치는 <em>Clipping-Space</em> 로 되어있다. 여기까지 이해했으면 아래 그림을 보자.</p>

<p><br />
<img src="/images/Graphics3D_ClipVolume.png" alt="frustum vs Clipping" class="center-image" /></p>
<center>출처 : <a href="https://www.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html">3D Graphics with OpenGL Basic Theory</a>
</center>
<p><br /></p>

<p>위 그림은 <em>View frustum</em> 과 <em>Clipping Volume</em> 을 보여준다. <em>View frustum</em> 은 <em>Perspective</em> 방식으로 카메라가 실제로 보여주는 공간을 시각화 한것이고, <em>Clipping Volume</em> 은 <em>MVP</em> 변환에서 <em>Projection</em> 행렬을 사용할시 <em>View frustum</em> 에서 <em>Clipping Volume</em> 으로 변환되는 볼륨을 시각화 한것이다. <em>Projection</em> 변환은 아래와 같다.</p>

<p><br />
<img src="/images/projection_matrix.png" alt="perspective projection matrix" class="center-image" /></p>
<center>출처 : <a href="https://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer
">Stackoverflow : Getting the true z value from the depth buffer</a>
</center>
<p><br /></p>

<p><em>Perspective Projection</em> 은 <em>frustum</em> 기준 위치를 <em>Cube</em> 기준 위치로 바꾸는 연산이기 때문에 실제 좌표의 왜곡이 발생한다. 우리는 Z(Detph) 값이 어떤식으로 왜곡되는지 알아야 한다. 우선 <em>Clipping-Space</em> 로 변환할때, <em>Perspective</em> 형식의 <em>View frustum</em> 의 <em>zNear</em>, <em>zFar</em> 사이의 Z 값을 [0~1] 값으로 매핑한다. 그러면 <em>zNear</em>, <em>zFar</em> 값을에 따라서 실제 좌표가 바뀐다. 그리고 값 자체가 실제 Z 값과 선형적으로 매핑되지 않는다. 아래 그림을 보자.</p>

<p><br />
<img src="/images/nonlinearDepth.png" alt="non linear depth" class="center-image" /></p>
<center>출처 : <a href="https://computergraphics.stackexchange.com/questions/5116/how-am-i-able-to-perform-perspective-projection-without-a-near-plane">Computer Graphics StackExchange : How am I able to perform perspective projection without a near plane?</a>
</center>
<p><br /></p>

<p>그림이 조금 헷갈릴수도 있다. 세로축의 <em>d</em> 값은 <em>Projection</em> 을 한 Z, <em>Depth</em> 값이고 가로축은 <em>World-Space</em> 의 Z 값이다. 조금 헷갈릴수도 있는 부분은 세로축의 기준값이 윗부분이 0이고 아랫부분이 1이다. 이 부분은 신경써서 봐야한다. 이해했다면 변경된 <em>Depth</em> 값은 실제 Z 값과 선형적인 관계가 아니고, 실제 Z 값으로 복원하려면 여러 연산을 해야하기에 <em>HBAO+</em> 에서는 <em>Depth</em> 값들을 <em>Linearize</em> 하는 과정을 맨 처음에 넣은 것이다. 실제 Z 값으로 복원하는 이유는 간단하다. <em>Linear</em> 하지 않은 <em>Depth</em> 값을 연산시에 사용하면 보다 부정확한 결과가 나오기 때문이다. 특히 <em>SSAO</em> 연산을 할때는 <em>Depth</em> 값이 기본이 되기 때문에 해주어야 한다.</p>

<p>이 단계에서의 결론은 간단하다. <em>Clipping-Space</em> 의 <em>Depth</em> 값을 <em>View-Space</em> 의 Z 값으로 변환하는 단계다. 처리하는 코드는 다른 단계에 비해 짧다. 만약에 넘겨준 <em>Depth</em> 데이터들이 <em>View-Space</em> 인 경우에는 옵션을 통해 처리할 수 있다.</p>

<h2>Deintereaved Texturing</h2>

<p>위의 그림에는 <em>Generate HBAO+</em> 라고 단순히 뭉뚱그려서 표현했지만 그 안에는 단순한 <em>Horizon based ambient occlusion(HBAO)</em> 계산만 있지는 않다. <em>Deintereaved Texturing</em> 이라는 테크닉과 함께 <em>HBAO</em> 를 계산한다. <em>Computer Engineering</em> 분야의 지식을 응용한 이론으로 개인적으로 이 이론을 접했을 떄 꽤나 충격이였다. 자세한 설명은 <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a> 슬라이드의 몇장과 함께 보자.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_51.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_51" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p><em>Deintereaved Texturing</em> 의 방법은 간단하다. 텍스쳐를 여러장으로 나누어 샘플링을 한 후 각각의 나눠진 텍스쳐를 샘플링한 결과를 하나로 합친다. 슬라이드에는 <em>Post-Processing</em> 을 기준으로 설명이 되어있다. 이점은 생각하면서 보자.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_52.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_52" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>한 텍스쳐를 여러장으로 나누는건 <em>Multiple Render Target</em> 을 사용해서 나눈다. 슬라이드는 4개를 기준으로 설명했지만 <em>DirectX10</em> 부터는 최대 8개까지 지원하기 때문에 16개로 나누어 샘플링한다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_53.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_53" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>다음은 나누어진 각각의 텍스쳐를 샘플링하여 원하는 알고리즘으로 결과를 낸다. 조각난 텍스쳐 한개당 한번 <em>DrawCall</em> 을 걸어준다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_54.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_54" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p><em>Deintereave</em> 를 하기전까지는 넓은 범위의 텍스쳐를 샘플링하여 캐시 효율이 많이 떨어졌지만 텍스쳐를 나누어 각각 할때마다 처리를 하게되니 캐시 효율의 이득을 얻었다. 또한 각각의 <em>DrawCall</em> 마다 텍스쳐의 용량이 조금만 필요하게 되니 대역폭의 이득도 얻게 된다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_55.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_55" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>한번의 <em>DrawCall</em> 로 나누어진 결과들을 합친다. <em>Deintereaved Texturing</em> 은 여기서 끝이다. 실제로 <em>HBAO+</em> 는 16개의 텍스쳐로 나누어 샘플링한다. <em>Multiple Render Target</em> 이 8개까지 지원되어 16개로 <em>Deintereave</em> 하려면 2번 <em>DrawCall</em> 을 해야한다. 또한 샘플링은 16번 <em>DrawCall</em> 을 하여 계산한다. 그래서 한번 <em>Deintereaved Texturing</em> 을 사용하여 <em>Post-Processing</em> 처리하려면 약 20번의 <em>DrawCall</em> 을 계산해야 한다. 절대적으로 큰 숫자가 아니기 때문에 크게 신경쓸 필요는 없어보인다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_62.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_62" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>엄청난 성과를 거둔게 보인다. 캐시 히트 확률이 굉장히 올라갔고, 시간도 많이 절약했다. <em>HBAO+</em> 의 성능향상을 시켜준 것이 이 <em>Deinterleaved Texturing</em> 인듯하다.</p>

<h2>Reconstruction of Normal</h2>

<p><em>HBAO+</em> 는 기본적으로 <em>Depth</em> 와 <em>Normal</em> 을 통해서 계산한다. 그렇기 때문에 외부에서 <em>Normal</em> 데이터를 넣어주거나 직접 만들어야 한다. 보통 <em>Deffered Rendering</em> 을 차용하는 시스템들은 간단하게 <em>GBuffer</em> 의 <em>Normal</em> 데이터만 넣어주면 된다. <em>Normal</em> 데이터를 가져오는 코드가 있으니 조금만 수정하여 사용하면 된다.</p>

<p><em>Normal</em> 데이터가 없는 경우에는 라이브러리 내에 직접 계산한다. 계산하는 픽셀을 기준으로 상하,좌우별로 <em>Depth</em> 와 화면상의 좌표계를 이용하여 <em>View-Space</em> 의 위치를 구한다음 위치가 상하, 좌우별로 가까운 픽셀의 위치 오프셋을 사용해 외적하여 <em>Normal</em> 값을 구한다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVidia HBAO+</a></li>
  <li><a href="https://developer.nvidia.com/sites/default/files/akamai/gameworks/samples/DeinterleavedTexturing.pdf">NVidia : Deintereaved Texturing</a></li>
  <li><a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a></li>
  <li><a href="http://www.gdcvault.com/play/1017623/Advanced-Visual-Effects-with-DirectX">GDCVault : Particle Shadows &amp; Cache-Efficient Post-Processing Video</a></li>
</ul>

        </div>

        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/3/">&laquo; Older</a>
    

    
      <a class="next" href="/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2018 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
