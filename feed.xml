<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko">
  <generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator>
  
  
  <link href="https://hrmrzizon.github.io/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hrmrzizon.github.io/" rel="alternate" type="text/html" hreflang="ko" />
  <updated>2017-05-17T04:25:17+00:00</updated>
  <id>https://hrmrzizon.github.io//</id>

  
    <title type="html">Appocrypha</title>
  

  
    <subtitle>store limitless knowledges</subtitle>
  

  
    <author>
        <name>Su-Hyeok Kim</name>
      
      
    </author>
  

  
  
    <entry>
      
      <title type="html">Handling Uv And Material In Unity</title>
      
      <link href="https://hrmrzizon.github.io/2017/05/15/handling-uv-and-material-in-unity/" rel="alternate" type="text/html" title="Handling Uv And Material In Unity" />
      <published>2017-05-15T00:00:00+00:00</published>
      <updated>2017-05-15T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/05/15/handling-uv-and-material-in-unity</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/05/15/handling-uv-and-material-in-unity/">&lt;p&gt;&lt;a href=&quot;/2017/05/14/handling-vertices-and-indices-in-unity/&quot;&gt;Handling vertices and indices&lt;/a&gt; 글에서 Unity 에서 정점과 인덱스를 사용해 물체를 그리는 방벙에 대해서 알아보았다. 그런데 뭔가 설정해야 할것들이 빠진 것처럼 보인다. 실제로 그려지는 모습은 Unity 에서 아무것도 설정이 안되어 있을 때 나오는 분홍색으로 전부 칠해져 있다. 일반적으로 게임에서 나오는 3D 물체들은 전부 색이 칠해져 있거나 그림이 그려져 있다. 거기다가 빛을 받아서 반짝반짝이기도 할때도 있다. 이번 글에서는 3D 오브젝트에 색을 입히거나 그림을 입히는 방법에 대해서 알아보자.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;폴리곤은 하나의 면으로써 폴리곤 안의 색으로 무언가를 표현해야 한다. 우리가 앞에서 보던 예제처럼 계속 분홍색으로 내버려 둘순 없지 않은가? 색을 직접 입힐만한 수단이 필요한데 이를 위해서는 몇가지 데이터들이 필요하다.&lt;/p&gt;

&lt;p&gt;제일 먼저 필요한 것은 폴리곤에 색을 입힐 방법을 컴퓨터에게 알려 주어야 한다. 이 방법은 보통 어떤 형식의 코드로 나타내는데 이를 쉐이더(&lt;em&gt;Shader&lt;/em&gt;)라고 한다. Unity 는 매우 다양한 색을 입히는 방법 : 쉐이더를 지원한다. 물론 직접 쉐이더 코드를 만들 수도 있지만 전체적인 것들에 대한 이해가 있어야 쉽게 방법을 고안할 수 있으므로 나중에 직접 쉐이더 코드를 만들어 볼 것이다. 이 글에서는 Unity 에서 제공하는 쉐이더를 사용해 폴리곤에 색을 입힐 것이다.&lt;/p&gt;

&lt;p&gt;쉐이더는 다양한 방식으로 색을 입힐 수 있는데 일반적으로 쓰는 방법은 그림을 하나 가져다가 폴리곤에 그려주는 것이다. 이 그림은  텍스쳐라고 칭한다. 텍스쳐를 그릴 때는 항상 일정한 기준이 필요하다. 무턱대고 텍스쳐의 아무곳이나 그릴순 없지 않은가? 그래서 폴리곤의 정점과 상응되는 텍스쳐의 2차원 좌표가 필요하다. 이를 UV 좌표(Position) 이라고 한다. “U” 와 “V” 가 텍스쳐의 가로, 세로 위치를 나타내는 말이라 UV 좌표라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/texturemapping.png&quot; alt=&quot;Texture mapping&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 UV 좌표와 폴리곤을 구성하는 정점들이 나온 모습을 볼 수 있는데, 우리가 주목할것은 왼쪽 그림이다. 삼각형이 그려져 있는데 실제로 가지고 있는 데이터는 삼각형들의 각 꼭지점을 좌표로 가지고 있다. 그리고 각 UV 좌표들은 폴리곤을 구성하는 정점들과 매칭되어 오른쪽 아래의 결과가 그려진다.&lt;/p&gt;

&lt;p&gt;폴리곤에 색을 입히는 원리에 대하여 간단하게 알아보았다. 이제 Unity 에서 직접 색을 입히는 방법을 알아보자.&lt;/p&gt;

&lt;h2&gt;Mapping object in Unity&lt;/h2&gt;

&lt;p&gt;위에서 색을 입히기 위해서는 총 3가지가 필요하다고 말했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;쉐이더&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;UV 좌표&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;텍스쳐 및 기타 정보&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Unity 에서는 이 3가지를 취급하기 위해 두가지 분류를 만들어 놓았다. 하나는 전 게시글에서 본 &lt;strong&gt;Mesh&lt;/strong&gt; 클래스고 하나는 &lt;strong&gt;Material&lt;/strong&gt; 이라는 개념이다. &lt;strong&gt;Mesh&lt;/strong&gt; 클래스는 복수의 좌표 데이터를 저장하기 위한 목적으로 사용된다. 그래서 정점, 인덱스와 더불어 UV 좌표도 &lt;strong&gt;Mesh&lt;/strong&gt; 인스턴스 안에 넣는다.&lt;/p&gt;

&lt;p&gt;이제 &lt;strong&gt;Material&lt;/strong&gt; 하나만 남았다. 단어의 뜻은 “재료, 원료” 이런 뜻인데 색을 입히기 위한 재료라고 생각하면 편하다. 설정된 쉐이더와 쉐이더에서 필요한 여러 데이터들을 가지고 있는 Unity 의 애셋이다. 파일로도 존재할 수 있고, 런타임에서 생성해서 가지고 있을 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/mesh_and_materials.png&quot; alt=&quot;mesh and materials&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/hrmrzizon/3DBasicExample&quot;&gt;3DBasicExample&lt;/a&gt; 의 edu/mat 브랜치에 우리가 봐야할 소스들이 있다. 씬안에 MeshToolTest2 스크립트가 붙어있을 텐데 해당 스크립트안으로 들어가면 썰렁하게 한줄이 있을것이다.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ModifyMesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MeshTool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddPlane&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;우리가 볼것은 &lt;em&gt;MeshTool.AddPlane&lt;/em&gt; 에 있다. 함수의 정의로 들어가보자.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AddPlane&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddVertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIdxCnt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Convert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToInt32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetIndexCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddIndices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;prevIdxCnt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIdxCnt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIdxCnt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;prevIdxCnt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIdxCnt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIdxCnt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddUVs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 코드는 정점을 다루는 게시물에서 한번 본 예제다. 크게 달라진 내용은 없다. 면을 정의하기 위해 4개의 점을 만들고, 폴리곤을 만들기 위해 인덱스 배열을 만들어 정점의 인덱스를 넣어준다. 아래 UV 좌표를 넣는 부분이 우리가 알아야할 부분이다. 위에서도 계속 언급했지만 UV 좌표 하나는 정점 하나에 맞춰져야 한다. 즉 정점 한개당 UV 좌표 한개가 무조건 있어야 한다. 만약 같은 좌표에 다른 UV 좌표가 필요하면 같은 정점이 여러개가 필요할 것이다.&lt;/p&gt;

&lt;p&gt;이해하기 쉽게 주석으로 그림도 만들어 놓았다.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
      (0,1) (0,0,1) 2   3 (1,0,1) (1,1)
                    * - *
                    | / |
                    * - *
      (0,0) (0,0,0) 0   1 (1,0,0) (1,0)
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이렇게 UV 좌표를 설정해주면 &lt;strong&gt;Mesh&lt;/strong&gt; 를 건드리는 일은 끝났다. 이제 &lt;strong&gt;Material&lt;/strong&gt; 에셋을 만들거나 런타임에 직접 생성해주어 &lt;strong&gt;MeshRenderer&lt;/strong&gt; 컴포넌트에 넣어주면 된다. 우선 만들어진 &lt;strong&gt;Material&lt;/strong&gt; 에셋을 &lt;strong&gt;MeshRenderer&lt;/strong&gt; 컴포넌트에 넣어보자. 실행시에 &lt;strong&gt;MeshRenderer&lt;/strong&gt; 컴포넌트가 생성되는데 이 안에 &lt;em&gt;materials&lt;/em&gt; 라는 항목이 있다. 한개가 비어있는 배열이 나올텐데, 비어있는 곳에다가 넣어주면 정상적으로 출력이 될것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/empty_material.png&quot; alt=&quot;empty material&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정상적으로 출력이 되었으면 직접 &lt;strong&gt;Material&lt;/strong&gt; 을 만들어 넣어보자. Assset -&amp;gt; Create -&amp;gt; Material 메뉴를 사용하면 만들 수 있다. 또는 inspector 창에서 우클릭 후 Create -&amp;gt; Material 메뉴를 사용하라.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/create_material.png&quot; alt=&quot;Create material&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 만들면 새로운 &lt;strong&gt;Material&lt;/strong&gt; 이 우리를 기다린다. 위에서 했던 방법으로 직접 넣어보자. 같은 방식으로 넣어주면 똑같이 나올것이다. 이렇게 &lt;strong&gt;Material&lt;/strong&gt; 을 적용하는 방법에 대해 알아보았다. 이제 UV 좌표가 뜻하는 위치를 눈으로 확인 가능하다. UV 좌표를 조작하면서 어떤식으로 동작하는지 확인하는 것도 좋은 방법일 것이다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/UV_mapping&quot;&gt;Wikipedia : UV Mapping&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="rendering" />
      
        <category term="try" />
      

      

      
        <summary type="html">Handling vertices and indices 글에서 Unity 에서 정점과 인덱스를 사용해 물체를 그리는 방벙에 대해서 알아보았다. 그런데 뭔가 설정해야 할것들이 빠진 것처럼 보인다. 실제로 그려지는 모습은 Unity 에서 아무것도 설정이 안되어 있을 때 나오는 분홍색으로 전부 칠해져 있다. 일반적으로 게임에서 나오는 3D 물체들은 전부 색이 칠해져 있거나 그림이 그려져 있다. 거기다가 빛을 받아서 반짝반짝이기도 할때도 있다. 이번 글에서는 3D 오브젝트에 색을 입히거나 그림을 입히는 방법에 대해서 알아보자.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Mesh Components In Unity</title>
      
      <link href="https://hrmrzizon.github.io/2017/05/14/mesh-components-in-unity/" rel="alternate" type="text/html" title="Mesh Components In Unity" />
      <published>2017-05-14T00:00:00+00:00</published>
      <updated>2017-05-14T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/05/14/mesh-components-in-unity</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/05/14/mesh-components-in-unity/">&lt;p&gt;Unity 에서는 Mesh 를 활용하기 위해 몇가지의 컴포넌트를 지원한다. 간단하게 알아보자.&lt;/p&gt;

&lt;h3&gt;Mesh 를 가지고 있는 컴포넌트 : MeshFilter&lt;/h3&gt;

&lt;p&gt;이 컴포넌트는 Unity 컴퓨넌트가 아닌 &lt;strong&gt;Mesh&lt;/strong&gt; 클래스의 인스턴스를 가지고 있는 목적으로 만들어진 클래스다. &lt;strong&gt;Mesh&lt;/strong&gt; 의 인스턴스를 보관하고 외부에서 &lt;strong&gt;Mesh&lt;/strong&gt; 인스턴스에 접근할 수도 있다. 다만 조금 유의해야할 사항은 사용법이다. &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MeshFilter.html&quot;&gt;MeshFilter&lt;/a&gt; 문서를 보면 사용할 수 있는 프로퍼티가 두개가 있는데 하나는 &lt;em&gt;MeshFilter.sharedMesh&lt;/em&gt; 와 &lt;em&gt;MeshFilter.mesh&lt;/em&gt; 두개가 있다.  &lt;em&gt;MeshFilter.sharedMesh&lt;/em&gt; 는 실제 가지고 있는 &lt;strong&gt;Mesh&lt;/strong&gt; 인스턴스이고 &lt;em&gt;MeshFilter.mesh&lt;/em&gt; 는 원래의 인스턴스를 복사해 새로 생성한 것을 반환하기 때문에 주의해야 한다.&lt;/p&gt;

&lt;h3&gt;Mesh 를 통해 그리는 컴포넌트 : MeshRenderer&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;MeshRenderer&lt;/strong&gt; 컴포넌트는 &lt;strong&gt;Mesh&lt;/strong&gt; 인스턴스와 등록된 Material 들을 통해 화면상에서 실제로 보여주는 역할을 하는 컴포넌트다. 같은 GameObject 안에 있는 &lt;strong&gt;MeshFilter&lt;/strong&gt; 를 통해 &lt;strong&gt;Mesh&lt;/strong&gt; 인스턴스에 접근한다. 또한 여러 옵션들을 통해 렌더링을 제어할 수 있다. 중요한 기능은 그림자를 받는 기능과 그림자를 생기게 하는 기능이다. 그 외에도 Unity 에서 지원하는 여러 옵션을 설정할 수 있다. 그리고 여러개의 &lt;strong&gt;Material&lt;/strong&gt; 들을 가지고 있을 수 있는데 &lt;strong&gt;Mesh&lt;/strong&gt; 의 &lt;em&gt;submesh&lt;/em&gt; 별로 &lt;strong&gt;Material&lt;/strong&gt; 을 매칭해주어야 알맞게 그릴 수 있다. 기본값은 한개이므로 특별히 세팅을 안했다면 한개씩만 넣어주면 된다.&lt;/p&gt;

&lt;h3&gt;SkinnedMeshRenderer&lt;/h3&gt;

&lt;p&gt;위에서 설명한 &lt;strong&gt;MeshRenderer&lt;/strong&gt; 와 이름이 매우 비슷하다. 앞에 &lt;em&gt;Skinned&lt;/em&gt; 라는 키워드만 붙어있다. 이름은 비슷하지만 Unity 안에서 처리되는 것은 조금 다르다. &lt;strong&gt;MeshRenderer&lt;/strong&gt; 는 정점이 실시간으로 움직이지 않는 것들을 대상으로 그리는 컴포넌트다. 하지만 &lt;strong&gt;SkinnedMeshRenderer&lt;/strong&gt; 는 다르다. 이 컴포넌트도 &lt;strong&gt;Mesh&lt;/strong&gt; 를 그리기 위해 만들어진 컴포넌트지만 특정한 &lt;em&gt;Bone&lt;/em&gt; 을 기준으로 위치를 전부 계산하고 그려야 한다.&lt;/p&gt;

&lt;p&gt;특정한 &lt;em&gt;Bone&lt;/em&gt; 을(Unity 에서는 Bone 한개마다 GameObject 하나로 나타낸다.) 기준으로 정점들을 움직이게 하게 해주는 작업을 &lt;em&gt;Rigging&lt;/em&gt; 이라고 하는데 &lt;em&gt;Rigging&lt;/em&gt; 이 적용된 것을 그릴려면 &lt;strong&gt;SkinnedMeshRenderer&lt;/strong&gt; 컴포넌트를 붙여 주어야 한다. &lt;strong&gt;MeshRenderer&lt;/strong&gt; 를 사용하면 &lt;em&gt;Bone&lt;/em&gt; 을 움직여도 움직임이 적용이 안된채로 그려져서 말짱 꽝이 되버린다.&lt;/p&gt;

&lt;h3&gt;MeshCollider&lt;/h3&gt;

&lt;p&gt;충돌 감지를 &lt;strong&gt;Mesh&lt;/strong&gt; 를 활용해서 하는 컴포넌트로 일반적으로는 안쓴다. 폴리곤의 갯수가 많으면 많을수록 체크에 병목이 생기기 때문이다. 상황에 따라 폴리곤이 적은 경우에는 써도 무방하다. 이 컴포넌트는 생성될 때 &lt;strong&gt;MeshFilter&lt;/strong&gt; 컴포넌트가 존재하면 &lt;em&gt;sharedMesh&lt;/em&gt; 를 통해 &lt;strong&gt;Mesh&lt;/strong&gt; 인스턴스에 접근한다.&lt;/p&gt;

&lt;p&gt;이렇게 &lt;strong&gt;Mesh&lt;/strong&gt; 를 활용하는 여러가지 컴포넌트들에 대하여 알아보았다. 할말은 많지만 간단한 소개를 위해 쓰여졌기에 여기까지 하겠다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/class-MeshFilter.html&quot;&gt;Unity Manual - MeshFilter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/class-MeshRenderer.html&quot;&gt;Unity Manual - MeshRenderer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/class-SkinnedMeshRenderer.html&quot;&gt;Unity Manual - SkinnedMeshRenderer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MeshFilter.html&quot;&gt;Unity ref - MeshFilter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MeshRenderer.html&quot;&gt;Unity ref - MeshRenderer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/SkinnedMeshRenderer.html&quot;&gt;Unity ref - SkinnedMeshRenderer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="rendering" />
      
        <category term="try" />
      

      

      
        <summary type="html">Unity 에서는 Mesh 를 활용하기 위해 몇가지의 컴포넌트를 지원한다. 간단하게 알아보자. Mesh 를 가지고 있는 컴포넌트 : MeshFilter 이 컴포넌트는 Unity 컴퓨넌트가 아닌 Mesh 클래스의 인스턴스를 가지고 있는 목적으로 만들어진 클래스다. Mesh 의 인스턴스를 보관하고 외부에서 Mesh 인스턴스에 접근할 수도 있다. 다만 조금 유의해야할 사항은 사용법이다. MeshFilter 문서를 보면 사용할 수 있는 프로퍼티가 두개가 있는데 하나는 MeshFilter.sharedMesh 와 MeshFilter.mesh 두개가 있다. MeshFilter.sharedMesh 는 실제 가지고 있는 Mesh 인스턴스이고 MeshFilter.mesh 는 원래의 인스턴스를 복사해 새로 생성한 것을 반환하기 때문에 주의해야 한다. Mesh 를 통해 그리는 컴포넌트 : MeshRenderer MeshRenderer 컴포넌트는 Mesh 인스턴스와 등록된 Material 들을 통해 화면상에서 실제로 보여주는 역할을 하는 컴포넌트다. 같은 GameObject 안에 있는 MeshFilter 를 통해 Mesh 인스턴스에 접근한다. 또한 여러 옵션들을 통해 렌더링을 제어할 수 있다. 중요한 기능은 그림자를 받는 기능과 그림자를 생기게 하는 기능이다. 그 외에도 Unity 에서 지원하는 여러 옵션을 설정할 수 있다. 그리고 여러개의 Material 들을 가지고 있을 수 있는데 Mesh 의 submesh 별로 Material 을 매칭해주어야 알맞게 그릴 수 있다. 기본값은 한개이므로 특별히 세팅을 안했다면 한개씩만 넣어주면 된다. SkinnedMeshRenderer 위에서 설명한 MeshRenderer 와 이름이 매우 비슷하다. 앞에 Skinned 라는 키워드만 붙어있다. 이름은 비슷하지만 Unity 안에서 처리되는 것은 조금 다르다. MeshRenderer 는 정점이 실시간으로 움직이지 않는 것들을 대상으로 그리는 컴포넌트다. 하지만 SkinnedMeshRenderer 는 다르다. 이 컴포넌트도 Mesh 를 그리기 위해 만들어진 컴포넌트지만 특정한 Bone 을 기준으로 위치를 전부 계산하고 그려야 한다. 특정한 Bone 을(Unity 에서는 Bone 한개마다 GameObject 하나로 나타낸다.) 기준으로 정점들을 움직이게 하게 해주는 작업을 Rigging 이라고 하는데 Rigging 이 적용된 것을 그릴려면 SkinnedMeshRenderer 컴포넌트를 붙여 주어야 한다. MeshRenderer 를 사용하면 Bone 을 움직여도 움직임이 적용이 안된채로 그려져서 말짱 꽝이 되버린다. MeshCollider 충돌 감지를 Mesh 를 활용해서 하는 컴포넌트로 일반적으로는 안쓴다. 폴리곤의 갯수가 많으면 많을수록 체크에 병목이 생기기 때문이다. 상황에 따라 폴리곤이 적은 경우에는 써도 무방하다. 이 컴포넌트는 생성될 때 MeshFilter 컴포넌트가 존재하면 sharedMesh 를 통해 Mesh 인스턴스에 접근한다. 이렇게 Mesh 를 활용하는 여러가지 컴포넌트들에 대하여 알아보았다. 할말은 많지만 간단한 소개를 위해 쓰여졌기에 여기까지 하겠다. 참조 Unity Manual - MeshFilter Unity Manual - MeshRenderer Unity Manual - SkinnedMeshRenderer Unity ref - MeshFilter Unity ref - MeshRenderer Unity ref - SkinnedMeshRenderer</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Handling Vertices And Indices In Unity</title>
      
      <link href="https://hrmrzizon.github.io/2017/05/14/handling-vertices-and-indices-in-unity/" rel="alternate" type="text/html" title="Handling Vertices And Indices In Unity" />
      <published>2017-05-14T00:00:00+00:00</published>
      <updated>2017-05-14T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/05/14/handling-vertices-and-indices-in-unity</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/05/14/handling-vertices-and-indices-in-unity/">&lt;p&gt;여태까지 많은 게임들은 Graphics API 를 사용하여 만들어졌다. 1992년에 OpenGL 의 첫버젼이 릴리즈 되었고 이어서 1995년에 DirectX 가 Windows Game SDK 안에 포함되어 릴리즈 되었다. 그 이후로 수많은 게임들이 이 두가지의 Graphics API 를 사용하여 개발되었다. 다만 Graphics API 를 직접 사용하려면 꽤 많은 배경지식과(선형대수학, Graphics 이론 등) 해당 Graphics API 에 대한 경험이 많이 필요했다. 즉 일반적인 프로그래머들이 접근하기 조금 어려운 분야였다. 하지만 이를 꽤 뚫어본 많은 사람들이 게임을 만들기 위한 소프트웨어 이른바 게임 엔진이라는 소프트웨어를 개발하면서 널리 퍼지게 되었고  요즘에는 많은 지식 없이 게임을 만들 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;하지만 프로그래머로써 성장하려면 한계단씩 내려가 보면서 원리를 깨우쳐야 한다. 특히 게임 클라이언트 프로그래머는 결국 Graphics API 를 활용한 프로그램을 짜는 것이기 때문에 지식이 없으면 없을수록 난항을 겪기 마련이다. 수학적인 지식이 부족하면 직접 계산하는 코드를 짤수가 없고, Graphics API 의 구성을 모른다면 최적화를 할때 하나하나 삽질해가며 바꿔보아야 한다.&lt;/p&gt;

&lt;p&gt;이 게시물에서는 Graphics API 를 공부하면 처음 나오게는 지식들(정점, 폴리곤, UV)에 대해서 알아보고 Unity 에서 이 지식들을 시험해보겠다.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3&gt;공간을 구성하는 기본 단위 : 정점(vertex)&lt;/h3&gt;

&lt;p&gt;가장 먼저 알아야것은 정점이다. 영어로는 &lt;em&gt;vertex&lt;/em&gt; 인데 이 단어는 다양한 이론에서 상이하게 다뤄지므로 헷갈릴 수도 있다. 우선 그래픽스 분야에서의 정점은 3차원 공간에서 특정 위치를 나타내는 단어다. 수학에서 흔이 쓰이는 점의 정의와 비슷하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/position_p.png&quot; alt=&quot;Position P in math&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 정점은 위의 수학의 점 P 의 정의와 같은 말이다. 모든 3차원 상의 물체는 점으로 이루어져 있다. 하나하나의 점이 특정한 구성 방식으로 모여 선과 면을 정의한다. 정점은 모든 물체를 표현하기 위한 기본적인 단위다.&lt;/p&gt;

&lt;h3&gt;그려지는 면의 기본 단위 : 삼각형(polygon, triangle)&lt;/h3&gt;

&lt;p&gt;위에서 정점들은 물체를 표현하기 위한 기본적인 단위라고 설명했다. 그리고 물체를 표현하려면 표면(surface)를 표현할 수 있어야 한다. 정점을 가지고 표면을 정의할 수 있는 방법은 여러가지가 있지만 정점을 최소의 갯수만 가지고 표현하려면 삼각형으로 표현하는 것이 최적의 방법이다. 그리고 Graphics API 에서도 삼각형을 기본 단위로 물체를 그린다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/rabbit_polygons.jpg&quot; alt=&quot;Rabbit&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 모든 물체는 삼각형을 기본으로 만들어진다.&lt;/p&gt;

&lt;h3&gt;그려지는 정보의 집합체 : Mesh&lt;/h3&gt;

&lt;p&gt;이 개념은 위에서 언급한 개념들과는 조금 다르다. 점이나 삼각형은 위상 수학에서 나올법한 내용이지만 Mesh 에 대한 내용은 소프트웨어에서 나온 개념이다. Mesh 는 3D 오브젝트가 그려질 때 필요한 정보들을 담아놓고 있는 정보 덩어리라고 할 수 있다. 위에서 언급한 여러개의 정점들과 폴리곤에 대한 여러 정보들을 가지고 있다. 위의 토끼는 결국 여러 정점들과 여러 폴리곤 정보들로 그려진다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;여기까지 기본적으로 쓰이는 용어에 대한 간단한 설명들을 살펴보았다. 이제 Unity 에서 직접 이것들을 만져볼 차례다. 우선 &lt;a href=&quot;https://github.com/hrmrzizon/3DBasicExample&quot;&gt;3DBasicExample&lt;/a&gt; 을 받아서 &lt;em&gt;edu/plane&lt;/em&gt; 브랜치로 이동한다.&lt;/p&gt;

&lt;p&gt;Unity 에서 직접 정점과 폴리곤을 조작하는 방법에 대해서 알아보기 위해 Scripts 디렉토리에 MeshTest.cs 소스코드를 보자.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ModifyMesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;


    &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
                     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                             &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
                     &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위 코드는 정점과 폴리곤을 구성하는 정점의 인덱스를 직접 만들어 넣어주는 코드다. &lt;strong&gt;Mesh&lt;/strong&gt; 클래스는 위에서 설명한 정점과 폴리곤의 정보 등 렌더링에 필요한 정보를 가지고 있는 데이터 뭉치다. 여기에 정점과 폴리곤 정보를 넣는다. &lt;em&gt;ModifyMesh&lt;/em&gt; 함수에서는 &lt;strong&gt;Mesh&lt;/strong&gt; 의 프로퍼티에 두개의 배열을 새로 생성하여 넣어준다. &lt;em&gt;vertices&lt;/em&gt; 는 3차원 좌표계의 정점 정보 배열로써 가장 핵심적인 데이터다. 코드에서는 4개의 점을 넣어준다. X,Z축으로 정사각형을 구성하는 정점들을 가지고 있다. &lt;em&gt;triangles&lt;/em&gt; 는 폴리곤을 표현하기 위한 정수 배열인데 여기에는 &lt;em&gt;vertices&lt;/em&gt; 배열의 인덱스들이 들어가 있다. 당연히 3개의 인덱스가 하나의 폴리곤을 구성하며 위의 &lt;strong&gt;Mesh&lt;/strong&gt; 인스턴스는 두개의 폴리곤을 그리게 될것이다. 아래 소스에 주석으로 위의 정점과 인덱스들이 나타내는 것을 표현해 보았다.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
  (0,0,1) 2   3 (1,0,1)
          * - *
          | / |
          * - *
  (0,0,0) 0   1 (1,0,0)
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Y축에서 아래로 바라보는 뷰로 표현했다. 그리고 폴리곤을 구성하는 인덱스 배열에서 중요한게 하나있다. 바로 인덱스의 순서다. 이 코드에서 인덱스 배열이 각각 가르키는 정점의 순서를 보면 전부다 시계 방향(cw: clockwise)인 것을 알 수 있다. 만약 방향이 반시계 방향(ccw: countclockwise)으로 구성된다면 보이는 방향이 밑으로 바뀔 것이다. &lt;em&gt;mesh.triangles&lt;/em&gt; 에 들어가는 순서를 살짝 바꾸어 실행해보자.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
                 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                         &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
                         &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
                 &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;원래 보이던 방향에서 반대로 바뀐 것을 알 수 있다. 이건 꽤나 중요한 사항이다. 다른 어플리케이션에는 어떤 방향으로 설정하는지 모르겠지만 Unity 에서는 시계 방향을 기준으로 윗 방향을 보이는 기준으로 잡는다. 물론 직접 인덱스를 건드릴일은 거의 없다. 복잡한 모델들은 대부분 파일에서 불러와서 사용하기 때문이다. 하지만 모른다면 꽤나 난처해질 것이다.&lt;/p&gt;

&lt;p&gt;여기까지 직접 정점과 폴리곤을 구성하는 방법에 대해서 알아보았다. 다만 정리가 조금 안된사항들이 있다. Graphics API 에서는 정점의 배열들을 Vertex Buffer 라고 칭한다. 폴리곤을 구성하는 인덱스의 배열은 Index Buffer 라고 칭한다. 그리고 &lt;em&gt;vertices&lt;/em&gt; 는 vertex 의 복수형이다. 비슷한 표현으로는 &lt;em&gt;indcies&lt;/em&gt; 가 있다. 명칭들을 잘 알아두면 문서를 읽거나 소통할때 말하기 편하니 알아두길 바란다.&lt;/p&gt;

&lt;p&gt;자동으로 생성되는 Unity 컴포넌트가 궁금하다면 &lt;a href=&quot;/2017/05/14/mesh-components-in-unity/&quot;&gt;Mesh components in unity&lt;/a&gt;에서 확인하라.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="rendering" />
      
        <category term="try" />
      

      

      
        <summary type="html">여태까지 많은 게임들은 Graphics API 를 사용하여 만들어졌다. 1992년에 OpenGL 의 첫버젼이 릴리즈 되었고 이어서 1995년에 DirectX 가 Windows Game SDK 안에 포함되어 릴리즈 되었다. 그 이후로 수많은 게임들이 이 두가지의 Graphics API 를 사용하여 개발되었다. 다만 Graphics API 를 직접 사용하려면 꽤 많은 배경지식과(선형대수학, Graphics 이론 등) 해당 Graphics API 에 대한 경험이 많이 필요했다. 즉 일반적인 프로그래머들이 접근하기 조금 어려운 분야였다. 하지만 이를 꽤 뚫어본 많은 사람들이 게임을 만들기 위한 소프트웨어 이른바 게임 엔진이라는 소프트웨어를 개발하면서 널리 퍼지게 되었고 요즘에는 많은 지식 없이 게임을 만들 수 있게 되었다. 하지만 프로그래머로써 성장하려면 한계단씩 내려가 보면서 원리를 깨우쳐야 한다. 특히 게임 클라이언트 프로그래머는 결국 Graphics API 를 활용한 프로그램을 짜는 것이기 때문에 지식이 없으면 없을수록 난항을 겪기 마련이다. 수학적인 지식이 부족하면 직접 계산하는 코드를 짤수가 없고, Graphics API 의 구성을 모른다면 최적화를 할때 하나하나 삽질해가며 바꿔보아야 한다. 이 게시물에서는 Graphics API 를 공부하면 처음 나오게는 지식들(정점, 폴리곤, UV)에 대해서 알아보고 Unity 에서 이 지식들을 시험해보겠다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Project Setting For Git</title>
      
      <link href="https://hrmrzizon.github.io/2017/05/11/unity-project-setting-for-git/" rel="alternate" type="text/html" title="Unity Project Setting For Git" />
      <published>2017-05-11T00:00:00+00:00</published>
      <updated>2017-05-11T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/05/11/unity-project-setting-for-git</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/05/11/unity-project-setting-for-git/">&lt;p&gt;꽤 많은 사람들이 Git 을 사용한다. SVN 보다 더 널리 알려지고 유용하게 쓰이는 VCS 로써 굉장히 많이 쓰이는 시스템이다. Unity 를 사용할 때도 Git 을 이용해 버젼 관리를 할 수 있는데, 아무런 세팅없이 사용하기엔 조금 문제가 있다. 보통 대두되는 문제는 두가지다.&lt;/p&gt;

&lt;p&gt;첫번째는 Git 을 쓰다보면 느끼게 되는데, Git 자체는 텍스트로 구성된 데이터를 취급하려고 만들어졌기 때문에 바이너리 데이터에 대한 솔루션이 없었다. 만약 큰 바이너리 파일이 존재하면 커밋마다 계속 스냅샷을 갱신하기 때문에 커밋에 쓰이는 데이터는 기하급수적으로 늘어나게 된다. 보통 텍스쳐나 영상을 가지고 있게 되면 위의 상황에 부딫친다. 두번째는 조금 귀찮은 경우다. Unity 는 자체적으로 여러 데이터들의 확장자를 지정하여 파일을 사용하는데 커밋을 병합(merge) 할 때 Unity 에서 지원하는 파일에 충돌이 생겨 직접 손봐주어야 할 때, 일정 형식에 맞추지 않으면 끔찍한 사태가 일어나게 된다. 문제가 대표적으로 생기는 파일은 씬(.scene) 파일이다.&lt;/p&gt;

&lt;p&gt;여러가지 세팅을 해주어야 하니 차근차근 살펴보자.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1&gt;Unity 프로젝트 설정하기&lt;/h1&gt;

&lt;p&gt;우선 외부 파일을 세팅하기전에 Unity 프로젝트에서 간단한 세팅을 해주어야 한다. 우선 상위 메뉴의 Edit -&amp;gt; ProjectSettings -&amp;gt; Editor 를 선택해 Inspector 창을 보자. 아래 방법을 따라하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity-edit-ps-editor.png&quot; alt=&quot;Unity Go to editor&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 여러 설정이 뜨는데 여기서 두가지면 살펴보면 된다. 첫번째는 Version control 이라는 항목이다. 이 항목은 VCS 을 설정하거나 Unity 에서 .meta 파일을 사용해 데이터를 저장하는 두가지의 큰 방식으로 나뉘는데 Unity Personal 에서는 VCS 를 설정하는 것은 사용할 수 없다. 그러므로 Personal 라이센스 사용자는 결국 두가지 방식 중 하나만 고르면 된다. .meta 파일을 숨김파일로 지정하느냐 일반 파일로 지정하느냐의 차이인데 Git 에서는 숨김 파일은 취급하지 않기 때문에 Visible Meta Files 옵션을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_editor_version_control.png&quot; alt=&quot;Unity VCS Setting&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두번째는 Asset Serialization 이라는 항목이다. 이 옵션은 Unity 프로젝트에서 Unity 에서 직접 지정하는 확장자가 붙은 파일들을 어떻게 취급하냐를 설정하는 옵션이다. Unity 프로젝트에서는 두가지 방식으로 파일을 취급할 수 있는데 하나는 텍스트 형식으로 취급하는 것과 하나는 바이너리 형식으로 취급하는 것이다. 옵션의 선택지를 보면 총 3가지 인데 맨처음 Mixed 는 Unity 에서 파일마다 지정한 방식대로 텍스트냐 바이너리냐를 따라가는 것이고 나머지 두개(Force Text, Force Binary)는 무조건 한가지 방식으로 모든 파일들을 통일하는 것이다. 여러 용도로 텍스트를 사용하므로 Force Text 옵션을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_editor_asset_serialization.png&quot; alt=&quot;Unity Asset Serialization&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기까지 Unity 프로젝트에서 설정해주어야 하는 것들은 끝이다. 다음은 외부에서 설정해주어야 하는 것들을 살펴보자.&lt;/p&gt;

&lt;h1&gt;Git 설정 파일 추가하기&lt;/h1&gt;

&lt;p&gt;Git 에서는 여러 방식의 설정을 지원한다. 그 중에서도 우리는 많이 쓰이는 두가지 방식의 설정에 대해서 알아볼 것이다. 두가지 방식 모두 파일에 설정 정보를 저장한 후 해당 파일이 스테이징 공간에 들어가게 되면 로컬 레포지토리에 바로 적용된다. 보통은 맨 처음 커밋에 넣어주어 앞으로의 커밋들에 대비한다.&lt;/p&gt;

&lt;h2&gt;스테이징 공간의 이름 필터 : .gitignore&lt;/h2&gt;

&lt;p&gt;Git 에서 새로운 커밋을 만들 때, 파일들을 임시로 담아놓는 공간이 있다. 이 공간을 스테이징 영역이라 하는데 Git 로컬 레포지토리에 등록되어 있고 내용이 변경된 파일이나, 아예 등록되지 않은 파일을 넣어서 커밋으로 만드는 임시 공간이다. 비유를 하자면 장바구니(stage area)에 미리 커밋할 것을 넣어놓고 사는(commit) 행위로 비유할 수 있겠다. 하여튼 스테이징 영역에서 무언가 필터 역할을 하는 특수 옵션 파일이 .gitignore 인데 무언가 무시한다는 것만 알 수 있다.&lt;/p&gt;

&lt;p&gt;위 문단에서도 말했지만 스테이징 영역에 들어갈 수 있는 것들은 파일이 등록되어 변경된 파일이나, 아예 등록되지 않은 파일인데 .gitignore 안에 패턴에 해당되고, 로컬 레포지토리 안에 등록되지 않은 파일은 스테이징 영역의 후보에서도 아예 사라진다. 즉 패턴을 .gitignore 파일안에 등록하면 앞으로 등록되지 않은 파일 중에 패턴에 맞는 파일들은 스테이징 영역에도 저장할 수 없다. 더 쉽게 말하자면 어떤 특정한 이름을 가지면 아예 커밋을 못하게 할 수 있다는 것이다.&lt;/p&gt;

&lt;p&gt;Unity 프로젝트에서 아주 중요한 패턴이 몇개 있다. 이를 예로 보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Library/*
*/Library/*
Temp/*
*/Temp/*&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 예시들은 Unity 프로젝트에서 Git 리모트 레포지토리에 보내면 안되는 부모 디렉토리 이름들이다. Library 디렉토리는 프로젝트의 캐시 데이터로써 프로젝트를 실행하려면 Unity 에서 계산을 해서 만드는 파일이지만 굳이 없어도 알아서 만들어지기에 꼭 필요는 없는 파일이다. 자세한 사항은 &lt;a href=&quot;/2017/04/02/unity-project-directory-structue/&quot;&gt;링크&lt;/a&gt;에서 확인하라. * 의 뜻은 앞에 적어도 한개 이상의 아무 글자가 있어야 한다는 뜻이다. 즉 Library 디렉토리의 하위의 파일들을 포함한다는 뜻이고, .gitignore 파일안에 있으니 하위의 파일들을 전부 제외한다는 뜻이다.&lt;/p&gt;

&lt;p&gt;이런 여러 패턴들을 저장해 쓸데없는 파일들을 스테이징 영역에 들어갈 후보에서 제외해 편하게 스테이징 작업을 할 수 있게 해준다. 거의 모든 프로젝트에서 메타파일들을 제외하기 위해 쓴다. 그만큼 굉장히 유용한 옵션이다. 그리고 굳이 하나하나 패턴을 추가해줄 필요 없이 자동으로 패턴을 가져올 수 있는 사이트가 있다. 바로 &lt;a href=&quot;https://www.gitignore.io/&quot;&gt;https://www.gitignore.io/&lt;/a&gt; 다. 여러 플랫폼을 설정해줄 수 있으니 사용하는 것에 따라 다르게 설정해주면 된다.&lt;/p&gt;

&lt;h2&gt;디렉토리별 속성 지정 : .gitattributes&lt;/h2&gt;

&lt;p&gt;Git 시스템은 텍스트 파일을 기준으로 만들어져 있다고 위에서 설명했었다. 그래서 파일을 병합(merge)를 할때나 비교(diff) 할 때 바이너리 파일이면 문제가 있다고도 말했다. .gitattributes 는 디렉토리나 파일 단위로 Git 에서 설정한 것과 다른 설정을 할수도 있다. 파일이 위치하는 디렉토리부터 병합 도구(mergetool)과 비교 도구(difftool) 을 확장자별로 설정할 수도 있고, 파일의 유형을 설정해서 Git 시스템이 다르게 동작하게도 할 수 있다. 즉 디렉토리별로 설정을 하는 방법이라 보면 될듯하다.&lt;/p&gt;

&lt;p&gt;갑자기 .gitattributes 에 대해 설명을 하는 이유는 .gitattributes 에 Unity 에서 사용하는 전용 파일이나 용량이 큰 텍스쳐, 사운드, 영상 파일을 따로 효율적으로 관리할 수 있기 때문이다. &lt;a href=&quot;https://gist.github.com/nemotoo/b8a1c3a0f1225bb9231979f389fd4f3f&quot;&gt;링크&lt;/a&gt; 에 쓰여있는 내용을 조금 잘라서 확인해보자. 실제 파일로도 직접 사용하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;…&lt;/p&gt;

  &lt;p&gt;*.unity merge=unityyamlmerge eol=lf&lt;/p&gt;

  &lt;p&gt;*.prefab merge=unityyamlmerge eol=lf&lt;/p&gt;

  &lt;p&gt;…&lt;/p&gt;

  &lt;p&gt;*.jpg filter=lfs diff=lfs merge=lfs -text&lt;/p&gt;

  &lt;p&gt;*.jpeg filter=lfs diff=lfs merge=lfs -text&lt;/p&gt;

  &lt;p&gt;…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 텍스트는 Unity 프로젝트에서 사용하는 .gitattributes 파일 내용의 일부분이다. 다만 다른 내용은 없고 전부 중복되는 내용이기에 일부분만 가져왔다. 여기서도 * 을 사용해 파일의 패턴을 표현했다. .gitattributes 에서는 전부 확장자만 체크를 해서 파일의 타입을 지정했다. 여기서 지정한 파일의 타입은 두가지로 나뉘는데 Unity 에서 사용하는 파일의 확장자와 큰 크기의 파일 확장자를 지정해 주었다. Unity 에서 지정한 파일 확장자는 병합(merge)시에 사용하는 툴을 git 기본 mergetool 이 아닌 Unity 에서 기본으로 지원해주는 UnityYAMLMerge 라는 커맨드라인 툴을 사용하도록 지정하고 추가로 줄끝을 어떻게 구분하는지 옵션값을 넣어준다. 큰 크기의 파일 확장자는 기본 병합 도구와(mergetool) 비교 도구(difftool) 그리고 필터라는 것을 lfs 라는것으로 전부 설정해 주었다. lfs 라는 것은 큰 크기의 파일을 취급하는 것이다. 정확히는 매 커밋마다 큰 파일을 가지고 있는 것이 아니라 큰 파일의 포인터를 저장해서 변경시에만 새로운 파일을 저장한다.&lt;/p&gt;

&lt;p&gt;이렇게 파일을 설정하면 끝이라고 생각하겠지만 아직은 아니다. 위에서 설정한 UnityYAMLMerge 와 LFS 정보를 설정시켜주어야 한다. &lt;a href=&quot;https://docs.unity3d.com/Manual/SmartMerge.html&quot;&gt;링크&lt;/a&gt; 에서 UnityYAMLMerge 의 정보를 설정시켜주는 방법이 나온다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[mergetool “unityyamlmerge”]&lt;/p&gt;

  &lt;p&gt;trustExitCode = false&lt;/p&gt;

  &lt;p&gt;cmd = “path to UnityYAMLMerge” merge -p “$BASE” “$REMOTE” “$LOCAL” “$MERGED”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 텍스트를 사용자 홈 디렉토리에 존재하는 .gitconfig(–global) 에 직접 위와같이 써넣거나 bash 에서 직접 설정해주면 된다. 중간에 &lt;em&gt;“path to UnityYAMLMerge”&lt;/em&gt; 는 설치된 Unity 디렉토리 안에 “/Editor/Data/Tools/UnityYAMLMerge.exe” 위치에 있다. 그리고 기본으로 쓰는 merge.tool 정보는 바꾸지 않는다. .gitattributes 에서 확장자별로 바꿔주기 때문에 굳이 쓰지 않는다.&lt;/p&gt;

&lt;p&gt;LFS 의 설정방법은 매우 단순하다. &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;링크&lt;/a&gt;에서 설치파일을 받아서 설치를 완료하면 알아서 설정을 해준다. 굉장히 편하다. ‘git config –system –list’ 명령어로 lfs 가 설정된 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gitconfigsystem.png&quot; alt=&quot;Git config for lfs&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기까지 두가지 옵션을 설정하는 방법에 대해서 알아보았다. UnityYAMLMerge 와 LFS 설정이 되어 있으면 &lt;a href=&quot;https://gist.github.com/nemotoo/b8a1c3a0f1225bb9231979f389fd4f3f&quot;&gt;.gitattributes&lt;/a&gt; 와 &lt;a href=&quot;https://www.gitignore.io&quot;&gt;.gitignore&lt;/a&gt; 파일만 Git 시스템에 넣어주면 앞으로 편하게 설정이 가능하다. 파일을 구할 수 있는 링크를 이름에 넣어놓았으니 직접 받아서 가져가면 된다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gitignore.io&quot;&gt;www.gitignore.io&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/nemotoo/b8a1c3a0f1225bb9231979f389fd4f3f&quot;&gt;Gist : Unity .gitattributes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;Git-lfs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/SmartMerge.html&quot;&gt;Unity ref : SmartMerge&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/ko/v2/Git%EB%A7%9E%EC%B6%A4-Git-Attributes&quot;&gt;git-scm : .gitattributes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="git" />
      
        <category term="merge" />
      
        <category term="unity" />
      

      

      
        <summary type="html">꽤 많은 사람들이 Git 을 사용한다. SVN 보다 더 널리 알려지고 유용하게 쓰이는 VCS 로써 굉장히 많이 쓰이는 시스템이다. Unity 를 사용할 때도 Git 을 이용해 버젼 관리를 할 수 있는데, 아무런 세팅없이 사용하기엔 조금 문제가 있다. 보통 대두되는 문제는 두가지다. 첫번째는 Git 을 쓰다보면 느끼게 되는데, Git 자체는 텍스트로 구성된 데이터를 취급하려고 만들어졌기 때문에 바이너리 데이터에 대한 솔루션이 없었다. 만약 큰 바이너리 파일이 존재하면 커밋마다 계속 스냅샷을 갱신하기 때문에 커밋에 쓰이는 데이터는 기하급수적으로 늘어나게 된다. 보통 텍스쳐나 영상을 가지고 있게 되면 위의 상황에 부딫친다. 두번째는 조금 귀찮은 경우다. Unity 는 자체적으로 여러 데이터들의 확장자를 지정하여 파일을 사용하는데 커밋을 병합(merge) 할 때 Unity 에서 지원하는 파일에 충돌이 생겨 직접 손봐주어야 할 때, 일정 형식에 맞추지 않으면 끔찍한 사태가 일어나게 된다. 문제가 대표적으로 생기는 파일은 씬(.scene) 파일이다. 여러가지 세팅을 해주어야 하니 차근차근 살펴보자.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Recommand About Gpu</title>
      
      <link href="https://hrmrzizon.github.io/2017/05/06/recommand-about-gpu/" rel="alternate" type="text/html" title="Recommand About Gpu" />
      <published>2017-05-06T00:00:00+00:00</published>
      <updated>2017-05-06T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/05/06/recommand-about-gpu</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/05/06/recommand-about-gpu/">&lt;h2&gt;Graphics?&lt;/h2&gt;

&lt;p&gt;예전부터 꽤 많은 게임들이 GPU 를 활용하는 Graphics API 를 사용하여 만들어졌다. 그래서 예전에는 직접 게임을 만드려면 Graphics API 를 사용하여 기본적인 렌더링 기능을 구현한 후에 만들어야 했었다. 단순한 2D 게임조차 말이다. 하지만 요즘은 Unity 와 Unreal Engine 4 가 게임 엔진의 쌍두마차를 이루며 게임 엔진의 기능들을 한껏 활용해 비교적 간단하고 빠르게 게임을 만든다. 그렇기에 요즘 꽤 많은 게임 프로그래머들이 Graphics API 를 직접 마주할일은 적어지고 아랫단에서 이루어지는 여러 현상들에 대해 무지해질 가능성이 매우 높아졌다. 또한 기성세대의 게임 프로그래머들은 이 현상에 대해 부정적인 의견들을 분출하고 있다.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;필자 또한 현세대의 주니어 게임 프로그래머로써 Graphics API 를 직접 마주할일은 없다. 거의 모든 부분의 처리를 엔진에서 해주기 때문이다. 하지만 한계가 올때도 있다. 렌더링 성능으로 문제가 생겼을 때 이를 고칠 수 있는 사람은 당연히 기본적인 지식이 있고 이에 대해 많은 경험이 있는 사람이 고칠 수 있다. 아주 간단한 문제라도 지식이 없는 사람과 있는 사람의 차이는 질적으로나 시간적으로나 꽤 많은 차이가 난다.&lt;/p&gt;

&lt;p&gt;간단한 예시를 들자면 일반적인 forward rendering 구조에서는 광원(lighting)이 많아질 수록 병목이 심해진다. 그래서 대부분 라이트맵, 노말맵을 활용하고 광원은 최소의 갯수로 유지하려고 한다. 하지만 이런 지식이 없는 채로 Unity 에서 간단히 light 컴포넌트를 여러개 놓고 한참 개발하다가 나중에 성능이 안나오는걸 확인 했을 때 엄청난 시간적 손실을 보게 될것이다.&lt;/p&gt;

&lt;p&gt;한가지 예시를 더 들어보자면, GPU 는 빠른 렌더링을 위해 GPU 전용 RAM 에 정점, 텍스쳐 정보들을 저장한다. 즉 컴퓨터의 RAM 과 다른 물리적 임시 공간이 있다는 소리다. 그래서 Graphics API 를 사용해보면 여러 정보들(정점, 인덱스, uv 등)을 정보들을 참조할 때 따로 API 를 사용해 저장한다. 그런데 게임 엔진의 사용자가 변환을 통한 이동이 아닌 정점을 직접 이동시키고 싶다는 생각을 했을 때 이런 내부적인 상황을 고려하지 못한다면 잘 동작할 수도 있지만 성능이 좋지 않게 나올 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/app_layer_by_programmers_view.jpg&quot; alt=&quot;app layer&quot; class=&quot;center-image&quot; /&gt;
출처 : &lt;a href=&quot;http://slideplayer.com/slide/8511485/&quot; class=&quot;center&quot;&gt;Introduction to OpenGL in SlidePlayer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;결국 게임을 만들다보면 이런 것들에 부딫힐 수 밖에 없기 때문에 게임 프로그래머를 그만두지 않는한 결국 직면 해야한다. Graphics API 에 대한 자료들은 상당히 많기에 관련된 자료들은 배제하고 더 아래에 있는 GPU 에서 이루어지는 현상에 대해 다루는 자료를 소개해보려 한다. 위 그림의 hardware and software 단계의 “hardware” 부분의 설명들이라 보면 된다.&lt;/p&gt;

&lt;h2&gt;1. &lt;a href=&quot;https://simonschreibt.de/gat/renderhell/&quot;&gt;Render Hell&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;이 페이지는 프로그래머 입장에서 알아야할 GPU 의 동작 정보를 정리해놓은 영문 웹 페이지다. 꽤나 깔끔하고 이해를 위한 영상도 많다. 영어를 못한다면 구글 번역기와 함께 동영상을 보면서 이해하면 충분히 내용을 숙지할 수 있다. 저자는 Game Artist 로써 본인도 정리되어 있는 자료가 없기에 만들었다고 서론이 쓰여있다. 또한 이 블로그를 조금 더 살펴보면 재미있는 자료들이 꽤 있으니 잘 활용하길 바란다.&lt;/p&gt;

&lt;h2&gt;2. &lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;amp;ejkGb=KOR&amp;amp;barcode=9788994774008&quot;&gt;대규모 병렬 프로세서 프로그래밍&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;2011년에 초판이 인쇄된 몇년이 지난 책이다. 하지만 이 책안의 내용은 NVidea 기준의 GPU 의 동작원리를 설명하고 CUDA 를 이해하게 해준다. 또한 한글로 번역된 책은 거의 없고, 이렇게 자세하게 내용이 적힌 책은 몇권 되지도 않는다. 게임 프로그래머로써 GPU 의 동작을 이해한다는 이 글의 범주는 약간 벗어났으나 내용을 포함하고 있기에 추천한다.&lt;/p&gt;

&lt;p&gt;GPU 의 동작이 적혀진 자료는 많지 않다. 수요가 많은 자료도 아닐 뿐더러 지식들의 가치도 높기 때문이다. 그래서 이 글을 지속적으로 업데이트를 할 예정이다. 자료를 모으는 용도도 있지만 제일 중요한건 필자도 지식이 별로 없는 편이라 공부 용도로 쓸려고 한다.&lt;/p&gt;

&lt;h2&gt;3. &lt;a href=&quot;https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline&quot;&gt;Life of triangle&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;NVidea 공식 블로그 홈페이지에 올라온 글이다. NVidea GPU Architecture 들과 함께 폴리곤 하나가 어떻게 그려지는지에 대해 쓰여져 있는 간단한 글타래다. 이 사이트 역시 꽤 많은 글들이 올라와 있으니 궁금할때 보면 좋을 듯 하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://pixeljetstream.blogspot.kr/2015/02/life-of-triangle-nvidias-logical.html&quot;&gt;개인 블로그 링크&lt;/a&gt; : 같은 글이 있다. 검은색 배경/흰 글씨를 선호하면 여기서 보면된다.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      
        <category term="common" />
      
        <category term="game" />
      
        <category term="try" />
      

      

      
        <summary type="html">Graphics? 예전부터 꽤 많은 게임들이 GPU 를 활용하는 Graphics API 를 사용하여 만들어졌다. 그래서 예전에는 직접 게임을 만드려면 Graphics API 를 사용하여 기본적인 렌더링 기능을 구현한 후에 만들어야 했었다. 단순한 2D 게임조차 말이다. 하지만 요즘은 Unity 와 Unreal Engine 4 가 게임 엔진의 쌍두마차를 이루며 게임 엔진의 기능들을 한껏 활용해 비교적 간단하고 빠르게 게임을 만든다. 그렇기에 요즘 꽤 많은 게임 프로그래머들이 Graphics API 를 직접 마주할일은 적어지고 아랫단에서 이루어지는 여러 현상들에 대해 무지해질 가능성이 매우 높아졌다. 또한 기성세대의 게임 프로그래머들은 이 현상에 대해 부정적인 의견들을 분출하고 있다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Using Travis Ci</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/28/using-travis-ci/" rel="alternate" type="text/html" title="Using Travis Ci" />
      <published>2017-04-28T00:00:00+00:00</published>
      <updated>2017-04-28T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/28/using-travis-ci</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/28/using-travis-ci/">&lt;h2&gt;Travis-CI : Continuous Intergration&lt;/h2&gt;

&lt;p&gt;다른 Github Repository 를 살펴보면서 많은 곳에서 Travis-CI 를 사용하고 있어 한번 시도해 보았다. 블로그를 만들기 이전부터 CI 에 대한 소식은 많이 들었지만 직접 사용해보는 것은 처음이였다. 약간 삽질을 했지만 영어만 읽을 줄 안다면 필요 없는 삽질이였다. 삽질할 때는 몰랐지만 Travis-CI 에서 제공하는 웹 문서들이 꽤 친절하게 되어있어 잘 읽고 따라하면 문제없이 세팅을 할 수 있을것이다. 물론 영어다.(&lt;a href=&quot;https://docs.travis-ci.com/&quot;&gt;Documentation&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Travis-ci 는 Github 과 연동하여 사용할 수 있는 CI 서비스다. Jenkins씨 처럼 직접 사용환경을 만드는게 아니기 때문에 상당히 편하다. 또한 Travis-ci 는 빌드스크립트를 사용해서 빌드를 해주기 때문에 처음 사용하기엔 약간 불편하지만 “스크립트” 이기 때문에 강력한 범용성을 가진다.&lt;/p&gt;

&lt;p&gt;현재 이 블로그에서는 Travis-ci 를 통해 유효성을 검증한 후에 실제 서비스하는 브랜치로 방법이 Travis-ci 빌드스크립트에 적용되어 있다. &lt;a href=&quot;https://github.com/yous/whiteglass&quot;&gt;whiteglass&lt;/a&gt; 에 기본적으로 되어 있어 처음에는 의아했는데 꽤 괜찮은 아디이어여서 현재도 쓰고 있는 방법이다.&lt;/p&gt;

&lt;p&gt;Travis-ci 를 연동하고 활용하는 방법에 대해서 알아보자.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2&gt;Github Repository -&amp;gt; Travis-CI 연동하기&lt;/h2&gt;

&lt;p&gt;세가지 세팅이 필요하다. 저장소의 루트 디렉토리에 .travis.yml 의 이름을 가진 빌드스크립트를 넣어주어야 하고, &lt;a href=&quot;https://www.travis-ci.org/&quot;&gt;https://www.travis-ci.org/&lt;/a&gt; 에 들어가 Github 계정으로 로그인 후 Travis-ci 사용 설정을 해주고, Travis-ci 홈페이지에 가서 사용 설정을 해주면 된다. &lt;a href=&quot;https://www.travis-ci.com/&quot;&gt;https://www.travis-ci.com/&lt;/a&gt; 은 결제가 필요한 Pro 기능이니 결제할게 아니면 &lt;a href=&quot;https://www.travis-ci.org/&quot;&gt;https://www.travis-ci.org/&lt;/a&gt; 로 들어가라.&lt;/p&gt;

&lt;p&gt;Travis-ci 전용 빌드 스크립트는 무조건  .travis.yml 이여야 하고, 파일의 위치는 루트에 있어야 한다. 즉 경로로 따지만 “/.travis.yml” 이런 식이 되겠다. 그리고  자세한 내용은 원하는 플랫폼, 언어의 만들어진 예제를 보는게 빠를것이다. 커맨드 라인으로 컴파일을 하는 과정을 써야 하므로 플랫폼마다 다르다. &lt;a href=&quot;https://docs.travis-ci.com/user/customizing-the-build/&quot;&gt;Travis-CI : customizing the build&lt;/a&gt; 에서 빌드 파이프 라인등 여러가지 내용을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;다음은 Travis-CI 사이트에 가입 후 Travis-CI 에서 Github 계정으로 로그인을 해주어 API 의 접근을 허가받으면 된다. &lt;a href=&quot;https://www.travis-ci.org/&quot;&gt;https://www.travis-ci.org/&lt;/a&gt; 들어간다. &lt;a href=&quot;https://www.travis-ci.com/&quot;&gt;https://www.travis-ci.com/&lt;/a&gt; 은 유료인 Travis-Pro 버젼 사이트이니 구분해서 들어가도록 한다. 나는 무료인 &lt;a href=&quot;https://www.travis-ci.org/&quot;&gt;https://www.travis-ci.org/&lt;/a&gt; 으로 들어가겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/travis_ci_home.png&quot; alt=&quot;Travis-CI home&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사이트로 들어가면 오른쪽 상단에 Github 계정으로 로그인 하는 버튼과 중간에 가입하는 버튼이 있다,&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.travis-ci.com/user/private-dependencies/&quot;&gt;Travis-CI : private dependencies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;버튼을 눌러 Github 로그인을 하게되면 아래와 비슷한 화면이 나온다. 필자는 이미 가입해서 잘쓰고 있어 Travis-Pro 로 스크린샷을 찍었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/authorize_application.png&quot; alt=&quot;Travis-pro authorize&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 과정에서 승인을 해서 authorize 즉 승인을 하게되면 Travis-CI 의 기능을 사용할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;이제 Github API 사용 권한을 얻었으니 Travis-CI 홈페이지에 가서 어떤 레포리토리가 사용을 할 것인지 체크해주면 된다. 정말 쉽다. 홈페이지에 들어가서 우측 상단의 이름을 선택 후 나오는 Accounts 메뉴로 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/travis_ci_homepage.png&quot; alt=&quot;Travis-CI homepage upper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저 메뉴로 들어가면 본인의 레포지토리 리스트가 나올것이다. 나오지 않는다면 우측 상단에 Sync account 를 눌러주면 된다. Travis-CI 를 사용할 레포지토리를 토글해서 사용 표시 해놓으면 사용 준비는 끝이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/travis_ci_my_accounts.png&quot; alt=&quot;Travis-CI my accounts&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 사진은 필자의 Travis-CI 설정 화면이다. 여기까지 설정을 한 후 해당 레포지토리에 푸쉬를 하면 알아서 트리거가 되어 빌드 스크립트에 적힌대로 빌드를 실행한다.&lt;/p&gt;

&lt;h2&gt;빌드스크립트를 활용한 자동 배포 시스템 만들기&lt;/h2&gt;

&lt;p&gt;간단하게 활용하는 방법에 대해서 알아볼텐데 빌드 스크립트를 활용하여 Travis-CI 에서 빌드가 끝나면 Github 레포지토리에 푸시하는 스크립트를 만드는 방법에 대해서 알아볼 것이다.&lt;/p&gt;

&lt;p&gt;우선 Travis-CI 전용 빌드스크립트를 사용할려면 &lt;em&gt;Build Life Cycle&lt;/em&gt; 에 대하여 알아야 한다. &lt;a href=&quot;https://docs.travis-ci.com/user/customizing-the-build/&quot;&gt;Travis-CI : customizing the build&lt;/a&gt; 를 보면 바로 밑에 &lt;em&gt;Build Life Cycle&lt;/em&gt; 항목이 있을 것이다. 숫자가 쓰여있는대로 실행을 하는데 실행 과정은 한번을 빼고는 전부 선형적으로 되어있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;OPTIONAL Install apt addons&lt;/li&gt;
    &lt;li&gt;OPTIONAL Install cache components&lt;/li&gt;
    &lt;li&gt;before_install&lt;/li&gt;
    &lt;li&gt;install&lt;/li&gt;
    &lt;li&gt;before_script&lt;/li&gt;
    &lt;li&gt;script&lt;/li&gt;
    &lt;li&gt;OPTIONAL before_cache (for cleaning up cache)&lt;/li&gt;
    &lt;li&gt;after_success or after_failure&lt;/li&gt;
    &lt;li&gt;OPTIONAL before_deploy&lt;/li&gt;
    &lt;li&gt;OPTIONAL deploy&lt;/li&gt;
    &lt;li&gt;OPTIONAL after_deploy&lt;/li&gt;
    &lt;li&gt;after_script&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 과정에서 OPTIONAL 을 제외한 과정들이 주가되는 빌드 과정인데 before_install 과 install 에서는 본격적인 빌드에 앞서 필요한 것들을 설정하는 과정이고, before_script 와 script 과정은 실제 빌드를 하는 과정이다. 이 과정들에서 실행시에 정상적이지 못한 실행이 되면(return 0 가 아닐 때) Travis-ci 는 이를 문제로 파악해 빌드를 멈추고 에러가 나거나, 실패한 것으로 간주한다.&lt;/p&gt;

&lt;p&gt;그 이후의 after_success, after_failure 는 빌드가 성공하냐, 실패하냐에 따라 실행되는게 다른데 위에서 설명한 도중에 멈추었을 때 after_failure 에 있는것을 실행하고 문제없이 잘되면 after_success 에 있는 커맨드를 실행한다. 여기서는 빌드에서 상관없는 후처리를 하면 된다. 또한 여기서 비정상적인 종료는 그냥 넘어가게 된다. 그러니 중요한 빌드 과정은 위의 과정에 넣어두는게 좋다.&lt;/p&gt;

&lt;p&gt;이제 실제 적용사례를 보자. 이 블로그의 예전 빌드스크립트를 확인해 볼것이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;language: ruby
sudo: &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;cache: bundler
rvm:
  - 2.3.3
before_install:
  - gem update --system
  - gem update --remote bundler
install:
  - bundle install --jobs&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3 --retry&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3 --path&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;BUNDLE_PATH&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vendor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/bundle&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
before_script:
  - git config --global user.name &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;git --no-pager show --no-patch --format&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%an'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  - git config --global user.email &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;git --no-pager show --no-patch --format&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%ae'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
script:
  - git clone -b master --depth 1 --quiet &lt;span class=&quot;s2&quot;&gt;&quot;https://&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TOKEN&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;@github.com/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TRAVIS_REPO_SLUG&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.git&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;site
  - rm -r &lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;site/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
  - bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;jekyll build
after_success:
  - &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;site
  - git add -A
  - git commit -m &lt;span class=&quot;s2&quot;&gt;&quot;Updated to &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;git rev-parse --short &lt;span class=&quot;nv&quot;&gt;$TRAVIS_COMMIT&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; at &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;date -u +&lt;span class=&quot;s1&quot;&gt;'%Y-%m-%d %H:%M:%S %Z'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  - git push -f &lt;span class=&quot;s2&quot;&gt;&quot;https://&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TOKEN&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;@github.com/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TRAVIS_REPO_SLUG&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.git&quot;&lt;/span&gt; master --quiet
branches:
  only:
    - &lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 블로그는 &lt;em&gt;jekyll&lt;/em&gt; 을 기반으로 만들어져 있어 &lt;em&gt;jekyll&lt;/em&gt; 을 통해 빌드를 하면 기본적인 과정은 끝난다. &lt;em&gt;jekyll&lt;/em&gt; 의 기본 빌드 경로는 현재 디렉토리의 /_site 다. 그래서 위의 빌드스크립트에서도 _site 에서 무언가 많이 하는걸 볼 수 있는데, 중요한 것은 after_success 의 실행 커맨드다. 빌드가 끝난 후, 빌드 결과물이 있는 _site 경로로 이동해(cd _site) 모든 결과를 커밋해 푸시하는(이하 명령) 코드가 나와 있다.&lt;/p&gt;

&lt;p&gt;그런데 이상한 환경변수가 하나 있을 것이다. &lt;em&gt;TOKEN&lt;/em&gt; 이라는 이상한 환경변수가 하나 있는데, 이는 Travis-CI 에다가 필자가 직접 설정한 환경변수다. 이 환경변수는 Github 에서 push 하는 클라이언트를 인증하기 위한 문자열인데 이에 대해서는 조금 자세한 설명이 필요하다.&lt;/p&gt;

&lt;p&gt;Github 과 통신할 때, 인증서를 이용해 인증하는 방식과 url 에 클라이언트 인증 토큰을 포함해 인증하는 두가지 방식이 있다. 그리고 Travis-CI 에서 보여지는 공식 문서에서는 총 4가지 방식으로 인증하는 방법에 대해 나와 있는데 두개는 인증서를 통해, 두개는 토큰을 통해 인증하는 방식이다. 그런데 인증서를 통한 방식 중 하나는 Travis-Pro 사용해야 가능하고, 하나는 Travis-CI 시스템에서 인증서 비밀번호를 입력하는 단계를 지나지 못해 포기했었다. 결국 토큰을 포함하는 방법을 사용하게 되었는데 토큰은 두가지 방식으로 구성이 가능하다. 하나는 사용자의 아이디와 패스워드를 직접 url 에 넣는 방법과 하나는 사용자 계정에 설정된 토큰을 이용하는 방법이다. 직접 패스워드와 아이디를 설정하는 방법은 누가 봐도 상당히 문제가 있어보이기 때문에 사용자 토큰을 통해 인증하는 방식을 택했다. 인증에 대한 자세한 내용은 여기에 있다. &lt;a href=&quot;https://docs.travis-ci.com/user/private-dependencies/&quot;&gt;Travis-CI : private dependencies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;우선 사용자 토큰을 사용할려면 발급을 받아야 한다. Github -&amp;gt; Settings -&amp;gt; Personal access tokens 으로 들어가면 화면 상단에 아래와 같은 그림이 나올 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/personal_access_tokens.png&quot; alt=&quot;Github Personal access tokens&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기에는 자신의 Github 개인정보를 사용할 수 있는 토큰들이 발급된 리스트를 볼 수 있는데, 이상한게 있으면 지우는게 신상에 좋을 것이다. 그래서 우리는 새로 쓰일 토큰을 발급받아야 하기 때문에 상단에 있는 Generate new token 이라는 버튼을 눌러 만들면 된다. 한번 비밀번호 인증이 필요할 것이다. 토큰의 이름을 설정해주고 &lt;em&gt;repo&lt;/em&gt; 라고 써있는 상위 항목을 선택해준 뒤 만들면 된다. 계정 접근 권한을 선택하는 것이니 나머지는 안건드리는게 좋을 것이다. 그렇게 만들면 끝이 아니라, 만든 후에 다시 Personal access tokens 메뉴로 가게 되는데 여기서 새로 만든 토큰 문자열이 나온다. 딱 한번만 나오니 토큰을 까먹었다면 다시 해당 토큰으로 들어가 재발급 받아야 한다.&lt;/p&gt;

&lt;p&gt;이제 토큰을 얻었으니 Travis-CI 에 설정된 레포지토리 환경설정 정보에 업데이트를 해주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Travis-CI_myblog_repo.png&quot; alt=&quot;Travis-CI my repo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설정할 레포지토리 정보에 들어가면 위와같이 레포지토리 이름과 여러 정보들을 선택할 수 있는 메뉴가 나오는데, 오른쪽 상단에 &lt;em&gt;More Option&lt;/em&gt; 을 선택해 Settings 메뉴로 간다. 들어가면 조금 밑에 &lt;em&gt;Environment Variables&lt;/em&gt; 공간이 있는데 여기에 아까 환경변수 이름과 똑같이(&lt;em&gt;TOKEN&lt;/em&gt;) 써주고 토큰 값을 복사+붙여넣기 한 후 ADD 버튼을 눌러주면 토큰 설정은 끝이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/travis-ci_env_settings.png&quot; alt=&quot;Travis-pro authorize&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 설정을 하면 after_success 이후의 명령들을 잘 실행될 것이다. &lt;em&gt;TRAVIS_REPO_SLUG&lt;/em&gt; 라는 환경변수도 있는데 이는 Travis-CI 에서 지원하는 환경 변수다. 링크를 참조하라. (&lt;a href=&quot;https://docs.travis-ci.com/user/environment-variables/&quot;&gt;링크&lt;/a&gt;)&lt;/p&gt;

&lt;h1&gt;참조&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yous/whiteglass&quot;&gt;jekyll 테마 : whiteglass&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.travis-ci.com/user/customizing-the-build/&quot;&gt;Travis-CI : customizing-the-build&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.travis-ci.com/user/environment-variables/&quot;&gt;Travis-CI : environment-variables&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      
        <category term="makeblog" />
      
        <category term="try" />
      

      

      
        <summary type="html">Travis-CI : Continuous Intergration 다른 Github Repository 를 살펴보면서 많은 곳에서 Travis-CI 를 사용하고 있어 한번 시도해 보았다. 블로그를 만들기 이전부터 CI 에 대한 소식은 많이 들었지만 직접 사용해보는 것은 처음이였다. 약간 삽질을 했지만 영어만 읽을 줄 안다면 필요 없는 삽질이였다. 삽질할 때는 몰랐지만 Travis-CI 에서 제공하는 웹 문서들이 꽤 친절하게 되어있어 잘 읽고 따라하면 문제없이 세팅을 할 수 있을것이다. 물론 영어다.(Documentation) Travis-ci 는 Github 과 연동하여 사용할 수 있는 CI 서비스다. Jenkins씨 처럼 직접 사용환경을 만드는게 아니기 때문에 상당히 편하다. 또한 Travis-ci 는 빌드스크립트를 사용해서 빌드를 해주기 때문에 처음 사용하기엔 약간 불편하지만 “스크립트” 이기 때문에 강력한 범용성을 가진다. 현재 이 블로그에서는 Travis-ci 를 통해 유효성을 검증한 후에 실제 서비스하는 브랜치로 방법이 Travis-ci 빌드스크립트에 적용되어 있다. whiteglass 에 기본적으로 되어 있어 처음에는 의아했는데 꽤 괜찮은 아디이어여서 현재도 쓰고 있는 방법이다. Travis-ci 를 연동하고 활용하는 방법에 대해서 알아보자.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Usage Of Enumerator</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/28/usage-of-enumerator/" rel="alternate" type="text/html" title="Usage Of Enumerator" />
      <published>2017-04-28T00:00:00+00:00</published>
      <updated>2017-04-28T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/28/usage-of-enumerator</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/28/usage-of-enumerator/">&lt;p&gt;C# 언어에는 IEnumerator 를 사용한 몇몇의 기능들이 존재한다. List 같은 컨테이너부터 코드로 반복기를 만들어 제어하는 기능 등 여러가지를 제공하는데 그것들에 대하여 한번 알아보자.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2&gt;&lt;strong&gt;IEnumerator&lt;/strong&gt; 가 무엇인가요?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;IEnumerator&lt;/strong&gt; 는 단순한 반복의 개념을 인터페이스로 정의해놓은 것이다. 아래 코드에 정의를 가져왔다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Current&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MoveNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;단순한 인터페이스다. 총 세가지 종류의 필드와 메소드가 있는데, &lt;em&gt;Current&lt;/em&gt; 는 반복을 하는 중 현재 가리키는 항목을 가리키는 필드다. &lt;em&gt;MoveNext&lt;/em&gt; 는 다음 항목으로 이동하는 메소드인데, 다음 항목으로 더 이상 이동할 수 없으면 false 를 반환한다. &lt;em&gt;Reset&lt;/em&gt; 은 계속 반복하던 것을 초기값으로 설정하는 메소드이다. 이렇게 설명만 나열해 놓으면 이해하기 어려우니 가장 접하기 쉬운 예제를 하나 보자. 아마 본적이 있을 수도 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;integerList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;integerList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;integerList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;integerList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;integerList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;integerList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetEnumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MoveNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Current&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;\\n&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 예제는 &lt;em&gt;int&lt;/em&gt; 값을 연속적으로 가지고 있는 &lt;em&gt;integerList&lt;/em&gt; 에서 __IEnumerator&lt;int&gt;__ 를 생성해 _integerList_ 의 값을 순서대로 화면에 찍는 코드다. 우리가 주목할 부분은 새롭게 __IEnumerator&lt;int&gt;__ 를 생성하는 코드부터다. 생성 후 enumerator 의 _MoveNext_ 다음 항목으로 가는 메소드를 호출한다. 이때 다음으로 이동하지 못하면 루프를 탈출한다. 그 다음 _Console.WriteLine_ 함수에 _enumerator.Current_ 의 값을 넣어주어 화면에 출력한다.&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;이렇게 &lt;strong&gt;IEnumerator&lt;/strong&gt; 는 세가지 필드와 메소드로 컨테이너의 반복을 보여주었다. C# 에서 지원하는 대부분의 컨테이너는 &lt;strong&gt;IEnumerator&lt;/strong&gt; 의 서브클래스를 지원하여 반복해서 데이터들을 참조할 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;하지만 여기서 &lt;strong&gt;IEnumerator&lt;/strong&gt; 의 활용이 끝나는 것은 아니다. C# 은 단순한 데이터의 반복을 코드로도 지원하기 위해 반복기라는 개념을 구현해 놓았다.&lt;/p&gt;

&lt;h2&gt;반복기는 또 뭔가요?&lt;/h2&gt;

&lt;p&gt;위에서는 구현되어 있는 컨테이너에서 &lt;strong&gt;IEnumerator&lt;/strong&gt; 객체를 가져와서 사용했다면, 이번에는 코드로 반복하는 개념을 만들어 볼 수도 있다. 아래 코드를 보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetEnumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PrintNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetEnumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MoveNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Current&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;\\n&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 코드를 돌려보면 아마 0 부터 9까지 출력되는 모습을 볼 수 있을 것이다. 처음 보는 키워드에 당황할 수도 있지만 당황하지 말고 천천히 살펴보자. 일단 출력하는 코드는 위쪽에 있는 예제와 같다. 우선 반복은 똑같이 한다는 것을 알 수 있다. 하지만 처음 보는 키워드는 당최 이해하기 조금 힘들다. &lt;em&gt;return&lt;/em&gt; 키워드는 반환값을 메소드 밖으로 반환하고 메소드를 종료하는 것에 보통 쓰이는데 저기 쓰여 있는 &lt;em&gt;yield return i&lt;/em&gt; 는 메소드를 종료하는 것처럼 보이지는 않는다. 결과값는 0 부터 9 까지 출력되고 &lt;em&gt;yield return i&lt;/em&gt; 는 0 부터 9 까지의 값을 반환하니 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/csharp_iterator_run.png&quot; alt=&quot;Iterator Run Diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에 반복기가 &lt;em&gt;MoveNext&lt;/em&gt; 를 호출했을 때 하는 행동에 대해서 나와있다. &lt;em&gt;MoveNext&lt;/em&gt; 메소드를 호출하면 &lt;em&gt;yield return&lt;/em&gt; 구문이 나오거나 코드가 끝날 때까지 실행한다. &lt;em&gt;yield return&lt;/em&gt; 구문이 나와서 뭔가 반환하면 그 값을 &lt;strong&gt;IEnumerator&lt;/strong&gt;.&lt;em&gt;Current&lt;/em&gt; 에 넣는다. 그리고 true 를 반환하고 끝낸다. &lt;em&gt;yield return&lt;/em&gt; 구문이 안나오고, 코드가 끝이나면 false 를 반환하고 끝난다. 결국 반복기의 제어는 &lt;em&gt;MoveNext&lt;/em&gt; 에 달려있는 셈이다. 그리고 &lt;strong&gt;IEnumerator&lt;/strong&gt;.&lt;em&gt;Reset&lt;/em&gt; 은 반복기에서는 지원이 안된다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/system.collections.ienumerator.aspx&quot;&gt;MSDN : IEnumerator 인터페이스&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/65zzykke.aspx&quot;&gt;MSDN : 반복기 사용&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="c#" />
      

      

      
        <summary type="html">C# 언어에는 IEnumerator 를 사용한 몇몇의 기능들이 존재한다. List 같은 컨테이너부터 코드로 반복기를 만들어 제어하는 기능 등 여러가지를 제공하는데 그것들에 대하여 한번 알아보자.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Garbage Collector In Unity</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/23/garbage-collector-in-unity/" rel="alternate" type="text/html" title="Garbage Collector In Unity" />
      <published>2017-04-23T00:00:00+00:00</published>
      <updated>2017-04-23T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/23/garbage-collector-in-unity</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/23/garbage-collector-in-unity/">&lt;p&gt;C, C++ 을 제외한 C#, Java, Python 등 주류 애플리케이션 언어들은 대부분 메모리 관리를 garbage-collector(이하 GC) 라는 개념을 차용해 메모리를 관리한다. GC 는 특정한 메커니즘을 가지고 어플리케이션에서 사용하는 메모리를 관리해주는 개념이다. GC 는 언어별로, 구현된 사항별로 다르기 때문에 모든 개념이 통용되는 것은 아니지만 대부분 같은 개념에서 출발한다.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;C 언어와 C++ 언어에서는 기본적으로 메모리 관리를 사용자가 &lt;strong&gt;직접&lt;/strong&gt; 하도록 한다. 요즘 많이 쓰이는 스크립트 언어들과는 달리 높은 퍼포먼스 대비 약간의 불편함을 감수하는 언어로 설계되었기 때문이다. 아래 예제처럼 말이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 사용 코드..
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위처럼 시스템에 메모리를 요청해 직접 가져오고, 사용을 끝낸 메모리 공간들을 반환하는 관리 방식은 소프트웨어의 빠른 개발을 방해한다. 메모리를 직접 관리해야 하기 때문에 메모리 관리 코드를 일일히 만들어 주어야 한다. 게다가 잘못 사용하게 되면 프로그램의 크래쉬를 유발하기까지 한다.&lt;/p&gt;

&lt;p&gt;이러한 특징 때문에 많은 언어에서는 자동으로 메모리를 관리하는 여러가지 시스템이 있었는데, 직접 관리해주는 방식보다 조금 간단하게 변형된 메모리 관리 방식이 있다. 바로 reference-couting 방식이다.&lt;/p&gt;

&lt;p&gt;필자가 사용해본 언어에서 reference-couting 을 쓴 언어는 iOS 를 개발할 때 objective-c 를 사용해서 개발했었는데, 언어 자체에서 최상위 객체를 reference-couting 방식을 사용해 구현해 놓아서 당연히 reference-couting 방식을 사용해 개발을 해야했었다. 아래 objective-c 예제가 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;NSString* s = [[NSString alloc] init];  // NSString 오브젝트 생성 레퍼런스 카운트 1 올라감

// 객체 사용 코드..

[s release];                            // 레퍼런스 카운트 1 내려감&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;reference-couting 이란 객체를 참조하는 횟수를 세서 참조 횟수가 0이 되면 할당을 해제하는 방식이다. 위의 예제에서는 첫줄에 오브젝트를 생성할 때 ref-count 를 1 올려주고, 사용이 끝난 후에는 &lt;strong&gt;release&lt;/strong&gt; 메소드를 사용해 ref-count 를 1 낮추어 메모리를 해제하는 것을 보여준다.&lt;/p&gt;

&lt;p&gt;하지만 reference-couting 은 조금 불편하다. 사용자가 직접 카운트를 관리해야하는 것은 결국 메모리 관리 전략을 직접 짜는것이기 때문이다. 그 후 1990년 대 후반에 등장한 언어들은 전부 ㅎ 개념을 차용했는데 대표적인 언어가 위에서도 언급한 JAVA 와 C# 이다. 그 이후에도 많은 고수준 언어들이 GC 개념을 차용했다. 그 중 우리는 Unity 에서 쓰이는 GC 의 개념에 대해서 알아볼 것이다.&lt;/p&gt;

&lt;h2&gt;Mono-runtime 에서의 GC&lt;/h2&gt;

&lt;p&gt;Unity 는 여러 언어를 지원하기 위해 Mono 라는 오픈소스 언어 변환 프레임워크를 사용한다. 현재 Unity 에서 사용 가능한 언어들은 C#, JavaScript, Boo 가 있는데 전부 Mono 지원 언어의 하위 집합들이다. 즉 Unity 가 돌아가는 것은 Mono 기반의 가상머신에서 돌아가는 것이다. 이렇게 실제 runtime 상에서 돌아가는 가상머신을 &lt;a href=&quot;http://www.mono-project.com/docs/advanced/runtime/&quot;&gt;Mono-runtime&lt;/a&gt; 이라 칭하는데 Mono 는 C# 을 주로 타게팅하고 만들어진 프레임워크이기 때문에 &lt;a href=&quot;http://www.mono-project.com/docs/advanced/runtime/&quot;&gt;Mono-runtime&lt;/a&gt; 은 GC 를 탑재해야 했다.&lt;/p&gt;

&lt;p&gt;Mono 2.8 이하 버젼에서는 &lt;em&gt;Boehm-Demers-Weiser&lt;/em&gt;(이하 &lt;em&gt;Boehm&lt;/em&gt;) 라는 이름의 GC 알고리즘을 택했었는데, 이는 1988년에 처음 릴리즈되었고 (&lt;a href=&quot;http://www.hboehm.info/gc/license.txt&quot;&gt;license&lt;/a&gt;) C/C++ 를 타겟으로 만들어진 GC 라이브러리로써(&lt;a href=&quot;https://github.com/ivmai/bdwgc&quot;&gt;Github&lt;/a&gt;) 당시 쓸만한 GC 였던 것 같다. &lt;a href=&quot;https://schani.wordpress.com/2010/12/20/sgen/&quot;&gt;&lt;em&gt;SGen&lt;/em&gt; Introduction&lt;/a&gt; 에서는 안정성과 이식성이 좋아 쓰였다고 한다. 하지만 &lt;em&gt;Boehm&lt;/em&gt; GC 는 C/C++ 을 타겟으로 구현되었다. 그래서 여러 문제와 한계가 있어 Mono-runtime 은 다른 대안이 필요했다. 결국 Mono 에서는 직접 GC 를 개발했다. 주로 칭하는 이름은 &lt;em&gt;SGen&lt;/em&gt; 길게 풀면 &lt;em&gt;Simple Generational&lt;/em&gt; 이다. Mono 2.8 버젼부터는 &lt;em&gt;SGen&lt;/em&gt; 으로 GC 를 통채로 바꾸었다.&lt;/p&gt;

&lt;p&gt;하지만 지금 Unity 에서 쓰는 Mono 의 버젼은 2.8 을 넘지 못한다. 또한 직접 파일을 확인해 Mono 의 정보를 보면 아래와 같이 command line 에서 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/mono_version.png&quot; alt=&quot;mono --version&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;보다시피 GC 항목에는 &lt;em&gt;Include Boehm&lt;/em&gt; 이라고 쓰여 있다. 이 구버젼의 Mono 는 언제부터 유지되었는지 정확한 날짜는 모르겠다. 하지만 Unity 3.X 버젼부터 계속 유지되어온 것같다. 안정성 문제를 따져보면 Mono 2.8 이 릴리즈 된지는 7년이 지나고 있다. 개선이 된지 한참이 지났을텐데 왜 패치를 안하는지는 모르겠다. 이는 일부 사용자들에게 꽤나 많은 원성을 그전부터 계~속 받고 있었다.(&lt;a href=&quot;https://feedback.unity3d.com/suggestions/scripting-garbage-collection-sg&quot;&gt;SCRIPTING: GARBAGE COLLECTION SGEN-GC&lt;/a&gt; : 2010년에 올라온 글이다.)&lt;/p&gt;

&lt;p&gt;그나마 다행인 것은 최근 Unity 에서는 Mono 버젼업을 하겠다는 의지를 보였다. Unity 5.5 버젼에서는 Mono 컴파일러 버젼업을 했으며, 당장은 아니지만 이전에 Mono 업데이트를 하겠다는 글이 올라왔었다.(&lt;a href=&quot;http://blogs.unity3d.com/2016/04/01/unity-joins-the-net-foundation/&quot;&gt;joins-the-net-foundation&lt;/a&gt;) 하지만 가장 최근에 릴리즈된 5.6 버젼에서는 Mono-runtime 자체는 그대로 구버젼을 쓰고 있다. 아직은 기다려야 할듯하다.&lt;/p&gt;

&lt;p&gt;현재 Unity 에서 쓰이는 Mono-runtime 에 대해서 알아보았다. 아래에서는 언제가 될지 모르는 Mono 프레임워크 업데이트에 대비해 &lt;em&gt;SGen&lt;/em&gt; 의 간단한 동작방식과 쓰이는 여러 알고리즘에 대해서 알아볼것이다.&lt;/p&gt;

&lt;h2&gt;SGen 에서 쓰이는 GC 알고리즘&lt;/h2&gt;

&lt;p&gt;SGen 에서는 전통적으로 많이 쓰이는 여러 알고리즘을 사용한다. 대부분 대중적으로 많이 알려진 알고리즘을 채용해 알아두면 꽤 많은 도움이 될것이다.&lt;/p&gt;

&lt;h3&gt;&lt;em&gt;mark-and-sweep&lt;/em&gt; GC&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;mark-and-sweep&lt;/em&gt; 은 GC 알고리즘 중에서도 시초가 되는 알고리즘이며, 가장 간단한 GC 방법이다. 이름만 살펴보면 표시하고(&lt;em&gt;mark&lt;/em&gt;) 쓸어담기(&lt;em&gt;sweep&lt;/em&gt;) 로 알 수 있는데 조금 더 풀어보면, 메모리가 부족하거나 안쓰는 메모리를 없에야 할 때 사용하는 메모리를 표시하고(&lt;em&gt;mark&lt;/em&gt;) 표시가 해제된 메모리 영역을 쓸어담아(&lt;em&gt;sweep&lt;/em&gt;) 청소하는 방식이라 할 수 있다. 그림으로 표현하자면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/mark_and_sweep_0.png&quot; alt=&quot;mark and sweep 0&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어플리케이션 메모리에서 새롭게 오브젝트가 생성 되었을 때의 상태를 표시했다. 상자들에 붙어 있는 초록색 번개는 사용중인 오브젝트를 표시(&lt;em&gt;mark&lt;/em&gt;)한 것이다. 보통은 오브젝트 한개당 1bit 를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/mark_and_sweep_1.png&quot; alt=&quot;mark and sweep 1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;꽤 시간이 GC 가 쓸기(&lt;em&gt;sweep&lt;/em&gt;) 행동을 하여 사용되지 않는 오브젝트를 청소하려 했으나 아무것도 없어 그냥 넘어가고, Object2 가 더 이상 참조되지 않아 Object2 를 사용되지 않는다고 표시(&lt;em&gt;mark&lt;/em&gt;) 하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/mark_and_sweep_2.png&quot; alt=&quot;mark and sweep 2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GC 가 메모리들을 정리할 때가 되어 사용되지 않는 메모리들을(&lt;em&gt;unreachable&lt;/em&gt;) 전부 쓸어서(&lt;em&gt;sweep&lt;/em&gt;) 정리한다. 이것이 &lt;em&gt;mark-and-sweep&lt;/em&gt; 의 개념이다. &lt;em&gt;Boehm&lt;/em&gt; GC 은 이 &lt;em&gt;mark-and-sweep&lt;/em&gt; 을 기본 개념으로 채용하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;기본적인 &lt;em&gt;mark-and-sweep&lt;/em&gt; 은 두가지 문제를 가지고 있다. &lt;em&gt;sweep&lt;/em&gt; 단계에서 모든 개체들을 추적하여 체크해야 하는것이 있고, 메모리 단편화에(&lt;a href=&quot;https://en.wikipedia.org/wiki/Fragmentation_%28computing%29&quot;&gt;Wiki : Memory Fragmentation&lt;/a&gt;) 대한 대책이 없다. 첫번째 문제는 &lt;em&gt;Generation GC&lt;/em&gt; 에서 확인하고, 두번째 메모리 단편화에 대한 문제에 대해 알아보자. 아래 그림을 보면된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/fragmentation.png&quot; alt=&quot;fragmentation&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://developer.brewmp.com/resources/tech-guides/memory-and-heap-technology-guide/high-level-architecture/memory-fragmentation&quot;&gt;출처 : brewmp developer site&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 그림은 1,2,3,4 숫자 순서대로 실행되는 그림인데, 저 순서대로 진행되어 중간중간에 16kb 가 비게 되어 메모리가 조각난다면(fragmentation), 16kb 보다 더 큰 메모리를 한꺼번에 할당할 때 문제가 생긴다. 그래서 상용에서 쓰이는 GC 가 &lt;em&gt;mark-and-sweep&lt;/em&gt; 을 사용했을 때에 대비한 많은 해결책이 있는데,  단점을 보완한 개량된 여러 버젼의 알고리즘이 꽤 많이 존재한다. &lt;em&gt;mark-and-sweep&lt;/em&gt; 자체를 개량한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mark-compact_algorithm&quot;&gt;&lt;em&gt;mark-and-compact&lt;/em&gt;&lt;/a&gt; 알고리즘이 &lt;em&gt;mark-and-sweep&lt;/em&gt; 과 가까운 알고리즘이다. 하지만 &lt;em&gt;SGen&lt;/em&gt; 은 다른 알고리즘을 사용했다.&lt;/p&gt;

&lt;h3&gt;&lt;em&gt;Copying&lt;/em&gt; GC&lt;/h3&gt;

&lt;p&gt;한글로는 객체 이동 기법이라 하고, 영어로는 “&lt;em&gt;Copying&lt;/em&gt;” 이라고 한다. &lt;em&gt;mark-and-sweep&lt;/em&gt; 에서 중간 중간 비는 메모리 파편화(fragmentation)를 메커니즘을 바꾸어 해결한 케이스인데 자세한 사항은 아래 그림을 보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/copying_garbage_collection.svg&quot; alt=&quot;copying&quot; class=&quot;center-image&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;http://www.memorymanagement.org/&quot;&gt;출처 : memorymanagement.org&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 그림에서는 3단계를 나누어 &lt;em&gt;Copying&lt;/em&gt; GC 를 설명하고 있는데, 쓰레기 수집(collection) 전에 이미 흰색으로 마크된 닿을 수 없는(unreachable), 버려진 메모리와 현재 사용중인 메모리가 한 공간에 존재한다. 또한 첫번째 그림에는 없지만 현재 실제로 사용하는 메모리가 있는 공간 외에도 같은 크기의 크기를 가진 공간이 하나 더 존재한다. 두번째 그림을 보면 이해가 갈것이다. 쓰레기 수집(collection) 을 하게 되면, 사용하던 메모리들이 존재하던 공간말고 다른 공간에 사용하던 메모리들만 복사한다. 이때 버려진(unreachable, dead) 메모리들은 복사하지 않는다. 복사 과정이 끝나면 기존에 있던 메모리 정보들은 싹다 지운다. 다음 쓰레기 수집(collection) 과정에서 싹다 지워버린 공간(남겨진 공간)으로 복사 후 쓰던 공간을 지우는 것을 반복한다. 이렇게 복사(copying)하고, 지우고 하는 과정이 무한 반복되는 방법이 &lt;em&gt;Copying&lt;/em&gt; GC 알고리즘이다.&lt;/p&gt;

&lt;h3&gt;&lt;em&gt;Generational&lt;/em&gt; GC&lt;/h3&gt;

&lt;p&gt;위에서 GC 알고리즘 2가지에 대해서 알아 보았는데, 두 방법들이 메모리를 직접 관리하는 방법에 대한 것이라면, &lt;em&gt;Generational&lt;/em&gt; GC 의 접근 방법은 조금 다르다. 일반적인 메모리의 생명 주기는 아주 짧게 있다가 사라지거나, 아주 오랜 기간 동안 쓰인다. 그래서 힙을 두개 이상의 세대(&lt;em&gt;Generational&lt;/em&gt;)로 나누어 다른 방식으로 관리하는 “&lt;em&gt;generational hypothesis&lt;/em&gt;“(세대 별 가설) 을 사용하는 것이 &lt;em&gt;Generational&lt;/em&gt; GC 의 기본적인 접근 방식이다.&lt;/p&gt;

&lt;p&gt;세대 별 가설은 구현된 플랫폼, 언어 별로 다 다르다. 하지만 여러 사례들을 보고 전체적으로 살펴보면 크게 다를 바는 없다.(물론 세부 구현은 다르겠지만) 이 글에서는 &lt;em&gt;SGen&lt;/em&gt; 만 살펴보도록 하겠다. &lt;em&gt;SGen&lt;/em&gt; 의 전체 이름은 &lt;em&gt;Simple Generational&lt;/em&gt; GC 다. 세대 구성이 간단하다는 뜻을 가지고 있는데, 이름과 같이 아주 여러개의 세대를 가지고 있는게 아니라 딱 2개의 세대로만 분리한다. 하나는 &lt;em&gt;Nursery&lt;/em&gt; 이고, 나머지 하나는 &lt;em&gt;Major Heap&lt;/em&gt; 이다. 우선 &lt;em&gt;Nursery&lt;/em&gt; 부터 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nursery&lt;/em&gt; 는 아기방, 보육원 이런 늬앙스를 가지고 있는데 뜻과 같이 처음 생겨나는 메모리 개체가 생성되는 세대다. &lt;em&gt;Nursery&lt;/em&gt; 의 전략은 빠르게 사라지는 메모리들을 수집하고, 유지되는 메모리 개체들을 상위 세대에 빠르게 올리는 목적이라 쓰레기 수집(GC)의 빈도가 높다. 메모리 개체가 일정 기간 동안 혹은 일정 GC 횟수가 지나고 살아 남아 있다면 상위 세대로 승진(&lt;em&gt;promote&lt;/em&gt;) 시킨다. 바로 &lt;em&gt;Major Heap&lt;/em&gt; 으로 말이다. 참고로 두 세대의 용도가 다르므로 &lt;em&gt;Nursery&lt;/em&gt; 와 &lt;em&gt;Major Heap&lt;/em&gt; 은 수집 알고리즘이 조금 다르다.&lt;/p&gt;

&lt;p&gt;아래에 간단하게 &lt;em&gt;SGen&lt;/em&gt; 의 동작 방식을 그림으로 살펴보자.(&lt;a href=&quot;http://www.mono-project.com/docs/advanced/garbage-collector/sgen/working-with-sgen/&quot;&gt;Working with SGen&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mono-project.com/archived/images/1/15/SGenSpaces.png&quot; alt=&quot;SGen hypothesis 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 처음 응용 프로그램이 실행 되었을 때다. 가장 처음에는 사용하는 메모리 공간이 없으므로 모든 공간들이 비어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mono-project.com/archived/images/4/43/SgenNurseryAlloc.png&quot; alt=&quot;SGen hypothesis 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행한지 시간이 조금 지나게 되어 &lt;em&gt;Nursery&lt;/em&gt; 에 새로운 개체들이 점점 늘어난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mono-project.com/archived/images/5/58/SgenEvacuation.png&quot; alt=&quot;SGen hypothesis 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어떤 규칙이나, 혹은 &lt;em&gt;Nursery&lt;/em&gt; 의 공간이 거의 가득 찼을 때, 쓰레기 수집을 하고 몇번의 쓰레기 수집에서 살아남은 메모리 개체들을 &lt;em&gt;Nursery&lt;/em&gt; 에서 &lt;em&gt;Major Heap&lt;/em&gt; 으로 승진시킨다. 옆의 &lt;em&gt;Large Object Space&lt;/em&gt; 는 지정된 크기(기본값은 8000바이트)를 초과하는 큰 메모리 개체들을 관리하는 공간이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;SGen&lt;/em&gt; 에서 쓰이는 GC 알고리즘들에 대해 간단히 알아보았다. 자세히 알아보지 않는 이유는 어차피 몰라도 코드를 짤때도 몇가지 사항들만 조심한다면 크게 문제될 것은 없다. 하지만 프로그래머로써의 최소한의 상식들을 위해 알아보았다. 한가지 상식을 위해 덧붙이자면 &lt;em&gt;Boehm&lt;/em&gt; 은 &lt;em&gt;mark-and-sweep&lt;/em&gt; 을 기본 개념으로 차용한다. 아래 항목들에서는 실제 스크립팅에서 억울하게 버려지는 메모리를 발생시키는 코드들에 대해서 알아볼 것이다.&lt;/p&gt;

&lt;h2&gt;Unity 스크립팅에서 실질적인 가비지 컬렉션 원인 및 대안&lt;/h2&gt;

&lt;p&gt;위에서 우리는 실제로 코딩과는 그다지 상관없는 정보를 얻었다. 결국 프로그래머에게 가장 중요한것은 본인의 코딩이 어떤 영향을 끼치는 것인지가 중요하다. Unity 스크립팅에서 쓰레기를 남겨 청소를 하게 만드는(Garbage Collecting 을 유발하는) 몇가지 방법에 대해 알아보자.&lt;/p&gt;

&lt;h3&gt;ToString(), ToArray() 등의 데이터 컨버팅 메소드&lt;/h3&gt;

&lt;p&gt;C# 에서 지원하는 대부분의 자료형들은 &lt;em&gt;ToString&lt;/em&gt; 이라는 메소드를 지원한다. 이는 데이터를 문자열로 변환하는 메소드 인데, 정확히 말하자면 문자열을 새로 만들어(allocation) 그 문자열에다가 데이터의 타입, 값 자체를 쓴다. 우리가 주목할 부분은 문자열을 새로 만드는게 중요한 것이다. 대부분 코드에서는 &lt;em&gt;ToString&lt;/em&gt; 을 남발하기 십상인데, 매 프레임마다 호출되는 &lt;em&gt;Update&lt;/em&gt; 메소드에서 &lt;em&gt;ToString&lt;/em&gt; 을 남발했다가는 꽤나 심한 프레임 드랍이 일어날 것이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이렇게 To 접두사가 붙는 데이터 컨버팅 메소드는 메모리 공간을 새로 할당하는 메소드가 대부분이다. 최대한 사용을 자제해야 하고, &lt;strong&gt;List&lt;/strong&gt; 컨테이너의 &lt;em&gt;ToArray&lt;/em&gt; 메소드 같은 컨테이너 컨터팅 메소드는 대부분 &lt;strong&gt;ref&lt;/strong&gt; 문법을 사용해 존재하는 배열에 값을 써주는 메소드가 존재한다.&lt;/p&gt;

&lt;h3&gt;string + 연산자 사용&lt;/h3&gt;

&lt;p&gt;C# 은 문자열 자체도 객체로 보기 때문에 여러 기능을 사용할 수 있는데 그 중 편리하게 사용되는 기능은 ‘+’ 연산자 오버로딩이다. 이 기능은 문자열과 문자열을 합쳐주는 기능으로 사용시 조금 부담이 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;check : &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;..&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 예제에서 ‘+’ 연산자 오버로딩을 통해 문자열 3개를 합치는 모습이 나오는데, 총 두번 합치는 것을 실행한다. 맨 처음 &lt;em&gt;“check : “&lt;/em&gt; 문자열과 (5+5) 를 문자열로 컨버팅한 &lt;em&gt;“10”&lt;/em&gt; 문자열을 합친다. 그러면 &lt;em&gt;“check : 10”&lt;/em&gt; 문자열이 새로 생기는데 문제는 다음이다. 새로 생긴 &lt;em&gt;“check : 10”&lt;/em&gt; 과 &lt;em&gt;”..”&lt;/em&gt; 를 합친다. 그러면 &lt;em&gt;“check : 10..”&lt;/em&gt; 문자열이 새로 생기고, print 메소드가 실행된 이후에는 새로 생긴 한개의 문자열 &lt;em&gt;“check : 10”&lt;/em&gt; 이 정말 쓸데없이 버려지게 된다.&lt;/p&gt;

&lt;p&gt;이렇게 ‘+’ 연산자 때문에 버려지는 메모리를 안생기게 하려면 다른 방법이 있다. 하나는 &lt;strong&gt;.Net&lt;/strong&gt; 의 &lt;em&gt;string.Format&lt;/em&gt; 메소드다. C 를 배워본 사람이라면 알겠지만 문자를 출력할 때 서식을 이용해 서식 문자열과 함께 인자를 넣어 각 함수가 알아서 서식 문자에 넣어둔 데이터를 읽어 새로운 문자열을 만들어 주는 것이다. 하나는 &lt;strong&gt;.Net&lt;/strong&gt; 의 &lt;strong&gt;StringBulider&lt;/strong&gt; 클래스다. 빌더 패턴을 이용해 문자열을 합치는 기능을 제공하는 클래스로 조금 더 직관적이고 &lt;em&gt;string.Format&lt;/em&gt; 처럼 한번에 바꾸는게 아니라 &lt;em&gt;ToString&lt;/em&gt; 함수를 통해 새로운 인스턴스를 원하는 시점에 만들 수 있어 동적인 환경에서 편하게 사용할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;check : {0}..&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;check : &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;..&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3&gt;박싱 : 스택 데이터를 &lt;strong&gt;object&lt;/strong&gt; 로 변환시킬 때&lt;/h3&gt;

&lt;p&gt;이 설명은 &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/yz2be5wk.aspx&quot;&gt;MSDN&lt;/a&gt; 에서 가져왔다.&lt;/p&gt;

&lt;p&gt;여기서 우리가 주의깊게 살펴볼 사항은 버려지는 메모리인데, 여기서 버려지는 메모리는 스택에 존재하는 단순 값들을 &lt;strong&gt;object&lt;/strong&gt; 로 반환할 때 생기는 일이다. 이런일은 잘 발생하지 않지만 짚고 넘어가보겠다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boxing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://i-msdn.sec.s-msft.com/dynimg/IC165510.jpeg&quot; alt=&quot;MSDN : boxing&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 코드처럼 객체가 아닌 stack 에 존재하는 데이터를 박싱할 때 사본은 heap 에 생성하므로써, 잠시 이용하고 버려지는 메모리가 발생하게 된다. 또한 이런 코드는 성능에도 영 좋지 않으니 남발하지 않는게 좋다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_%28%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99%29&quot;&gt;위키피디아(한글) 쓰레기 수집기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%B0%B8%EC%A1%B0_%ED%9A%9F%EC%88%98_%EA%B3%84%EC%82%B0_%EB%B0%A9%EC%8B%9D&quot;&gt;참조 횟수 계산 방식&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/ms973837.aspx&quot;&gt;MSDN : 가비지 수집기 기본 및 성능 힌트&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ronniej.sfuh.tk/c-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A3%BC%EA%B8%B0-%EC%8A%A4%EC%BD%94%ED%94%84-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-lifetime-scope-garbage-collection/&quot;&gt;C# GC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Boehm_garbage_collector&quot;&gt;Boehm garbage collector&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ivmai/bdwgc&quot;&gt;Github : Boehm-Demers-Weiser GC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mono-project.com/docs/advanced/runtime/&quot;&gt;Mono-runtime&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mono-project.com/docs/advanced/garbage-collector/sgen/&quot;&gt;Mono GC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mono-project.com/docs/advanced/garbage-collector/sgen/working-with-sgen/&quot;&gt;Mono working with SGen&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://schani.wordpress.com/2010/12/20/sgen/&quot;&gt;SGen&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://feedback.unity3d.com/suggestions/scripting-garbage-collection-sg&quot;&gt;Unity feedback : SCRIPTING: GARBAGE COLLECTION SGEN-GC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.schrankmonster.de/2010/09/01/taking-the-new-and-shiny-mono-simple-generational-garbage-collector-mono-sgen-for-a-walk/&quot;&gt;Benchmark Boehm vs SGen using GraphDB &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.cornell.edu/courses/cs312/2003fa/lectures/sec24.htm&quot;&gt;Copying garbage collection&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://d2.naver.com/helloworld/1329&quot;&gt;NAVER D2 : JAVA garbage collector&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&quot;&gt;Wikipedia : C#&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/yz2be5wk.aspx&quot;&gt;MSDN : boxing and unboxing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
## 참조 문서 다운로드 링크

- [Boehm Tutorial - PPT 다운로드 링크](http://www.research.ibm.com/ismm04/slides/boehm-tutorial.ppt)
- [Bounding Space Usage of Conservative Garbage Collectors](https://pdfs.semanticscholar.org/b5de/c18f67406975f98a2e20dfb362d4e0542a91.pdf)
--&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="mono" />
      
        <category term="c#" />
      
        <category term="gc" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">C, C++ 을 제외한 C#, Java, Python 등 주류 애플리케이션 언어들은 대부분 메모리 관리를 garbage-collector(이하 GC) 라는 개념을 차용해 메모리를 관리한다. GC 는 특정한 메커니즘을 가지고 어플리케이션에서 사용하는 메모리를 관리해주는 개념이다. GC 는 언어별로, 구현된 사항별로 다르기 때문에 모든 개념이 통용되는 것은 아니지만 대부분 같은 개념에서 출발한다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Usage Of Coroutine</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/21/usage-of-coroutine/" rel="alternate" type="text/html" title="Usage Of Coroutine" />
      <published>2017-04-21T00:00:00+00:00</published>
      <updated>2017-04-21T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/21/usage-of-coroutine</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/21/usage-of-coroutine/">&lt;p&gt;Unity 는 코루틴이라는 괴상한(?) 코딩 방식을 지원한다. 맨 처음에 발견했을 때는 Synchronize 한 코딩 방식에 익숙해져 있어 상당히 낯설고 적응이 안됐다. 하지만 응용 범위를 늘려가다보니 상당히 편한 코딩 방식이라는 것을 깨닳았다. 한번 코루틴에 대해 알아보자.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2&gt;Coroutine 사용하기&lt;/h2&gt;

&lt;p&gt;아래 예제를 보자. 몇초를 기다리는 로직을 코루틴을 사용해 구현했다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait3Second&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait3Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Start.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;After 3 second.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait3Second&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;시작 후 3초를 기다리는 간단한 코드다. 이 코드는 시작할 때 로그가 출력되고, 3초가 지난 후에 로그를 출력한다. 그리고 3초가 지가가기 전에 스페이스바를 누르면 실행하던 코루틴을 취소한다. &lt;strong&gt;StartCoroutine&lt;/strong&gt; 으로 코루틴 함수를 실행하면 코드에서 &lt;em&gt;yield return&lt;/em&gt; 구문이 나오기 전까지 실행하다가 &lt;em&gt;yield return&lt;/em&gt; 에서 반환하는 데이터에 따라 기다리기를 끝날때까지 반복한다. 아래 그림을 보면 이해가 쉬울 것 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/common_coroutine_execute.png&quot; alt=&quot;coroutine execute&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코루틴의 동작을 매우 간단하게 표현한 그림이다. 그런데 코루틴은 위 예제에서 호출한 방식 말고도 다른 방식으로 제어가 가능하다. 아래 예제를 살펴보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;Coroutine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait Start: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait Mid: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ~ &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait End: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ~ &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Start] \&quot;Wait\&quot; by method call and store enumerator, coroutine&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Start] \&quot;Wait\&quot; by method name and store coroutine&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Stop] \&quot;Wait\&quot; by using enumerator&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Stop] \&quot;Wait\&quot; by using method name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Stop] \&quot;Wait\&quot; by using coroutine&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopAllCoroutines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Stop] all \&quot;Wait\&quot; context&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 예제는 A, S 키를 누르면 &lt;em&gt;Wait&lt;/em&gt; 코루틴을 실행시키고, Z,X,C,V 키를 누르면 실행하던 &lt;em&gt;Wait&lt;/em&gt; 코루틴을 멈추는 코드로 되어 있다.&lt;/p&gt;

&lt;p&gt;조금 더 자세하게 설명하자면, 실행한 방식과 멈추는 방식이 비슷한 제어 방법은 두가지가 있다. 하나는 메소드를 실행시켜 나온 &lt;strong&gt;IEnumerator&lt;/strong&gt; 객체를 통하여 실행하고(A키) 멈추는(Z키) 방법, 나머지 하나는 메소드 이름을 통하여 코루틴을 실행시키고(S키) 멈추는(X키) 방법이 있다.&lt;/p&gt;

&lt;p&gt;다만 이름을 통해서 코루틴을 실행하는 방법은 같은 이름의 메소드가 존재할 때는 코드의 위쪽에 있는 것을 실행하고, 이름을 통해 코루틴을 멈추는 방법은 같은 메소드로 호출한 코루틴을 전부 멈추기 때문에 주의하기 바란다.&lt;/p&gt;

&lt;p&gt;그리고 코루틴을 멈추는 방법 중 두가지가 더 있는데, 하나는 MonoBehaviour 인스턴스에서 실행한 코루틴을 전부 멈추는 방법, 나머지 하나는 &lt;strong&gt;StartCoroutine&lt;/strong&gt; 이 반환한 객체 &lt;strong&gt;Coroutine&lt;/strong&gt; 을 사용하여 실행한 코루틴 하나를 멈추는 방법이다. &lt;strong&gt;Coroutine&lt;/strong&gt; 객체는 단지 코루틴을 실행했을 때, 실행한 코루틴을 제어하기 위해 사용하는 객체다. 이 &lt;strong&gt;Coroutine&lt;/strong&gt; 객체를 이용해 코루틴을 멈추는게 가장 좋은 듯 하다. &lt;strong&gt;IEnumerator&lt;/strong&gt; 객체를 통하여 멈추는 방식은 중간에 &lt;em&gt;yield return&lt;/em&gt; 으로 반환한 객체를 확인 가능하고 직접 제어가 가능하기 때문에 꼭 참조해야할 일이 아니면 &lt;strong&gt;Coroutine&lt;/strong&gt; 객체를 사용하는게 안전할 것이다.&lt;/p&gt;

&lt;p&gt;또한 &lt;strong&gt;Coroutine&lt;/strong&gt; 객체는 멈추는 역할 말고도 다른 역할 한가지를 더 수행할 수 있다. 바로 코루틴을 중첩하는 경우에 사용가능한데, 위 예제에 아래 코드를 보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Coroutine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;justWait&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;justWait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드는 맨 처음 &lt;em&gt;Wait&lt;/em&gt; 메소드를 &lt;strong&gt;StartCoroutine&lt;/strong&gt; 을 사용하여 실행한 후, 반환한 &lt;strong&gt;Coroutine&lt;/strong&gt; 객체를 &lt;em&gt;yield return&lt;/em&gt; 으로 반환해주면 해당 코루틴이 끝날 때까지 기다려준다. 그리고 기다리는 코루틴이 끝나면 크기를 1.1배 늘려주는 루틴을 계속 반복한다. 위와 같이 &lt;strong&gt;WaitForSeconds&lt;/strong&gt; 나, 실행된 코루틴 객체를 넣어주면 해당 루틴이 끝날 때까지 기다려 주기 때문에, 프레임별로 코딩을 하는 방식에서 시간과 여러 타이밍을 생각하는 비동기적 방식의 코딩이 가능하다. 이는 Unity 의 C# 스크립팅에 혁신적인 변화를 주었다. 그리고 Update 의 사용을 적게 해주기 때문에 Update 콜을 적게해주어 아주 조금의 퍼포먼스 향상도 기대할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 코루틴은 숙달되지 않은 프로그래머가 쓰게되면 그다지 좋은 코딩 방식은 아니다. 코루틴을 처음 접하게 되는 프로그래머는 기존의 프레임별로 실행하던 코드에서 Unity 에서만 쓰이는 코루틴의 개념을 생각하면서 코딩을 해야하기 때문에 상당히 혼란스러울 것이다. 또한 코루틴은 비동기 시스템이기 때문에 Multi Threading 이라 착각하는 경우가 있는데, 단지 Multi tasking 일 뿐이고, 같은 쓰레드에서 실행된다. 아래 그림을 보면 알 수 있을것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity-callback-order.png&quot; alt=&quot;Unity callback order&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결국 단일 쓰레드에서 실행되는 시스템이면 코루틴을 쓴다고해서 혁신적인 성능향상을 기대하기는 힘들다. 단지 다른 Update 방식이라 생각하면 될듯하다.&lt;/p&gt;

&lt;h2&gt;Unity 에서 지원하는 코루틴 대기 제어 기능들&lt;/h2&gt;

&lt;p&gt;코루틴을 사용할 때 기다려야 할 때 여러 기능들을 제공한다.&lt;/p&gt;

&lt;p&gt;대표적인 예는 시간을 기다리는 기능들이다. &lt;strong&gt;WaitForSeconds&lt;/strong&gt; 와 &lt;strong&gt;WaitForSecondsRealtime&lt;/strong&gt; 가 있는데 게임 어플리케이션의 시간과 실제 시간을 기다리는 기능이다. 위에서 &lt;strong&gt;WaitForSeconds&lt;/strong&gt; 를 사용했다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait Start: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait Mid: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ~ &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait End: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ~ &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 콜백이 실행되는 그림을 살펴보면 Game Logic 레이어에서 대부분 멈춰준다. 이 타이밍은 &lt;em&gt;Update&lt;/em&gt; 가 호출된 후, &lt;em&gt;LateUpdate&lt;/em&gt; 가 호출되기 전인데 누군가는 이 시점 말고 다른 시점에 코루틴을 멈추고 싶을 수도 있다. 그래서 Unity 에서는 다른 두 타이밍에 기다림을 멈추는 기능이 있다. &lt;strong&gt;WaitForFixedUpdate&lt;/strong&gt; 과 &lt;strong&gt;WaitForEndOfFrame&lt;/strong&gt; 인데,  &lt;strong&gt;WaitForFixedUpdate&lt;/strong&gt; 는 &lt;em&gt;FixedUpdate&lt;/em&gt; 들이 호출된 후 타이밍에 멈춰주는 기능으로써 물리 기반 기능과 같은 타이밍을 공유하고 싶을 때 사용하면 된다. &lt;strong&gt;WaitForEndOfFrame&lt;/strong&gt; 은 한 프레임의 모든 처리가 끝난 후까지 기다려주는 기능으로써 무언가 후처리를 할 때 사용해주면 된다.&lt;/p&gt;

&lt;p&gt;또한 사용자가 멈추고 싶은 타이밍에 멈추는 경우도 필요할 것이다. 그래서 두가지 논리적인 조건이 충족할 때 멈춰주는 기능도 있다. &lt;strong&gt;WaitUntil&lt;/strong&gt; 과 &lt;strong&gt;WaitWhile&lt;/strong&gt; 인데, 단순하게 &lt;em&gt;Func&amp;lt;bool&amp;gt;&lt;/em&gt; 델리게이트만 받아 참이냐, 거짓이냐에 따라서 기다림을 제어한다. &lt;strong&gt;WaitUntil&lt;/strong&gt; 은 델리게이트가 반환하는 값이 &lt;em&gt;false&lt;/em&gt; 일 때 다음으로 넘어가고, &lt;strong&gt;WaitWhile&lt;/strong&gt; 델리게이트가 반환하는 값이 &lt;em&gt;true&lt;/em&gt; 일 때 다음으로 넘어가기 된다.&lt;/p&gt;

&lt;p&gt;마지막으로 프로토콜로 통신하는 기능을 사용할 때 사용하는 &lt;strong&gt;WWW&lt;/strong&gt; 라는 특수한 제어 객체가 있다. 이는 보통 &lt;em&gt;http&lt;/em&gt; 통신을 해서 무언가 받아올 때 사용한다. 아래 예제가 대표적인 예시다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getGoogle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;WWW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;google&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WWW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://www.google.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;보통은 위 예제처럼 &lt;em&gt;http&lt;/em&gt; 통신을 해서 데이터를 가져올 때 사용한다. 로컬 파일 시스템이나 ftp 프로토콜도 가능하다. 자세한 사항은 &lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/WWW.html&quot;&gt;Unity WWW&lt;/a&gt; 여기서 확인하라.&lt;/p&gt;

&lt;p&gt;이렇게 Unity 에서 기다림을 제어하는 기능에 대해서 알아보았다. 하지만 이 기능들 가지고는 약간 부족한 부분이 있을 것이다. 이를 위해 Unity 에서는 &lt;strong&gt;CustomYieldInstruction&lt;/strong&gt; 이라는 기능을 제공한다.&lt;/p&gt;

&lt;h2&gt;CustomYieldInstruction 를 사용해서 커스터마이징하기&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CustomYieldInstruction&lt;/strong&gt; 을 통해 기다리는 기능을 상당히 간단하게 구현이 가능하다. &lt;strong&gt;CustomYieldInstruction&lt;/strong&gt; 는 &lt;em&gt;keepWaiting&lt;/em&gt; 이라는 abstract 프로퍼티를 통해 값이 &lt;em&gt;false&lt;/em&gt; 일 때는 기다리고, &lt;em&gt;true&lt;/em&gt; 일 때는 넘어가는 간단한 &lt;strong&gt;IEnumerator&lt;/strong&gt; 구현체다. 즉 &lt;strong&gt;CustomYieldInstruction&lt;/strong&gt; 을 상속받아 &lt;em&gt;keepWaiting&lt;/em&gt; 프로퍼티만 구현하면 끝이다. 아래 transform 의 scale 을 검사해서 일정 값을 초과하게 되면 다음으로 넘어가는 기능을 아래 예제에 첨부했다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ScaleOverYieldInstruction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CustomYieldInstruction&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ScaleOverYieldInstruction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepWaiting&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;구현 자체는 상당히 간단하다. 일반적인 클래스 인스턴스 처럼 생성자에서 초기화를 해주고, &lt;em&gt;keepWaiting&lt;/em&gt; 구현을 한 것이 보인다. 다만 조금 의문이 드는점은 &lt;em&gt;keepWaiting&lt;/em&gt; 은 도대체 언제 호출이 되냐는 것이다.&lt;/p&gt;

&lt;p&gt;사실 위의 소개한 기능중에 CustomYieldInstruction 이용해 구현한 기능이 있다. &lt;strong&gt;WaitUntil&lt;/strong&gt; 과 &lt;strong&gt;WaitWhile&lt;/strong&gt; 이다.
&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html&quot;&gt;Unity CustomYieldInstruction&lt;/a&gt; 을 보면 Update 가 호출된 후, LateUpdate 를 호출하기 전 즉 타이밍이 적혀있는 그림에서 보았을 떄 GameLogic 레이어에서 체크가 된다는 것을 알 수 있다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/Coroutines.html&quot;&gt;Unity 코루틴 메뉴얼&lt;/a&gt;
&amp;lt;!–&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/system.collections.ienumerator.aspx&quot;&gt;MSDN : IEnumerator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/65zzykke.aspx&quot;&gt;MSDN : 반복기 사용&lt;/a&gt;
–&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Coroutine.html&quot;&gt;Unity Coroutine ref&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html&quot;&gt;Unity CustomYieldInstruction ref&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/YieldInstruction.html&quot;&gt;Unity YieldInstruction ref&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://unityindepth.tistory.com/21&quot;&gt;Unity In Depth 코루틴 글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/WWW.html&quot;&gt;Unity WWW ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
ok  유니티의 기본적인 코루틴 사용법? StopCoroutine:Coroutine
ok  장단점?
ok  구현 클래스 예시 WaitUntil, WaitWhile
~~  CustomYieldInstruction : keepwaiting 을 씀, Update 다 된 이후, LateUpdate 하기 전에 체크함
xx  C# 에서의 코드 블록 지원, 코드에서 사용되는 IEnumerator 의 구조
--&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      
        <category term="c#" />
      

      

      
        <summary type="html">Unity 는 코루틴이라는 괴상한(?) 코딩 방식을 지원한다. 맨 처음에 발견했을 때는 Synchronize 한 코딩 방식에 익숙해져 있어 상당히 낯설고 적응이 안됐다. 하지만 응용 범위를 늘려가다보니 상당히 편한 코딩 방식이라는 것을 깨닳았다. 한번 코루틴에 대해 알아보자.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Custom Property Drawer Tooltip</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/19/custom-property-drawer-tooltip/" rel="alternate" type="text/html" title="Custom Property Drawer Tooltip" />
      <published>2017-04-19T00:00:00+00:00</published>
      <updated>2017-04-19T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/19/custom-property-drawer-tooltip</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/19/custom-property-drawer-tooltip/">&lt;p&gt;CustomPropertyDrawer 를 사용할 때 필드에 설정한 &lt;strong&gt;Tooltip&lt;/strong&gt; 정보가 전달이 안될 때가 있다. 이때는 아래와 같이 하면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;BeginProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// label 대신 content 를 에디터 코드에 넣어줌.
&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;EndProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;OnGUI 를 통해 넘어오는 &lt;strong&gt;label&lt;/strong&gt; 파라미터에는 단지 텍스트만 들어가있어 조금 더 살펴보니 위의 방법처럼 해당 프로퍼티의 &lt;strong&gt;GUIContent&lt;/strong&gt; 를 가져오는 방법이 있었다. 저 반환된 &lt;strong&gt;GUIContent&lt;/strong&gt; 는 어디에서도 사용가능하니 유용하게 쓰일듯하다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      

      

      
        <summary type="html">CustomPropertyDrawer 를 사용할 때 필드에 설정한 Tooltip 정보가 전달이 안될 때가 있다. 이때는 아래와 같이 하면 된다. public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { GUIContent content = EditorGUI.BeginProperty(position, label, property); // label 대신 content 를 에디터 코드에 넣어줌. EditorGUI.EndProperty(); } OnGUI 를 통해 넘어오는 label 파라미터에는 단지 텍스트만 들어가있어 조금 더 살펴보니 위의 방법처럼 해당 프로퍼티의 GUIContent 를 가져오는 방법이 있었다. 저 반환된 GUIContent 는 어디에서도 사용가능하니 유용하게 쓰일듯하다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Usage Of Attributes In Unity</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/12/usage-of-attributes-in-unity/" rel="alternate" type="text/html" title="Usage Of Attributes In Unity" />
      <published>2017-04-12T00:00:00+00:00</published>
      <updated>2017-04-12T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/12/usage-of-attributes-in-unity</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/12/usage-of-attributes-in-unity/">&lt;p&gt;C# 문법은 클래스, 구조체, 열거형, 멤버 변수, 메소드등 여러 타입에 표시를 하는 기능을 제공한다. 이 표시들을 C# 문법에서는 &lt;strong&gt;Attribute&lt;/strong&gt;(속성) 라고 칭한다. 그리고 이 속성을 사용하여 Unity 에서는 많은 기능들을 제공한다. 아래 우리가 가장 많이 볼만한 속성을 사용한 예제가 있다.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2&gt;Property 직렬화 제어&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Unity 시스템에 데이터를 직렬화해 멤버변수 초기값을 지정한다.
&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[UnityEngine.SerializeField]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limitCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 직렬화를 못하게 한다.
&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[System.NonSerialized]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gameCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unity 스크립팅 시스템은 따로 멤버 직렬화에 대한 속성을 지정하지 않으면 접근 제한자(public, protected, private) 에 따라 직렬화를 할지 말지 결정한다. 하지만 접근 제한자로만 사용하기에는 부족한 부분이 있다 그래서 Unity 에서는 멤버 변수 직렬화를 &lt;strong&gt;Attribute&lt;/strong&gt; 문법을 사용해 Unity 전용 속성을 만들어 제어를 할 수 있도록 해두었다.&lt;/p&gt;

&lt;p&gt;클래스 멤버 변수 직렬화를 제어하는 속성은 세개가 있다. &lt;strong&gt;UnityEngine.SerializeField&lt;/strong&gt; 와 &lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt; 와 &lt;strong&gt;System.NonSerialized&lt;/strong&gt; 이 세개다. &lt;strong&gt;UnityEngine.SerializeField&lt;/strong&gt; 는 클래스 멤버 변수의 데이터를 직렬화 해주어 인스턴스가 생성되었을 떄 Unity 시스템에서 직렬화한 데이터로 초기화 시켜주는 속성이고, &lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt; 는 이전에 직렬화된 데이터와의 링크를 끊어 일시적으로 직렬화를 사용한 초기화를 막고 Inspector 에서도 안보이게 해준다. &lt;strong&gt;System.NonSerialized&lt;/strong&gt; 는 해당 멤버 변수의 직렬화를 아예 막는 속성이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;SerializeField&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;HideInInspector&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;NonSerialized&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수 직렬화를 해주는 &lt;strong&gt;Attribute&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;직렬화된 데이터를 숨기는 &lt;strong&gt;Attribute&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수 직렬화를 막는 &lt;strong&gt;Attribute&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 세개의 속성들로 Unity 직렬화 시스템을 제어할 수 있다. &lt;strong&gt;UnityEngine.SerializeField&lt;/strong&gt; 는 직렬화된 데이터가 필요할 때, &lt;strong&gt;System.NonSerialized&lt;/strong&gt; 는 직렬화된 데이터가 전혀 필요 없을 때, &lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt; 는 개발 도중에 잠시 직렬화된 데이터와 연결을 끊을 때 사용한다.&lt;/p&gt;

&lt;p&gt;필자는 확실한 것을 지향하기 때문에 &lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/HideInInspector.html&quot;&gt;&lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt;&lt;/a&gt; 를 잘 사용하진 않는다. 링크를 타고 들어가면 나오지만 정확한 행동의 정의되지 않았다. 단지 숨기기만 하는건지, 직렬화된 데이터를 없에는건지 설명이 명확하게 되어있지 않다. 또한 현재쓰는 Unity 5.5.2 버젼으로 테스트를 해보면 &lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt; 가 붙은 직렬화 데이터가 초기화 되는 경우가 있다.&lt;/p&gt;

&lt;h2&gt;사용자 정의 자료형 직렬화&lt;/h2&gt;

&lt;p&gt;Unity 는 위 예제에서 보다시피 C# 의 기본 자료형과 Unity 에서 지원하는 자료형들의 변수를 Inspector 에서 에디팅할 수 있게 지원한다. 아래 스크립트와 그림을 보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeScript&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someVector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnimationCurve&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someCurve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;SomeScript 가 붙은 GameObject 의 Inspector 창에 아래와 같은 모습이 보일것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_1.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이 Unity 에서는 기본 자료형과 Unity 에서 지원하는 자료형을 Inspector 에서 에디팅하는 것을 지원한다. 하지만 클래스, 구조체 같은 사용자 정의 자료형은 경우가 조금 다르다. 무작정 &lt;strong&gt;SerializeField&lt;/strong&gt; 속성을 붙인다고 되지는 않는다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeDataObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someYRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeScript&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeDataObject&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 코드를 직접 실행시켜보면 알겠지만 이렇게 해봤자 Inspector 에서는 별 변화가 없다. &lt;strong&gt;SomeDataObject&lt;/strong&gt; 같이 &lt;strong&gt;MonoBehaviour&lt;/strong&gt; 를 상속받지 않은 사용자 정의 자료형들은 Inspector 에서 에디팅을 가능하게 하고, 저장을 하려면 클래스에 직렬화(&lt;strong&gt;Serializable&lt;/strong&gt;) 하다는 속성을 붙여주어야 한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;na&quot;&gt;[System.Serializable]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeDataObject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위와 같이 속성 하나만 붙여주면 Inspector 에서 에디팅이 가능하고 직렬화가 되어 자동으로 초기화가 가능해진다. 아래 그림과 같이 보일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_2.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;CustomPropertyDrawer 를 이용하여 변수의 Inspector 바꾸기&lt;/h2&gt;

&lt;h4&gt;클래스를 사용하여 커스터마이징하기&lt;/h4&gt;

&lt;p&gt;보통 클래스나 구조체를 사용해 자료를 저장하는 경우는 꽤 많다. 그리고 데이터가 많아지면 많아질 수록 넣어야할 변수는 많아지고 Inspector 창은 혼란의 도가니에 빠지게 된다. 아래와 같이 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_3.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 예시는 조금 극단적이긴 하지만 변수가 6개씩만 넘어도 한눈에 보기에도 힘들고 편집하는데도 살짝 헷갈린다. 그리고 간단한 시스템이 아니면 대부분 꽤 많은 변수를 가지게 된다. 그래서 Unity 에서는 타입별로 Inpector 에서 보이는 에디팅 환경을 바꾸는 것을 지원한다. 위의 선언한 &lt;strong&gt;SomeDataObject&lt;/strong&gt; 를 이용하여 바꾸어보기로 하자.&lt;/p&gt;

&lt;p&gt;우선 에디터 전용 스크립트를 만들어 주어야 한다. Unity 의 Project 창에서 아무 위치에나 &lt;em&gt;“Editor”&lt;/em&gt; 라는 이름으로 폴더를 만들어주고, 그안에 스크립트를 만들어주자. 아래 그림과 같이 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/editor_code_location.png&quot; alt=&quot;Project-editor&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SomeDataObject&lt;/strong&gt; 를 그리는 에디터이니 &lt;strong&gt;SomeDataObjectDrawer&lt;/strong&gt; 로 이름을 지어주었다. 그리고 그 안의 내용을 아래와 같이 적어주자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEditor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;[CustomPropertyDrawer(typeof(SomeDataObject))]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeDataObjectDrawer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PropertyDrawer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetPropertyHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetPropertyHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 예제는 원래 나오는 방식과 똑같이 구현을 해놓은 예제다. 여기서 주목해야할 점은 두개다. &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 클래스와 &lt;strong&gt;CustomPropertyDrawer&lt;/strong&gt; 속성이다. &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 클래스는 Inspector 내에서 직접 그리는 클래스의 모체로써, Inspector 에서 보이는 변수의 모습을 바꾸려면 이 클래스를 상속받아 구현을 해놓아야 한다. &lt;strong&gt;CustomPropertyDrawer&lt;/strong&gt; 속성은 클래스나 속성 타입을 명시적으로 넣어주어 해당 타입의 변수들이 Inspector 에서 보이는 모습을 바꾸겠다는 속성이다. 위 예제를 보면 &lt;strong&gt;CustomPropertyDrawer&lt;/strong&gt; 속성에는 &lt;strong&gt;SomeDataObject&lt;/strong&gt; 를 넣어주어 &lt;strong&gt;SomeDataObject&lt;/strong&gt; 클래스의 모든 변수들을 &lt;strong&gt;SomeDataObjectDrawer&lt;/strong&gt; 안의 코드를 이용해 보여준다는 의미다. 그리고 &lt;strong&gt;SomeDataObjectDrawer&lt;/strong&gt; 클래스는 &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 를 상속해 &lt;em&gt;GetPropertyHeight&lt;/em&gt; 메소드를 이용하여 높이값을 가져오고, &lt;em&gt;OnGUI&lt;/em&gt; 메소드를 사용하여 실제로 Inspector 창안에서 보이는 것을 구현한다. 위 코드에서는 기본적으로 제공하는 높이와, Unity 에서 사용하는 에디터 구현 코드를 사용해서 기존 에디터와 같은 방식으로 보일 것이다.&lt;/p&gt;

&lt;p&gt;기본적인 구현 방법에 대해 알아보았으니 아래 그림처럼 구현해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_4.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래에 구현 코드가 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 왼쪽에 이름으로 나오는 라벨, 여기서는 변수 이름이 들어감.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PrefixLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherWidth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 각 위치별로 설정해줌.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameRect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;numberRect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rotateRect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherWidth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 각 변수별로 Unity 에서 기본으로 지원하는 형식을 사용함.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 끝에 GUIContent.none 를 안넣어주면 이름이 표시되어 에디터에서 밀리게 나옴.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nameRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;FindPropertyRelative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;someName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;FindPropertyRelative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;someNumber&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rotateRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;FindPropertyRelative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;someYRotation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드는 한 변수당 한줄이였던 방식에서 데이터를 한줄에 넣어주는 코드다. &lt;strong&gt;EditorGUI.PrefixLabel&lt;/strong&gt; 메소드를 통해 앞에 표시되는 이름을 보여주고, 숫자를 넣어주는 부분의 넓이를 확보하고 나머지 넓이를 문자열을 보여주는데 사용한다.&lt;/p&gt;

&lt;p&gt;여기까지 클래스 변수가 Inspector 창에서 보이는 부분을 직접 커스터마이징 하는 방법에 대해서 알아보았다. 이 &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 기능을 이용하여 타입별로 고정하는게 아닌 &lt;strong&gt;Attribute&lt;/strong&gt; 를 이용하여 필요한 부분만 바꾸는 방법도 있다.&lt;/p&gt;

&lt;h4&gt;속성을 사용하여 커스터마이징하기&lt;/h4&gt;

&lt;p&gt;C# 문법은 &lt;strong&gt;Enum&lt;/strong&gt; 을 비트플래그로 사용하는 방법이 있다. 아래와 같이 말이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;na&quot;&gt;[System.Flags]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeEnumFlag&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Some&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Other&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Enum&lt;/strong&gt; 의 정의에다가 &lt;strong&gt;System.Flags&lt;/strong&gt; 를 붙여 사용하면 된다. 그런데 Unity 에서는 이 &lt;strong&gt;Enum&lt;/strong&gt; 을 황용하여 비트마스크를 보여주는 기능을 지원하지 않는다. 단지 한개의 아이템만 선택하는 기능만 지원한다. 그래서 Inspector 에서 비트 플래그를 사용하여 값을 설정하려면 직접 &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 를 사용하여 에디터를 바꿔주어야 한다. 그래서 아래처럼 코드를 짜보았다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;na&quot;&gt;[CustomPropertyDrawer(typeof(SomeEnumFlag))]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeEnumFlagDrawer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PropertyDrawer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;]&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumTypeNameDict&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;]&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;EnumFlagAttribute&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EnumFlagAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumTypeNameDict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;TryGetValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Enum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;enumTypeNameDict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MaskField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;직접 실행시켜보면 알겠지만 저 코드는 잘 동작하지 않는다. 왜냐하면 &lt;strong&gt;CustomPropertyDrawer&lt;/strong&gt; 를 사용해서 바꿀 타입은 클래스들만 가능하기 때문이다. &lt;strong&gt;SomeEnumFlag&lt;/strong&gt; 는 &lt;strong&gt;Enum&lt;/strong&gt; 자료형이기 때문에 저 방식은 통하지 않는다. 이럴 때 &lt;strong&gt;Attribute&lt;/strong&gt; 를 직접 만들어 설정이 가능하다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EnumFlagAttribute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PropertyAttribute&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EnumFlagAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드는 속성을 직접 선언한 코드다. 중요한 점은 Unity 에서 지원하는 &lt;strong&gt;PropertyAttribute&lt;/strong&gt; 를 상속받아서 정의하였다는 점이다. &lt;strong&gt;PropertyAttribute&lt;/strong&gt; 를 사용해야만 Inspector 창에서 보이는 방식을 바꿀 수 있다. 위에서 만들어준 &lt;strong&gt;Enum&lt;/strong&gt; 비트 플래그 에디터 코드에 아래와 같이 연결시켜준다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;na&quot;&gt;[CustomPropertyDrawer(typeof(EnumFlagAttribute))]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeEnumFlagDrawer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PropertyDrawer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그 다음 해당 속성을 변수에 붙여주면 Inspector 에서 아래 그림과 같이 보일것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_5.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클래스 또는 속성별로 변수별 Inspector 에디터를 바꿔보는 &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 설정 방법에 대해서 알아보았다.&lt;/p&gt;

&lt;p&gt;여태까지 설명했던 기능들은 전부 &lt;strong&gt;Attribute&lt;/strong&gt; 를 사용하여 지원한다. 그리고 설명하지 않은 &lt;strong&gt;Attribute&lt;/strong&gt; 문법을 사용하는 기능들도 엄~~청 많다. &lt;strong&gt;Attribute&lt;/strong&gt; 에 대해 이해를 하고 있으면 앞으로의 추가적인 기능들을 사용하는데 많은 도움이 될것이다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/mt653982.aspx&quot;&gt;C# Attribute Usage&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/PropertyDrawer.html&quot;&gt;Unity Custom Attribute&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.naver.com/PostView.nhn?blogId=hammerimpact&amp;amp;logNo=220775187161&amp;amp;redirect=Dlog&amp;amp;widgetTypeCall=true&quot;&gt;PropertyDrawer 번역 네이버 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tallior.com/unity-attributes/&quot;&gt;Set of Unity Attribute&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      

      

      
        <summary type="html">C# 문법은 클래스, 구조체, 열거형, 멤버 변수, 메소드등 여러 타입에 표시를 하는 기능을 제공한다. 이 표시들을 C# 문법에서는 Attribute(속성) 라고 칭한다. 그리고 이 속성을 사용하여 Unity 에서는 많은 기능들을 제공한다. 아래 우리가 가장 많이 볼만한 속성을 사용한 예제가 있다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Using Scriptable Object</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/09/using-scriptable-object/" rel="alternate" type="text/html" title="Using Scriptable Object" />
      <published>2017-04-09T00:00:00+00:00</published>
      <updated>2017-04-09T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/09/using-scriptable-object</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/09/using-scriptable-object/">&lt;p&gt;2년전 Unity 로 모바일 게임 개발을 시작했었다. 학생 시절 간단하게 게임을 만든적은 있었지만 Unity 로 게임을 만들어본 적은 한번도 없었기에 매우 어려운 도전이였다. 그래서 Unity 시스템에 대해 간단히 알고 개발을 시작했었는데 당시에는 ScriptableObject 의 기능을 모르고 있던터라 단순히 Prefab 만으로 데이터를 저장하고 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/subwaysurfer.png&quot; alt=&quot;Subway suffer&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;당시 만든 게임은 3D 러닝 게임이였는데, 서브웨이 서퍼과 비슷한 방식의 게임이였다. 핵심은 어떻게 맵을 계속 나타나게 하느냐 였는데, 나는 단순하게 플레이어의 위치에 따라 맵을 계속 이어붙였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/map_example_0.png&quot; alt=&quot;runtime map&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Map 은 Prefab 단위로 구성되어 있었는데, Map Prefab 에는 플레이어가 지나갈 길의 정보, 3D 메쉬 정보가 있었다. 그리고 맵 종류별로 풀링을 하여 활용했었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/map_example_1.png&quot; alt=&quot;map pooling&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 한가지 아쉬운게 있다면 Map Prefab 별로 모두 길 정보를 가지고 있는게 아쉬웠다. 프리팹은 보이는 정보만 가지고 길 정보는 따로 존재해  참조하는 방식이 조금 더 나았을 것이다. 종류 별로 반복되는 길 정보가 많았기 때문에 더욱 아쉬웠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/map_example_2.png&quot; alt=&quot;map refer to road data&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 길 정보는 따로 존재하고 맵이 길 정보를 참조하는 방식으로 말이다. 하지만 위와 같은 방식을 고안하더라도 실제로 구현할 방법을 몰랐기 때문에 방치했었다. 하지만 지금은 독립적으로 존재하는 데이터 에셋을 만드는 방법을 알고 있다. 그건 바로 ScriptableObject 라는 에셋 타입이다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;정적인 에셋 타입 : ScriptableObject&lt;/h2&gt;

&lt;p&gt;ScriptableObject 는 Inspector 에 존재하는 데이터 에셋의 종류 중 하나다. Prefab 처럼 그 자체를 복사할 수 없고, 단지 독립적으로 존재한다. 그래서 ScriptableObject 를 참조해서 데이터에 접근할 수 있다. 이름처럼 스크립트에서 ScriptableObject 라는 클래스를 상속받아 활용하며 데이터 직렬화를 지원하기 때문에 컴포넌트 스크립팅 처럼 데이터를 저장하여 사용가능하다. 시작할 때 언급한 길 정보를 ScriptableObject 로 직접 만들어 보았다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;[CreateAssetMenu(fileName = &quot;RoadData&quot;, menuName = &quot;Examples/RoadData&quot;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RoadDataOjbect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScriptableObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roadPositionArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roadPositionArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetPositionAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roadPositionArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 구현을 보면 필요한 데이터(위에서는 위치정보)를 저장하기만 한다. 스크립팅 방식은 저장할 데이터를 선언만 해주고, 그 데이터를 관리하는 코드만 짜주면 된다. 컴포넌트 스크립팅과 조금 다른점은 직접 행동하는 개체가 아니기 때문에 실제 게임 로직은 제외해서 코딩을 하게 된다.&lt;/p&gt;

&lt;p&gt;하지만 ScriptableObject 의 의의는 스크립팅 방식이 아니라, 독립적으로 존재하는 것에 의미를 더 부여한다. 정확히 정의하자면 “독립적으로 존재하는 데이터의 집합 에셋” 이라고 할 수 있다. 그래서 독립적으로 존재하기 위해 파일로 직접 만들어주는 코드가 필요하다.&lt;/p&gt;

&lt;p&gt;그 코드가 클래스 선언위의 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/CreateAssetMenuAttribute.html&quot;&gt;CreateAssetMenu&lt;/a&gt; 라는 속성이다. MonoBehaviour 를 활용한 스크립트는 컴포넌트로 취급되기 때문에 GameObject 에 붙이기만 하면 자연스럽게 사용할 수 있다. 하지만 ScriptableObject 는 독립적으로 존재하기 때문에 생성하는 코드를 만들어 주어야 한다. 저 속성을 붙이면 아래 그림처럼 메뉴에 만드는 코드가 추가된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/make_scriptableobject.png&quot; alt=&quot;make scriptableObject&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림처럼 메뉴를 선택하면 아래 그림과 같이 스크립트를 만들때와 동일하게 이름을 설정하고 파일을 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/make_scriptableobject_inspector.png&quot; alt=&quot;make scriptableObject inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 예제에서는 ScriptableObject 를 단순히 데이터 자체만 저장하는 용도로 쓰는 예시를 보여주었다. 단순 데이터 저장 방식으로도 많이 쓰이지만 이를 프로젝트 내의 에셋을 연결시켜주는 용도로도 사용할 수 있다. 아래 그림처럼 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/set_scriptableobject.png&quot; alt=&quot;set of asset or data&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ScriptableObject 에 단순 데이터, 관련된 애셋들을 묶어 관리하면 조금더 효율적으로 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/hrmrzizon/UnityExample&quot;&gt;UnityExample&lt;/a&gt; 에 위에서 나온 예들을 적용시킨 예제가 있으니 살펴보길 바란다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/script-Serialization.html&quot;&gt;Untiy Serialize&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/class-ScriptableObject.html&quot;&gt;Unity ScriptableObject&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.naver.com/PostView.nhn?blogId=hammerimpact&amp;amp;logNo=220770261760&quot;&gt;네이버 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://unity3d.com/kr/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects&quot;&gt;Unity ScriptableObject Guideline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      

      

      
        <summary type="html">2년전 Unity 로 모바일 게임 개발을 시작했었다. 학생 시절 간단하게 게임을 만든적은 있었지만 Unity 로 게임을 만들어본 적은 한번도 없었기에 매우 어려운 도전이였다. 그래서 Unity 시스템에 대해 간단히 알고 개발을 시작했었는데 당시에는 ScriptableObject 의 기능을 모르고 있던터라 단순히 Prefab 만으로 데이터를 저장하고 있었다. 당시 만든 게임은 3D 러닝 게임이였는데, 서브웨이 서퍼과 비슷한 방식의 게임이였다. 핵심은 어떻게 맵을 계속 나타나게 하느냐 였는데, 나는 단순하게 플레이어의 위치에 따라 맵을 계속 이어붙였다. Map 은 Prefab 단위로 구성되어 있었는데, Map Prefab 에는 플레이어가 지나갈 길의 정보, 3D 메쉬 정보가 있었다. 그리고 맵 종류별로 풀링을 하여 활용했었다. 여기서 한가지 아쉬운게 있다면 Map Prefab 별로 모두 길 정보를 가지고 있는게 아쉬웠다. 프리팹은 보이는 정보만 가지고 길 정보는 따로 존재해 참조하는 방식이 조금 더 나았을 것이다. 종류 별로 반복되는 길 정보가 많았기 때문에 더욱 아쉬웠다. 위와 같이 길 정보는 따로 존재하고 맵이 길 정보를 참조하는 방식으로 말이다. 하지만 위와 같은 방식을 고안하더라도 실제로 구현할 방법을 몰랐기 때문에 방치했었다. 하지만 지금은 독립적으로 존재하는 데이터 에셋을 만드는 방법을 알고 있다. 그건 바로 ScriptableObject 라는 에셋 타입이다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Message System</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/07/unity-message-system/" rel="alternate" type="text/html" title="Unity Message System" />
      <published>2017-04-07T00:00:00+00:00</published>
      <updated>2017-04-07T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/07/unity-message-system</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/07/unity-message-system/">&lt;h2&gt;이름으로 메소드를 호출하다. SendMessage&lt;/h2&gt;

&lt;p&gt;Unity 런타임 시스템에서는 Unity 자체의 캐시 시스템을 이용하여 컴포넌트의 메소드를 문자열로 찾아 호출해주는 기능을 가지고 있다. 그중 하나는 &lt;strong&gt;GameObject&lt;/strong&gt; 와 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Component.html&quot;&gt;&lt;strong&gt;Component&lt;/strong&gt;&lt;/a&gt; 클래스에 존재하는 &lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/GameObject.SendMessage.html&quot;&gt;&lt;strong&gt;SendMessage&lt;/strong&gt;&lt;/a&gt; 라는 메소드다. 아래와 같이 사용을 할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnEnable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;SendMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DoSomething&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Do something!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;OnEnable 에서 해당 컴포넌트의 DoSomething 이라는 메소드를 찾아 호출하는 SendMessage 메소드를 호출하고, 아마 DoSomething 메소드가 호출되면서 로그가 출력될 것이다.&lt;/p&gt;

&lt;p&gt;Unity 에서 메세징 방식의 대표적인 사용사례는 컴포넌트 스크립팅을 할 때 항상 볼 수 있는 Start, Update 등 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MonoBehaviour.html&quot;&gt;MonoBehaviour&lt;/a&gt; 의 여러 메시지 콜백들이다. 저 메시지 콜백들을 통해 스크립트 컴포넌트는 여러 상태를 알 수 있다.
&lt;!-- more --&gt;
또한 &lt;strong&gt;AnimationClip&lt;/strong&gt; 을 사용할때 메세지 이벤트를 넣어서 사용할 수 있다. 애니메이션의 특정 프레임에 메시지 이벤트를 만들어 같은 게임오브젝트에 붙어있는 스크립트들에게 메시지를 던져준다. &lt;a href=&quot;https://github.com/hrmrzizon/UnityExample&quot;&gt;UnityExample&lt;/a&gt; 프로젝트의 MessageScene 의 ShakeCube 를 확인하라.&lt;/p&gt;

&lt;h2&gt;메시지 방식의 사실, 장단점&lt;/h2&gt;

&lt;p&gt;지금도 많은 사람들이 SendMessage 는 &lt;strong&gt;“매우 느리다”&lt;/strong&gt; 라는 생각을 하며 사용한다. 하지만 &lt;strong&gt;“매우 느리다”&lt;/strong&gt; 의 근거가 될만한 이유는 C# Reflection 기능을 &lt;strong&gt;“실시간”&lt;/strong&gt; 으로 사용하는 것에 있다. 이를 반박하자면&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GameObject 가 생성될 시에 각 컴포넌트별로 C# 리플렉션 기능을 사용해 메소드들의 위치와 이름을 함께 저장하여 가지고 있는다. 그리고 오브젝트가 파괴될 때까지 이 캐시 데이터를 저장해놓고 쓴다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 문단의 내용이 사실이라면 &lt;strong&gt;“매우 느리다”&lt;/strong&gt; 의 근거는 없다. Unity 시스템에서 사용하는 기능이 그렇게 느릴리는 없다. (&lt;a href=&quot;https://www.slideshare.net/MrDustinLee/ss-27739454&quot;&gt;유니티가 당신에게 알려주지 않는 것들&lt;/a&gt; : 43 ~ 47쪽)&lt;/p&gt;

&lt;p&gt;언제나 장점이 있으면 단점도 있다. 이 메시징 방식은 타입에 상관없이 문자열 하나로 메소드 호출이 가능하다는(Typeless call) 강력한 장점을 가지고 있다. 하지만 단점도 고려하고 사용해야 한다.&lt;/p&gt;

&lt;h4&gt;1. 빈번한 호출은 피한다.&lt;/h4&gt;

&lt;p&gt;문자열 탐색에 대한 비용이 있으니 매 프레임마다 호출해주거나 빈번히 사용이 일어날 때는 사용을 지양해야 한다.&lt;/p&gt;

&lt;h4&gt;2. 생성시에 부하가 발생한다.&lt;/h4&gt;

&lt;p&gt;컴포넌트 성성 타이밍에 C# Reflection 기능을 사용해 메소드 데이터를 생성한다. 이 때 부하가 발생한다. 퍼포먼스가 필요한 게임에서는 &lt;strong&gt;GameObject&lt;/strong&gt; 의 생성은 되도록 피하고, 모든 오브젝트를 가장 처음에 로드 후 재활용해서 사용한다.&lt;/p&gt;

&lt;h4&gt;3. OOP 를 망친다.&lt;/h4&gt;

&lt;p&gt;접근 제한자에 상관없이 호출해주기 때문에 객체 캡슐화에 안좋은 영향을 미친다. OOP(객체지향프로그래밍) 에서는 접근 제한자를 통해 외부에 노출시킬 메소드, 안에서 숨겨야할 메소드를 설정한다. 하지만 Unity 메시징 방식은 접근 제한자를 무시하기 때문에 프로그래머에게 모호한 선택을 요구한다.&lt;/p&gt;

&lt;h4&gt;4. 방치될 가능성?&lt;/h4&gt;

&lt;p&gt;레거시 시스템이 될 가능성이 있다. &lt;a href=&quot;https://bitbucket.org/Unity-Technologies/ui&quot;&gt;UGUI&lt;/a&gt; 가 4.6 버젼에서 추가되면서 Unity 에서는 UnityEngine.Events 라는 기능도 추가되었다. 이 네임스페이스 안에는 UnityEvent 에 대한 구현도 있고, 현재 메시지 방식을 대체할 수 있는 EventSystem 이라는 시스템의 구현도 되어 있다. UGUI 에서는 UnityEngine.Events 안의 기능들을 적극 사용해 구현을 했다.&lt;/p&gt;

&lt;p&gt;이를 통해 알 수 있는 점은 현재 기능에 대한 최적화는 가능성이 있으나, 더 이상의 기능 추가는 기대하기 어렵다. 즉 Animation 컴포넌트와 같이 기능 확장이 멈추어 새로 생기는 시스템과는 점점 멀어질 가능성이 높다.&lt;/p&gt;

&lt;p&gt;메시징 방식을 사용할 때는 위 항목들을 명심하고 사용하길 바란다.&lt;/p&gt;

&lt;h2&gt;그래서 언제 사용하면 되나요?&lt;/h2&gt;

&lt;p&gt;간단하다. 생성 및 초기화 같이 시작과 끝에서 호출되거나 정말 쓸 수 밖에 없는 경우(애니메이션 이벤트) 에 사용한다. 혹은 성능이 필요 없는 UI에 쓰기도 한다. 매 프레임마다 호출되는 곳이 아닌이상 써도 무관한 경우가 많다.&lt;/p&gt;

&lt;p&gt;위와 같은 조건이 갖추어지면 UnityEvent 와 용도가 겹치는 부분이 있다. 둘다 직접 메소드 호출을 하는게 아닌 원격으로 해주는 기능이라 쓰임새가 겹친다. 하지만 둘은 성질 자체가 달라서 용도도 다르게 사용할 수 있다. UnityEvent 는 에디터에서 직접 컴포넌트를 지정해주어야 하고, 런타임에서는 변경이 불가능하기 때문에 고정된 컴포넌트에서만 사용한다. 하지만 그외의 경우 스크립트 내에서 프리팹을 복사할 때는 UnityEvent 를 사용할 수 없다. 결국 C# Delegate 문법을 사용하거나 SendMessage 기능을 사용해야 하는데 이 경우에는 상황에 따라 적절하게 쓰면 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;분류&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Unity Messaging&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C# Delegate&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;속도&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비교적 느림&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비교적 빠름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;코딩&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;한번에 메소드 호출이 가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;직접 메소드를 이어주고 호출해주어야함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;매 프레임마다 호출되거나 자주 호출이 되는 경우에는 C# Delegate 문법을, 성능이 필요없는 부분(생성,파괴)에서 호출할 때는 SendMessage 를 사용하면 된다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/MessagingSystem.html&quot;&gt;Unity 메시지 시스템&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gamedev.stackexchange.com/questions/120327/how-to-send-an-interface-message&quot;&gt;GameDev HowToMessage&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/MrDustinLee/ss-27739454&quot;&gt;유니티가 당신에게 알려주지 않는 것들&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="mono" />
      
        <category term="c#" />
      
        <category term="try" />
      

      

      
        <summary type="html">이름으로 메소드를 호출하다. SendMessage Unity 런타임 시스템에서는 Unity 자체의 캐시 시스템을 이용하여 컴포넌트의 메소드를 문자열로 찾아 호출해주는 기능을 가지고 있다. 그중 하나는 GameObject 와 Component 클래스에 존재하는 SendMessage 라는 메소드다. 아래와 같이 사용을 할 수 있다. void OnEnable() { SendMessage(&quot;DoSomething&quot;); } void DoSomething() { Debug.Log(&quot;Do something!&quot;); } OnEnable 에서 해당 컴포넌트의 DoSomething 이라는 메소드를 찾아 호출하는 SendMessage 메소드를 호출하고, 아마 DoSomething 메소드가 호출되면서 로그가 출력될 것이다. Unity 에서 메세징 방식의 대표적인 사용사례는 컴포넌트 스크립팅을 할 때 항상 볼 수 있는 Start, Update 등 MonoBehaviour 의 여러 메시지 콜백들이다. 저 메시지 콜백들을 통해 스크립트 컴포넌트는 여러 상태를 알 수 있다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Event Handling</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/05/unity-event-handling/" rel="alternate" type="text/html" title="Unity Event Handling" />
      <published>2017-04-05T00:00:00+00:00</published>
      <updated>2017-04-05T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/05/unity-event-handling</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/05/unity-event-handling/">&lt;p&gt;Unity 에서 객체간의 이벤트를 처리하는 방법들을 써본다. c# 에서 지원하는 delegate, event 와 UnityEvent 를 알아볼 것이다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;C# Delegate, Event&lt;/h2&gt;

&lt;h4&gt;행동을 대신하다. Delegate&lt;/h4&gt;

&lt;p&gt;대리자(Delgate) 의 개념이 고안된지는 꽤 많은 시간이 흘렀다. 시작으로 거슬러 올라가면, 가장 사람들이 많이 접한 형태는 Windows API 의 메세지 처리 콜백 함수가 있겠다. 긴말 필요없이 간단한 예제를 살펴보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//
// delegate 를 이용한 간단한 Unity 예제다.  
//
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delegate&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CheckForAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CheckForAwake&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 단순히 함수를 대입한다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LogAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 람다식을 += 를 사용해 onAwake 델리게이트에 추가한다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;CheckForAwake&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Awake!! Twice!!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 람다식을 -= 를 사용해 onAwake 델리게이트에서 지운다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// null 을 넣어 빈 델리게이트를 표현한다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LogAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Awake!!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 예제는 대리자(Delgate)의 사용방법을 보여준다. 대리자(Delgate)는 단순히 대입을 통해 한개의 함수만 넣을 수도 있고, ‘+’, ‘-‘ 연산자들을 통해 여러개의 함수를 가질수도 있다. 다만 같은 인자, 같은 반환형을 가져야 위와 같이 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;위 예제를 살펴보았을 때 대리자(Delgate)는 함수들을 여러개 가질 수도 있고, null 값을 가질수 있는 자료형이라고 칭할 수 있겠다.&lt;/p&gt;

&lt;p&gt;그리고 일일히 타입을 지정하지 않고도 미리 지정된 대리자들을 사용가능하다. (참고 : &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/018hxwa8.aspx&quot;&gt;Action&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/bb549151.aspx&quot;&gt;Func&lt;/a&gt; 등 많은 타입이 있다.)&lt;/p&gt;

&lt;h4&gt;특정 정보를 전달해준다. Event&lt;/h4&gt;

&lt;p&gt;C# 에서 event 키워드는 대리자(Delgate) 선언에 같이 쓸 수 있는 키워드로, 선언된 대리자(Delgate)의 접근을 제한하는 역할을 한다. 근데 “접근을 제한할려면 접근 키워드를 쓰지 왜 event 라는 다른 키워드를 쓰는 것인가?” 라는 생각이 들 수도 있다. 역시 아래 예제를 보면서 설명하겠다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine.Events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine.SceneManagement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//
// 씬 로드 event 를 이용한 예제다.
//
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 대리자 이벤트 변수
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnityAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoadSceneMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 자기 자신의 대리자 이벤트 변수는 어떤 접근도 가능함.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OnSceneLoaded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OnSceneLoaded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러! 외부의 event 변수는 assign 이 안됨.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// SceneManager.sceneLoaded = onLoad;
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// += 접근은 가능함.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;SceneManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sceneLoaded&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러! 외부의 event 변수는 assign 이 안됨.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// SceneManager.sceneLoaded = null;
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// -= 접근은 가능함.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;SceneManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sceneLoaded&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnSceneLoaded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scene&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoadSceneMode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{0}, {1}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 코드는 event 의 접근 제한이 어디에 걸려있는지 알 수 있다. 자기 자신의 이벤트 대리자는 얼마든지 접근이 가능하지만, 외부에서 이벤트 대리자를 접근할 때는 대입 연산자는 불가능하고, 등록(+=) 하거나 취소(-=) 하는 연산자만 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;즉 이벤트 키워드는 인스턴스 외부에서 대리자를 보호하는 역할을 하며, 외부에서 이벤트 키워드가 붙은 대리자 자체를 이벤트를 전달받는 용도로만 쓰도록 한다.&lt;/p&gt;

&lt;h2&gt;Serializable 한 이벤트 : UnityEvent&lt;/h2&gt;

&lt;p&gt;위에서 C# 에서 지원하는 Event, Delegate 문법을 알아보았다. 저 문법들만 잘 활용해도 깔끔하게 스크립팅이 가능하지만, Unity 시스템에서는 조금은 모자란 부분이 있다. 그래서 Unity 에서는 C# 의 Event, Delegate 기능을 따로 구현을 해서 지원한다. 구현을 클래스로 제공하는데 이름은 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html&quot;&gt;UnityEvent&lt;/a&gt; 다.&lt;/p&gt;

&lt;p&gt;스크립트에서 이벤트 사용은 거의 비슷하다. 런타임 내에서는 이벤트를 등록하거나, 제거할 수 있고 Invoke 메소드를 통해 이벤트를 알려주면 된다. 하지만 UnityEvent 는 스크립팅보다는 Hierarchy 시스템 내에서 빛을 발한다. UGUI 의 Button 컴포넌트를 아래 그림이 있다. 한번 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eventhandling-inspector.png&quot; alt=&quot;inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 버튼은 “눌렸을 때, 무언가 동작을 한다.” 라고 생각을 할것이다. 그래서 동작을 이어주는 부분이 &lt;em&gt;OnClick()&lt;/em&gt; 이라고 쓰여있는 부분이다. &lt;em&gt;OnClick()&lt;/em&gt; 에 두개의 블록이 있다. 블록은 아래 +, - 버튼을 통해 없에거나 만들 수 있다. 그리고 각 블록의 역할은 게임 오브젝트의 컴포넌트의 메소드 하나를 연결하는 역할을 한다. 블록은 연결할 메소드의 갯수만큼 늘리고 줄이면 된다.&lt;/p&gt;

&lt;p&gt;설정하는 방법은 간단하다. Hierarchy 내에서 하나의 게임오브젝트를 선택하고, 게임 오브젝트가 가지고 있는 컴포넌트 중의 메소드를 하나 선택한다. 그리고 파라미터가 있으면 간단하게 설정해주면 된다. 아래 그림과 같이 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eventhandling-inspector-select-method.png&quot; alt=&quot;inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 메소드를 등록하면된다. 그런데 UnityEvent 에 등록할 수 있는 메소드의 제한이 있다. 타겟 게임 오브젝트와 자신의 게임 오브젝트의 관계가 고정되어야 하고, static 함수가 아니여야 하며, 무조건 public 으로 접근제한자가 설정되어 있어야 한다. static 함수가 아니여야 하는건 실제 컴포넌트의 메소드를 호출한다는 컨셉인것 같고, 접근제한자가 public 이여야 하는건 스크립트의 유연함을 위해 그런듯 하다.&lt;/p&gt;

&lt;p&gt;그런데 사용하다보면 조금 의문이 드는점이 있다. &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html&quot;&gt;UnityEvent&lt;/a&gt; 에서 정의된 &lt;em&gt;AddListener/RemoveListener&lt;/em&gt; 와 인스펙터에서 설정해준 정보들이 다르게 취급되는 것처럼 보인다.&lt;/p&gt;

&lt;p&gt;사실 UnityEvent 에서는 메소드 등록 정보를 두개로 나누어서 관리한다.&lt;/p&gt;

&lt;p&gt;하나는 인스펙터에서 설정해준 persistant listner(지속성 리스너), 하나는 non-persistant listener(비지속성 리스너) 로 구분을 한다. 인스펙터에서 설정해준 값들은 지속성 리스너로 취급하며 런타임에서는 수정이 불가능하다. Unity 프로젝트안에 저장된(직렬화된) 데이터들이라서 런타임에서는 수정이 불가능 하기 때문이다.(에디터에서는 가능하다)&lt;/p&gt;

&lt;p&gt;그리고 UnityEvent 클래스에 직접 정의된 &lt;em&gt;AddListener/RemoveListener&lt;/em&gt; 은 비지속성 리스너를 취급하는 메소드다. 이들은 런타임에서 등록, 제거가 가능하다. 하지만 지속되지 않는(저장되지 않는) 리스너로 위에서 설명한 C# event, delgate 문법과 같은 기능을 한다.&lt;/p&gt;

&lt;p&gt;파라미터 설정도 사용자 마음대로 설정할수 있다. 자세한 설정 방법은 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Events.UnityEvent_1.html&quot;&gt;UnityEvent&lt;/a&gt; 를 참조하면 된다.&lt;/p&gt;

&lt;h2&gt;실제 사용 사례 및 장단점&lt;/h2&gt;

&lt;p&gt;C# Delegate 문법은 정말 무궁무진하게 쓰인다. 특히 일시적인 루틴이 아닌 비동기 처리가 필요할 때 유용하게 쓸 수 있다. 아래 예시를 보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetObjectCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 무조건 한번에 값을 반환해주어야 함.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetObjectCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 실행시에 대리자를 호출할 수도 있고, 일정 시간이 흐른뒤에 대리자를 호출할 수도 있다.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Action 은 C# 라이브러리에서 미리 정해놓은 대리자 형식이다.(&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/018hxwa8.aspx&quot;&gt;Action 링크&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;가장 흔하게 대리자를 볼 수 있는 소스는 로그인 플랫폼 API 에 가장 많이 붙어있다. 대부분 네트워크 통신을 하기 때문에 당연히 비동기 처리에 대한 답이 필요하고, 가장 편한 수단으로 대리자를 뽑은 것이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Login&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Login&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;getGoogle&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getGoogle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;WWW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;googleConnection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WWW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://www.google.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;googleConnection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;getGoogle&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loginSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;IsNullOrEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;googleConnection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 Login 메소드가 대표적인 예시다.&lt;/p&gt;

&lt;p&gt;UnityEvent 빨리 게임 로직을 작업해야 할때나, UI 로직을 구성할 때 가장 많이 쓰인다. UGUI 의 많은 위젯들도 UnityEvent 를 사용하고 심지어 UI 전용 이벤트를 처리해주는 EventTrigger 라는 컴포넌트도 있을 정도로 UnityEvent 를 많이 활용한다.&lt;/p&gt;

&lt;p&gt;게임 로직도 UnityEvent 로 구성하면 만들때는 쉽지만 UnityEvent 는 가독성이 상당히 안좋기 때문에 복잡한 게임 로직을 구성하면 나중에는 손댈수 없는 스파게티 코드도 아닌 덩어리가 만들어질 것이다. 하지만 간단한 게임 로직이나, 프로토타이핑에는 매우 적합하다. 그리고 개인적으로 제일 좋은 것은 이벤트를 연결하는 코드를 관리하지 않아서 좋다.&lt;/p&gt;

&lt;p&gt;런타임 퍼포먼스에 대해에서는 이 글을 참고하라 : &lt;a href=&quot;http://jacksondunstan.com/articles/3335&quot;&gt;Event Performance: C# vs UnityEvent(영문)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위에서 말한 내용을 예제에서 확인하면 편리할 것이다. 아래 Github 링크를 올려놓았으니 확인해보길 바란다.&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://github.com/hrmrzizon/Extended-Roll-a-Ball&quot;&gt;Extended-Roll-a-Ball&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/ms173176.aspx&quot;&gt;MSDN 방법: 대리자 선언, 인스턴스화 및 사용&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/ms173172.aspx&quot;&gt;MSDN C# Delegate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/awbftdfh.aspx&quot;&gt;MSDN C# Event&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jacksondunstan.com/articles/3335&quot;&gt;Event Performance&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/UnityEvents.html&quot;&gt;UnityEvent Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="c#" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">Unity 에서 객체간의 이벤트를 처리하는 방법들을 써본다. c# 에서 지원하는 delegate, event 와 UnityEvent 를 알아볼 것이다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Project Directory Structue</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/02/unity-project-directory-structue/" rel="alternate" type="text/html" title="Unity Project Directory Structue" />
      <published>2017-04-02T00:00:00+00:00</published>
      <updated>2017-04-02T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/02/unity-project-directory-structue</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/02/unity-project-directory-structue/">&lt;p&gt;Unity 프로젝트는 여러 종류의 데이터를 디렉토리로 판단해 컴파일 한다. 반대로 이 디렉토리 구조를 통해 Unity 의 컴파일 시스템을 알아볼 수도 있다. 디렉토리 구조 자체는 간단하나 숨겨진 뜻은 조금 복잡하다. 그러니 한번 알아보기로 하자.&lt;/p&gt;

&lt;p&gt;* 이글은  &lt;em&gt;Unity Personal 5.5.2f&lt;/em&gt; 기준으로 쓰여져 있습니다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;Unity 프로젝트 구조&lt;/h2&gt;

&lt;p&gt;일반적인 Unity 프로젝트 디렉토리 구조는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;em&gt;Assets&lt;/em&gt;&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;library&lt;/em&gt;&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;ProjectSetting&lt;/em&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Assets 디렉토리는 스크립트, 리소스, 플러그인 등 프로젝트에서 쓰이는 대부분의 데이터를 모아놓은 디렉토리다. 개발은 거의 Assets 폴더안에서 이루어진다. 또한 이 디렉토리 안에서도 여러 종류의 특별한 디렉토리 이름이 있다.&lt;/p&gt;

&lt;p&gt;ProjectSetting 디렉토리는 프로젝트의 여러 옵션들을 관리하는 파일을 가지고 있다. 안을 들여다보면 &lt;em&gt;Edit -&amp;gt; Project Settings&lt;/em&gt; 에서 볼 수 있는 이름들과 같은 파일들이 있다.&lt;/p&gt;

&lt;p&gt;Library 디렉토리는 위에서 말한 Assets 디렉토리와 ProjectSetting 디렉토리의 모든 데이터를 Unity 가 바로 가져다 쓸 수 있도록 Unity 만의 데이터로 변형한 결과물이다. Unity 에서는 이 결과물들로 대부분의 컴파일을 처리한다.&lt;/p&gt;

&lt;p&gt;이 디렉토리의 데이터는 실제 데이터가 아닌 메타 데이터다. 즉 프로젝트에서 당장 없어도 되는 파일이다. 파일을 옮길 때 디스크 크기를 신경써야 한다면 이 디렉토리는 지워도 된다. 그리고 VCS 에 프로젝트를 등록할 때는 Libary 디렉토리는 올리면 안된다. 혼자서 쓸때는 상관없지만 여러명이서 사용할 때는 Asset, ProjectSetting 디렉토리의 데이터와 Library 의 데이터가 달라질 수 있다. 만약 다르다면 실행 시에 오류가 나거나, 다시 컴파일할 수도 있다.&lt;/p&gt;

&lt;h2&gt;Assets 안의 특별한 이름들&lt;/h2&gt;

&lt;p&gt;위에서도 언급했지만 Assets 디렉토리는 게임의 실질적인 데이터들이 들어가 있는 디렉토리다. 그래서 Unity 에서는 에셋들을 관리하기 위해 Assets 디렉토리 안에서도 데이터를 구분하도록 몇개의 디렉토리 이름을 예약해 놓았다. 예약된 이름들은 무조건 정해진 동작을 하니 정해진 동작과 같은 목적이 아니라면 디렉토리 이름을 다르게 설정해주어야 한다.&lt;/p&gt;

&lt;h4&gt;“Standard Assets”&lt;/h4&gt;

&lt;p&gt;Unity 의 예제 프로젝트들을 실행하면 대부분의 프로젝트들은 Standard Assets 디렉토리가 존재한다. 예제마다 항상 보이는 이 디렉토리는 일반적인 에셋과 다른 분류를 위해 만들어진 이름이다. &lt;a href=&quot;https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html&quot;&gt;Unity Compile Order&lt;/a&gt; 를 보면 알겠지만 맨 처음 컴파일이 되는 디렉토리는 Standard Assets 다.&lt;/p&gt;

&lt;p&gt;그래서 먼저 컴파일이 되면 사용자 입장에서는 무엇이 중요한 것인가? 중요한 한가지만 뽑자면, Assets 폴더안의 다른 언어로 쓰여진 스크립트에서 Standard Assets 스크립트를 참조할 수 있다. 이 말은, C# 으로 유니티 프로젝트를 개발하는 사람이 js 로 쓰여진 스크립트를 변환없이 사용이 가능하단 소리다.&lt;/p&gt;

&lt;h4&gt;“Streaming Assets”&lt;/h4&gt;

&lt;p&gt;Unity 에서 사용되는 모든 파일들은 변환을 거치거나, 메타 파일을 생성해 Unity 시스템에서 접근을 용이하게 한다. 하지만 몇몇의 경우 Unity 에서 변환을 하면 안되는 경우가 몇몇 있다. Unity 문서에서, iOS 에서는 영상을 재생하려면 원본 파일이 필요하다는 예시가 있었다.&lt;/p&gt;

&lt;p&gt;그래서 필요한 디렉토리가 Streaming Assets 다. 이름 자체도 스트리밍을 염두해두고 만든 듯 싶다. 이 디렉토리의 파일을 접근하는 방법은 언어에서 제공하는 API를 사용하거나, &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/WWW.html&quot;&gt;WWW&lt;/a&gt; 를 통해 접근할 수도 있다. 플랫폼 별로 경로가 다르니 유의하길 바란다.&lt;/p&gt;

&lt;h4&gt;“Resources”&lt;/h4&gt;

&lt;p&gt;Unity 에서는 빌드를 컴파일 할때, 각 씬의 게임오브젝트 마다 연결된 에셋(&lt;em&gt;Assets 안의 데이터를 칭한다.&lt;/em&gt;)들을 찾아서 컴파일 한다. 그리고 런타임에서 Hierarchy 안에 게임 오브젝트가 만들어졌을 때, 게임 오브젝트에 연결된 에셋들을 로드한다.(중복되면 한번만 로드한다.)&lt;/p&gt;

&lt;p&gt;그런데 로드하는 과정에서 약간의 문제가 생길 소지가 있다. 크기가 아주 큰 에셋을 로드하면 많은 메모리 공간을 차지해 문제가 생길 우려가 있다.(튕긴다거나..) 특히 메모리가 부족한 모바일 플랫폼에서는 신경써서 관리를 해주어야 한다.&lt;/p&gt;

&lt;p&gt;그래서 원본 에셋을 동적으로 로드하고, 해제하는 기능을 제공한다. 그 기능을 사용하게 해주는 디렉토리가 Resources 다. 이 디렉토리 안의 데이터들은 런타임에서 경로를 입력해 로드, 언로드가 가능하다.&lt;/p&gt;

&lt;h4&gt;“Editor”&lt;/h4&gt;

&lt;p&gt;Unity 에서는 Unity 에디터 안에서 일정한 범위의 에디터 커스터마이징을 제공한다. 그런 에디터에서 쓰이는 코드들 또한 Assets 안에 존재한다. 그리고 그 코드들을 모아놓는 디렉토리가 Editor 디렉토리다. 또한 이 폴더안에 모두 분류하는 직접적인 이유가 있다.&lt;/p&gt;

&lt;p&gt;Unity 는 런타임 내에서는 에디터 코드와 전혀 상관없이 돌아가게 모듈화를 강제한다. 빌드를 컴파일하게 되면, Editor 디렉토리는 모두 제외하고 컴파일을 한다. 또한 Unity 에서 에디터 바이너리를 제공하는 UnityEditor.dll 또한 빌드에 포함되지 않는다. 런타임 코드에서 UnityEngine 네임스페이스를 참조하고 컴파일하면 직접 에러를 볼 수 있을것이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html&quot;&gt;Unity Compile Order&lt;/a&gt; 에서도 Editor 컴파일은 가장 나중에 한다. 에디터 컴파일과 빌드 컴파일을 쉽게 분리하기 위해 이렇게 순서를 정한듯 하다.&lt;/p&gt;

&lt;h4&gt;“Plugins”&lt;/h4&gt;

&lt;p&gt;Unity 는 Android, PC, macOS 등 왠만한 플랫폼을 지원하는 크로스 플랫폼 게임 엔진이다. 하지만 엔진에서는 자체적으로 지원하는 기능들만 크로스 플랫폼을 지원하고, Third-party 라이브러리는 지원할 수가 없다. 그래서 Unity 에서는 플랫폼 별로 Plugins 디렉토리에 넣을 수 있는 기능을 제공한다. 또한 정적, 동적 라이브러리 들을 포함하는 용도로도 쓰인다. 자세한 사항은 &lt;a href=&quot;https://docs.unity3d.com/Manual/PluginInspector.html&quot;&gt;Unity Plugins&lt;/a&gt; 를 참조하라.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/SpecialFolders.html&quot;&gt;Unity Special Folder&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html&quot;&gt;Unity Compile Order&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://yongil.net/unity/2015/04/23/Unity-Special-Folder-Names-in-your-Assets-Folder.html&quot;&gt;용일이의 개발,번역 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/PluginInspector.html&quot;&gt;Unity Plugins&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      

      

      
        <summary type="html">Unity 프로젝트는 여러 종류의 데이터를 디렉토리로 판단해 컴파일 한다. 반대로 이 디렉토리 구조를 통해 Unity 의 컴파일 시스템을 알아볼 수도 있다. 디렉토리 구조 자체는 간단하나 숨겨진 뜻은 조금 복잡하다. 그러니 한번 알아보기로 하자. * 이글은 Unity Personal 5.5.2f 기준으로 쓰여져 있습니다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Csharp Class Method Extension</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/13/csharp-class-method-extension/" rel="alternate" type="text/html" title="Csharp Class Method Extension" />
      <published>2017-03-13T00:00:00+00:00</published>
      <updated>2017-03-13T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/13/csharp-class-method-extension</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/13/csharp-class-method-extension/">&lt;p&gt;unirx 를 살펴보다 모르는 문법이 나와서 기록해둔다. &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/bb383977.aspx&quot;&gt;MSDN 확장 메서드 문서&lt;/a&gt; 를 참고했다.&lt;/p&gt;

&lt;h2&gt;C# 클래스 확장 메서드&lt;/h2&gt;

&lt;p&gt;C# 3.0 문법부터 사용자가 기존에 정의된 클래스에 메소드를 확장 가능하게 되었다. obj-c 의 카테고리와 조금 비슷한것 같다. 자세한 사항은 코드와 함께 보자.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Linq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CustomExtensions&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Extension methods must be defined in a static class
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringExtension&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// This is the extension method.
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// The first parameter takes the &quot;this&quot; modifier
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// and specifies the type for which the method is defined.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WordCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'?'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringSplitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RemoveEmptyEntries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;선언 방식은 위와 같다. 반드시 static class 에 static method 로 선언해주어야 하며, 첫번째 파라미터는 확장할 타겟 클래스의 인스턴스와 함께 앞에 this 키워드를 사용해주면 된다. 필요한 파라미터가 있다면 그 뒤에다 쭉 써주면 된다. 다만 외부에서 호출해주는 것이기 때문에 한정자의 제한을 받는다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Extension_Methods_Simple&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Import the extension method namespace.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CustomExtensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Program&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;The quick brown fox jumped over the lazy dog.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//  Call the method as if it were an
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//  instance method on the type. Note that the first
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//  parameter is not specified by the calling code.
&lt;/span&gt;            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WordCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Word count of s is {0}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;사용 방법은 간단하다. 구현한 네임스페이스를 임포트 해주고, 확장한 메서드를 (인스턴스).(메서드) 형식으로 호출해주면 된다. 첫번째 타겟 클래스 인스턴스는 생략하고 파라미터를 넣어주면 된다. 다만 자기 자신의 함수를 호출해줄 때도 this 를 활용해 (인스턴스).(메서드) 형식으로 호출해주어야 한다.&lt;/p&gt;

&lt;h2&gt;주의점&lt;/h2&gt;

&lt;p&gt;이 기능은 참 편하다. 쉽게 클래스의 기능을 확장하기 때문이다. 근데 잘못 남용하다가는 아주 개판이 날 가능성이 높다. MSDN 에서는 반드시 필요한 곳에서만 사용하라고 권장하고 있다. 그리고 내 생각도 별반 다를바 없다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="c#" />
      

      

      
        <summary type="html">unirx 를 살펴보다 모르는 문법이 나와서 기록해둔다. MSDN 확장 메서드 문서 를 참고했다. C# 클래스 확장 메서드 C# 3.0 문법부터 사용자가 기존에 정의된 클래스에 메소드를 확장 가능하게 되었다. obj-c 의 카테고리와 조금 비슷한것 같다. 자세한 사항은 코드와 함께 보자.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 2 Erricsson Texture Compression</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression/" rel="alternate" type="text/html" title="Unity Texture Compression 2 Erricsson Texture Compression" />
      <published>2017-03-12T00:00:00+00:00</published>
      <updated>2017-03-12T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression/">&lt;p&gt;모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(&lt;a href=&quot;http://www.jacobstrom.com/output.html&quot;&gt;http://www.jacobstrom.com/output.html&lt;/a&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. ETC(Erricsson Texture Compression)&lt;/h2&gt;

&lt;p&gt;처음 알아볼 압축 방식은 ETC(Erricsson Texture Comperssion) 이다. Jacob Ström&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, Tomas Akenine-Möller 두 사람이 학부 실저에 고안해낸 PACKMAN(2004) 을 더 발전시켜 iPACKMAN(2005) 이라는 학명으로 SIGGRAPH 라는 유명한 컨퍼런스에 등장했다. 이 후 iPACKMAN 의 공식 명칭이 Errcisson Texture Compression(ETC1) 으로 되어 쓰이게 된다. ETC 를 알아보기 전, 먼저 고안된 PACKMAN 을 알아보기로 하자.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h4&gt;(1) PACKMAN?&lt;/h4&gt;

&lt;p&gt;PACKMAN 은 블록 방식의 텍스쳐 압축 기법으로, 직사각형 픽셀 그룹을 만들어 압축한다. RGB 채널이 각각 8bit인 픽셀 8개를(2*4=8) 총 32bit로 압축시킨다. 압축을 안할 시 192bit 이니 1/6 의 공간을 차지하게 압축한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc1_12bit_general_color.png&quot; alt=&quot;12bit_general_color&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;+&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc1_per-pixel_luminance.png&quot; alt=&quot;per-pixel_luminance&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;+&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc1_packman-compressed.png&quot; alt=&quot;packman-compressed&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12bit general color&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;per-pixel_luminance&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;packman-compressed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;PACKMAN 의 정보는 블록에서 평균색(첫번째 그림:general color)과 색 편차가 들어가 있는 테이블의 인덱스를 픽셀별로 기록해(두번째 그림:per-pixel luminance) 평균 색 + 색 편차로 각 픽셀의 색을 결정해 텍스쳐를 구성한다.(세번째 그림:packman-compressed)&lt;/p&gt;

&lt;p&gt;평균색은 말 그대로 픽셀들간의 평균 색이고, 색 편차는 픽셀별로 다른 색들을 평균 색과 비교해서 가장 가까운 편차를 선정한다. 위 문단에서 테이블의 인덱스를 기록한다고 했는데 더 자세하게 알아보기 위해 테이블을 가져왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/etc1_luminance_table.png&quot; alt=&quot;luminancetable&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 표는 자주 사용될만한 색 편차들을 정해놓은 표다. 원래는 4개의 숫자가 한개의 세트로 16세트로 구성되어 있으나, 위 표에는 앞의 8개만 나와있다.&lt;/p&gt;

&lt;p&gt;색 편차 데이터가 구성되는 방식은 8개의 픽셀들간에 가장 오차가 적을만한 table codeword 를 선정한 후 4개의 데이터 중 하나를 골라 인덱스를 저장한다. 색편차를 저장하는 데이터의 종류는 table codeword 와 그 세트안의 인덱스 정보 두개다. 또한 픽셀 인덱스는 픽셀별로 필요하기 때문에 8개가 필요하다.&lt;/p&gt;

&lt;p&gt;색 편차 데이터의 구성 방식을 알아보았으니 전체 색 구성 방식을 알아보자. 필요한 정보와 데이터의 크기는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;픽셀간의 평균색 : RGB444(12bit)&lt;/li&gt;
    &lt;li&gt;테이블 코드워드 : 0~15(4bit)&lt;/li&gt;
    &lt;li&gt;픽셀별 인덱스 : 0~3(2bit)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;평균색은 RGB444 방식으로 12bit로 표현되며, table codeword 는 총 16개가 있으니 4bit 가 필요하다, 그리고 픽셀별 인덱스는 4가지의 숫자만 표현하면 되니 2bit 면 충분하다. 그래서 8개의 픽셀색을 표현하는데 필요한 비트는 12+4+2*8= 32bit 가 필요하다.&lt;/p&gt;

&lt;h4&gt;(2) iPACKMAN?&lt;/h4&gt;

&lt;p&gt;PACKMAN 압축 방식은 문제가 있었다. PACKMAN 방식으로 압축된 이미지와 각 픽셀당 RGB444 로 압축된 이미지를 비교했을 때 휘도(luminance)만 보면 더 좋은 결과를 보여주었지만 색차(chrominance) 면에서 보면 더 안좋은 결과를 보였다. 특히 그라데이션 같이 색이 천천히 바뀌는 이미지에서 색차 밴딩(chrominance banding)이 심했다고 한다. RGB444 방식을 사용해서 작은 차이를 표현하기 어렵고, 한 블록(8개의 픽셀)당 한개의 RGB444 색만 사용하기 때문이다.&lt;/p&gt;

&lt;p&gt;그래서 iPACKMAN 에서는 색차 밴딩을 해결하기 위해 PACKMAN 의 방식에서 변형된 모드를 하나 추가했다. 그 모드 때문에 꽤 많은 부분이 바뀌었다. 모드를 제외한 변경사항은 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;table codeword 가 3bit 로 줄었다.&lt;/li&gt;
    &lt;li&gt;블록의 개념이 2&lt;em&gt;4 픽셀 그룹 하나에서 2&lt;/em&gt;4 픽셀 그룹 두개를 합친 4*4 픽셀 그룹으로 확장됬다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위에서 색차 밴딩이 심하다고 언급했다. 그리고 원인은 RGB444 에 있다고도 말했다. 그래서 데이터의 정밀도를 높이기 위해, 두 2*4 픽셀 그룹의 공간을 합쳐 기존에 독립적으로 2개의 RGB444 색상이 구성되던 방식과 달리 약간의 변화를 주어 RGB555+dRGB333 으로 데이터를 구성하는 방식을 고안해냈다.&lt;/p&gt;

&lt;p&gt;RGB444의 한계를 느끼고 RGB555 로 평균 색을 확장해서 색차의 범위를 확인했다. 20개의 서로 다른 이미지들의 색 편차(deviation)의 통계 데이터를 확인해보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc1_histogram_difference_average_color.png&quot; alt=&quot;histogram_difference&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RGB555로 양자화된 평균 색상의 편차 그래프&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;데이터를 보면 대부분 가운데에 몰려있다. 그래서 88%의 데이터를 포함가능한 -4 ~ 3 간격을 타겟으로 RGB555 를 사용후, RGB333 을 편차값으로 사용해 두 블록을 사용하는 방법을 사용했다.&lt;/p&gt;

&lt;p&gt;table codeword 가 3bit 로 줄은 이유는 이미지를 표현할 공간을 만들어야 했기 때문에 다른 것들을 살피다가 table codeword 를 줄인것으로 예측된다. table codeword 는 고정된 색상 편차 테이블의 인덱스인데, 20개의 이미지 테스트에서 3bit 로 줄이는 테스트를 해 보았을 때, 놀랍게도 평균 0.2db 차이가 안나 바꾸었다고 한다.&lt;/p&gt;

&lt;p&gt;table codeword 의 사이즈를 1bit 씩 줄여 2*4 픽셀 그룹이 2개니 2bit 여유 공간이 남았다. 이 공간들은 데이터의 구성을 표현하는 데이터가 된다. 1bit 는 새롭게 추가된 difference mode 냐, normal mode 냐를 표현하는 비트 플래그로, 1bit 는 수직으로 데이터가 구성되는지, 수평으로 데이터가 구성되는지에 대한 비트 플래그로 표현했다.&lt;/p&gt;

&lt;p&gt;직관적으로 데이터 구성을 이해하기 위해 논문에 있던 이미지를 첨부하겠다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://hrmrzizon.github.io/images/etc1_table_diff_vs_normal.png&quot; alt=&quot;histogram_difference&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;데이터 구성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4&gt;(3) 특징&lt;/h4&gt;

&lt;p&gt;ETC 의 특징은 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;모바일 디바이스를 기준으로 한 손실 압축 기법이다.&lt;/li&gt;
    &lt;li&gt;투명하지 않은(Non-Alpha) 텍스쳐(RGB24)를 지원한다. &lt;/li&gt;
    &lt;li&gt;OpenGL ES 2.0 이상 부터 표준 포맷이 되었으며, 안드로이드 프로요(2.2) 부터 공식 지원하기 시작했다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;ETC 는 기본적으로 모바일 디바이스를 타겟으로 만들어진 텍스쳐 압축 알고리즘이다. 그렇기에 구현 방식 또한 상당히 간단하고 명료하다. 보통 ETC 는 OpenGL ES 3.0 아래 버젼을 지원하는 GPU 를 탑재한 디바이스를 지원할 때 주로 사용되는 방식이다. 또한 알파를 설정할 수 없어 상당히 불편한 경우가 많다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;이 사람은 추후 ETC2 연구에도 참여하였다.&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(http://www.jacobstrom.com/output.html) 2. ETC(Erricsson Texture Compression) 처음 알아볼 압축 방식은 ETC(Erricsson Texture Comperssion) 이다. Jacob Ström1, Tomas Akenine-Möller 두 사람이 학부 실저에 고안해낸 PACKMAN(2004) 을 더 발전시켜 iPACKMAN(2005) 이라는 학명으로 SIGGRAPH 라는 유명한 컨퍼런스에 등장했다. 이 후 iPACKMAN 의 공식 명칭이 Errcisson Texture Compression(ETC1) 으로 되어 쓰이게 된다. ETC 를 알아보기 전, 먼저 고안된 PACKMAN 을 알아보기로 하자. 이 사람은 추후 ETC2 연구에도 참여하였다.&amp;nbsp;&amp;#8617;</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 1 Start</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start/" rel="alternate" type="text/html" title="Unity Texture Compression 1 Start" />
      <published>2017-03-11T00:00:00+00:00</published>
      <updated>2017-03-11T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start/">&lt;p&gt;Unity 로 게임을 개발하던 도중 텍스쳐 압축에 호기심이 생겨 공부하기 + 호기심을 풀기 위해 텍스쳐 압축에 대해 알아보기로 하였다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;1. 텍스쳐 압축(Texture Compression)이란?&lt;/h2&gt;

&lt;h4&gt;1) 뜻&lt;/h4&gt;

&lt;p&gt;일반적으로 압축(Compression) 이란 원본 데이터를 조금 없에거나, 보존해서 파일의 크기를 줄이는 방법을 칭한다. 대표적인 예로 우리가 큰 파일을 전송할 때 압축을 해서 전송하는 경우가 있겠다.(zip, 7z) 이러한 파일 압축 기법들은 모든 데이터를 보존해야 하기 때문에 비손실 압축으로 되어 있다. 하지만 미디어 파일(오디오, 영상, 이미지) 들은 모든 데이터를 저장하지 않고 사람이 인식할 정도만 데이터를 저장하는 비손실 압축 기법이 대부분을 차지한다. (mp3, mp4, jpg) 비 손실 압축방법 중 잘 알려진 포맷은 PNG 포맷이 있다. JPEG, PNG 방식들은 통칭 이미지 압축(Image Compression) 이라 부른다. 하지만 텍스쳐 압축과 이미지 압축의 의미는 조금 다르다.&lt;/p&gt;

&lt;p&gt;텍스쳐 압축(Texture Compression) 위키피디아를 참조해보면 &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Texture compression is a specialized form of designed for storing in rendering systems. Unlike conventional image compression algorithms, texture compression algorithms are optimized for random access.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;문장들을 해석해보면 “텍스쳐 압축은 3D 컴퓨터 그래픽스 렌더링 시스템에서 텍스쳐 맵들을 저장하기위해 고안된 특별한 방식의 이미지 압축이다. 텍스쳐 압축 알고리즘은 전통적인 이미지 압축 알고리즘과 다르게 무작위 접근에 최적화 되어있다.” 라고 한다.&lt;/p&gt;

&lt;p&gt;텍스쳐 압축 알고리즘 자체는 이미지 압축 알고리즘이라 할 수 있다. 하지만 텍스쳐 압축 알고리즘이 이미지 압축과 다른 점은 3D 렌더링 시스템에서 빠르게 접근하기 위해 이미지의 픽셀별로 빠르게 접근이 가능하다는 것이다. 빠르게 접근 한다는 뜻은, &lt;strong&gt;압축된 텍스쳐 데이터 그대로에서 픽셀별로 데이터를 가져올 수 있어야 한다는 뜻이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;대부분의 미디어 압축 포맷에 응용되어 상당히 많이 쓰이는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%9F%B0_%EB%A0%9D%EC%8A%A4_%EB%B6%80%ED%98%B8%ED%99%94&quot;&gt;Run-Length Encoding&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%97%88%ED%94%84%EB%A7%8C_%EB%B6%80%ED%98%B8%ED%99%94&quot;&gt;Huffman Encoding&lt;/a&gt; 방식들은 Encode 된 상태에서 원하는 픽셀의 정보만 가져올려면 모든 데이터를 Decoding 한 후에 가져와야 한다.  즉 저 방식들이 들어간 압축 방식들은 빠른 무작위 접근이 힘들기 때문에 텍스쳐 압축 알고리즘에 응용될 수 없다.&lt;/p&gt;

&lt;h4&gt;2) 쓰임새 &lt;/h4&gt;

&lt;p&gt;실제로 텍스쳐 압축을 사용하려면 요구조건이 몇가지 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;그래픽 시스템(OpenGL, DirectX)에서 텍스쳐 압축을 지원해야 한다.&lt;/li&gt;
    &lt;li&gt;해당 컴퓨터의 GPU 에서 텍스쳐 압축을 지원해야 한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;자주 사용되는 텍스쳐 압축 방식은 그래픽 시스템에서 지원한다. 그래픽 시스템에 대한 걱정은 안해도 된다. 하지만 GPU 에서 지원하는 텍스쳐 압축 방식들은 알아야 한다. GPU 에서 지원하는 압축 포맷의 경우 압축된 데이터를 알아서 디코딩하지만, 지원 안하는 포맷의 경우 SW 디코딩을 하거나, 다른 포맷으로 바꿔주어야 한다.&lt;/p&gt;

&lt;p&gt;스마트폰을 예로 들면, 모바일 플랫폼은 GPU 의 종류가 4가지가 넘고, GPU 별, GPU 제조사 별로 지원하는 텍스쳐 압축 방식이 다 다르다.&lt;/p&gt;

&lt;p&gt;대표적으로 Apple 의 모바일 기기에서 쓰이는 Apple A~ 칩셋들은 모두 PowerVR GPU를 탑재했고, PowerVR GPU 는 PVRTC(PowerVR Texture Compression) 만 지원한다. Apple 제품군에서는 PVRTC 만 쓰면 된다.&lt;/p&gt;

&lt;p&gt;이에 반해 다양한 Android 기기들은 다양한 GPU 를 탑재해서 (QualComn Adreno, ARM Mali 등..) 더욱더 다양한 종류의 텍스쳐 압축 기법이 존재한다. Android 기반의 디바이스들은 거의 다 ETC1 을 지원하기 때문에 대표적으로 사용이 가능하긴 하다. 하지만 몇몇 기기가 PowerVR GPU 를 탑재하기 때문에&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; ETC1 만 사용할 수는 없다.&lt;/p&gt;

&lt;p&gt;즉 하나의 모바일 어플리케이션에서 모든 방식을 선택하기는 힘들다. 모든 방식을 지원하려면 다양한 방식의 리소스가 필요한데, 그러면 응용 프로그램의 용량이 엄청나게 될 것이다. 그래서 몇 가지 디바이스를 포기하거나, Unity 에서는 &lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/AssetBundlesIntro.html&quot;&gt;AssetBundle&lt;/a&gt;의 힘을 빌려 &lt;a href=&quot;http://dragonjoon.blogspot.kr/2015/08/blog-post.html&quot;&gt;&lt;strong&gt;이런 방법&lt;/strong&gt;&lt;/a&gt;을 쓸 수도있다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;대표적으로 삼성 Exynos 3110, 5410 이 있다. 쓰인 기기는 갤럭시 S, 갤럭시 탭 7.0, 갤럭시 S4&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">Unity 로 게임을 개발하던 도중 텍스쳐 압축에 호기심이 생겨 공부하기 + 호기심을 풀기 위해 텍스쳐 압축에 대해 알아보기로 하였다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Make Jekyll+github Blog 1</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1/" rel="alternate" type="text/html" title="Make Jekyll+github Blog 1" />
      <published>2017-03-08T00:00:00+00:00</published>
      <updated>2017-03-08T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1/">&lt;p&gt;아는 지인이 좋다고 추천해서 jekyll+github 으로 블로그를 만들게 되었다.
한글로 된 자료가 그리 많지 않아 직접 기록해보려 한다.&lt;/p&gt;

&lt;h2&gt;개요&lt;/h2&gt;

&lt;p&gt;원리는 간단하다. GitHub 에서 jekyll 로 만들어진 블로그 백엔드 서비스(BaaS)를 지원하고, 사용자는 일정한 형식으로 레포지토리를 구성하면 블로그가 짠! 하고 나타난다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;GitHub 에서 작업할 것들&lt;/h2&gt;

&lt;p&gt;순서는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;GitHub 계정이 없을 시 가입하기&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;GitHub 에 블로그 레포지토리 만들기&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3&gt;GitHub 가입하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/github_homepage_signup.png&quot; alt=&quot;Github.com&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com&quot;&gt;Github.com&lt;/a&gt;에서 가입하면 된다. 가입 절차는 간단하니 직접 해보라.&lt;/p&gt;

&lt;h3&gt;GitHub 에 블로그 레포지토리 만들기&lt;/h3&gt;

&lt;p&gt;하나의 저장소를 만든다. 이때 중요한 것은 레포지토리 이름을 반드시 “&lt;strong&gt;(닉네임)&lt;/strong&gt;.githum.com” 으로 적어주여야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/github_make_repo.png&quot; alt=&quot;make_repo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 말이다. 우리는 원격 블로그 저장소를 만들었다. 이제 저장할 블로그 내용물을 만들 차례다.&lt;/p&gt;

&lt;h2&gt;블로그 만들기&lt;/h2&gt;

&lt;p&gt;Github 에서는 Ruby 로 만들어진 Jekyll 프레임워크 기반의 블로그를 지원한다. 즉 Jekyll 로 블로그를 만들어 GitHub 레포지토리에 올리면 잘 보인다. 만들어진 GitHub 레포지토리를 들어가보면 기본적으로 만들어진 블로그가 있다. 포스팅이 가능하고 기본적인 정보를 올릴 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 이 블로그는 만들어진 테마를 가져와서 세팅하는 것이기 때문에 내 멋대로 커스터마이징이 힘들다. 그렇다고 직접 스킨을 만들기에는.. 아무것도 모르는 사람이 처음부터 직접 만들기는 힘들다. 그러면 다른 사람이 만들어진걸 가져다 쓰는게 가장 빠르고 간편한 방법이다.&lt;/p&gt;

&lt;h3&gt;만들어진 테마 가져오기&lt;/h3&gt;

&lt;p&gt;우선 &lt;a href=&quot;https://jekyllthemes.org&quot;&gt;jekyll 테마 홈페이지&lt;/a&gt;이나 github에서 민들어진 jekyll 테마들을 찾아볼 수 있다. github 에서 가져오거나, &lt;a href=&quot;https://jekyllthemes.org&quot;&gt;jekyll 테마 홈페이지&lt;/a&gt;에서 직접 파일을 받아 쓸 수 있다.&lt;/p&gt;

&lt;h4&gt;1. GitHub 에서 테마 가져오기&lt;/h4&gt;

&lt;p&gt;여러 방법이 있지만 필자는&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;clone 해서 로컬 저장소를 만든다.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;연결된 remote repository 를 블로그 repository 로 바꾼다.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 방식으로 진행했다.&lt;/p&gt;

&lt;p&gt;GitHub 에서 원하는 jekyll 테마를 clone 해준다. 이 글을 쓸 무렵 필자는 &lt;a href=&quot;https://github.com/yous/whiteglass&quot;&gt;whiteglass&lt;/a&gt; 테마를 사용했었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/github_jekyll_whiteglass_theme.png&quot; alt=&quot;whiteglass_theme&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git clone {other’s url}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 그림의 위치에서 url 을 복사해 세팅할 디렉토리에 위와 같이 입력해주면 된다.&lt;/p&gt;

&lt;p&gt;clone 을 한 후에는 가져온 remote repository 가 연결되어 있을 것이다. 일단 확인부터 해보자. 우선 프로젝트 루트 디렉토리로 이동해 shell 을 키고 아래 커맨드를 입력한다&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote -v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그럼 아마도 아래와 같이 나올것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;origin (other’s-url) (fetch)&lt;/p&gt;

  &lt;p&gt;origin (other’s-url) (push)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;잘 살펴보면 알겠지만 중간에 들어간 url 은 가져온 프로젝트의 url 이다. 변경하려면 다음과 같이 하면된다&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote remove origin // 등록된 origin을 지운다.
git remote add origin &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;repository-url&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; // 본인 블로그 레포지토리 url 을 등록시켜 준다.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그 다음 다시 등록된 remote repository 를 확인해보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote -v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;등록한 url 로 나오면 성공이다. 이제 연결을 해주었으니 원할 때 remote repository 로 보내면 된다.&lt;/p&gt;

&lt;p&gt;정석인 방법은 원본 프로젝트를 fork 해서 나의 레포지토리로 바꾼 후 수정을 거쳐 하는것이지만, 언제 스킨을 바꿀지 모르기에 위 방식대로 진행했다.&lt;/p&gt;

&lt;h4&gt;2. jekyll 테마 프로젝트를 구해서 설정하기&lt;/h4&gt;

&lt;p&gt;이 방법도 크게 다르지 않다. 단지 local repository의 설정이 다를뿐이다. 아래와 같이 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;jekyll 테마 프로젝트의 루트 디렉토리에서 git 저장소로 설정한다.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;블로그 repository 를 remote repository 로 등록시켜 준다.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 방식으로 진행했다.&lt;/p&gt;

&lt;p&gt;프로젝트의 루트 디렉토리로 shell 을 이동해 아래와 같이 명령을 입력해준다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git init&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;맨 처음 local repository로 설정해주는 명령어다. 인자가 따로 필요없이 그냥 저렇게만 쳐주면 된다.&lt;/p&gt;

&lt;p&gt;기존에 연결된 remote repository 가 없으니 바로 remote repository 를 설정해주면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote add origin &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;repository-url&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; // 본인 블로그 레포지토리 url 을 등록시켜 준다.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;여기까지 하면 local repository 를 설정하는건 끝이다.&lt;/p&gt;

&lt;h3&gt;jekyll 개발환경 설정하기&lt;/h3&gt;

&lt;p&gt;테마까지 로컬 저장소에 설정을 해놓았으니 컴퓨터에서 가상의 서버를 돌려가면서 본인의 포스팅을 확인할 환경을 만들어 주어야 한다. 물론 세팅을 하지않고 포스팅을 할수는 있다. 변경하고 push 하고, 확인하고, 변경후 push하고 확인하는 루틴이 계속될 것이다.&lt;/p&gt;

&lt;p&gt;하지만 위에서 말한 방법은 &lt;em&gt;매우&lt;/em&gt; 귀찮다. 쓰는대로 바로바로 진행이 되어야 편할 것이라 생각했기에 직접 jekyll 개발환경을 세팅하는 방향을 선택했다.&lt;/p&gt;

&lt;p&gt;리눅스 계열 OS 를 사용하는 개발자들은 대부분 구버젼의 Ruby 가 깔려 있겠지만 Windows 환경에서는 전혀 그런게 없다. 그래서 필자는 직접 설치 해주었다. &lt;a href=&quot;https://rubyinstaller.org&quot;&gt;Ruby installer&lt;/a&gt; 사이트에 들어가면 간단하게 isntaller 만 받아 설치를 해줄 수 있다. 설치 과정 중 환경변수(Path) 설정하는 옵션을 설정하면 간단하게 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;bundler&lt;/em&gt; 라는 툴을 깔아주어야 한다. 쉘에서 많이 사용하며 Ruby 의 불편한 의존성 관리를 도와주는 툴이라고 한다. jekyll 에서는 기본적으로 &lt;em&gt;bundler&lt;/em&gt; 를 사용하기 때문에 꼭 설치해주어야 한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;gem install bundler&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 jekyll 만 깔아주면 개발 환경 구축은 끝이다. 아래 명령어를 입력하자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;gem install jekyll&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3&gt;로컬 환경에서 블로그 확인하기&lt;/h3&gt;

&lt;p&gt;모든 세팅이 다 끝났다면 이제 블로그를 직접 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;jekyll serve&lt;/p&gt;

&lt;p&gt;위 명령어를 입력 후, 루프백 IP(127.0.0.1)나, localhost 도메인을 통해 블로그 서버를 직접 확인할 수 있다. 참고로 jekyll 은 4000 포트를 쓰니 참고 바란다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="jekyll" />
      
        <category term="makeblog" />
      
        <category term="try" />
      

      

      
        <summary type="html">아는 지인이 좋다고 추천해서 jekyll+github 으로 블로그를 만들게 되었다. 한글로 된 자료가 그리 많지 않아 직접 기록해보려 한다. 개요 원리는 간단하다. GitHub 에서 jekyll 로 만들어진 블로그 백엔드 서비스(BaaS)를 지원하고, 사용자는 일정한 형식으로 레포지토리를 구성하면 블로그가 짠! 하고 나타난다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Ue4 Vs Unity5</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/05/ue4-vs-unity5/" rel="alternate" type="text/html" title="Ue4 Vs Unity5" />
      <published>2017-03-05T00:00:00+00:00</published>
      <updated>2017-03-05T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/05/ue4-vs-unity5</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/05/ue4-vs-unity5/">&lt;h3&gt;&lt;em&gt;이 글은 강의를 듣는 분들을 위해 작성된 심심풀이 땅콩같은 글임을 알립니다. &lt;strong&gt;절대&lt;/strong&gt; 논란의 여지가 되고 싶지 않습니다.&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Unity 로 게임 개발을 시작한지 약 2년이 넘었습니다. 이제 언리얼 엔진 4에 발을 들여놓으려고 합니다. 막 파악하면서 느낀 점을 적어보려고 합니다. 기존 개발을 해오던 분들과 의견이 다를수도 있으니 너그러운 마음으로 읽어주시길 바랍니다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;Overview 의 차이&lt;/h2&gt;

&lt;p&gt;문서를 읽으면서, 예제를 실험해보면서 느낀 점은, 둘의 스케일이 다르다는 것 입니다. Unity 는 비교적 간단하고 심플한 구조를 가진 반면, Unreal Engine 4 는 복잡하나 엔진 차원에서 많은 것을 지원하려 하는 것이 보입니다.&lt;/p&gt;

&lt;h3&gt;게임 시스템&lt;/h3&gt;

&lt;p&gt;게임 시스템을 보면, Unity 는 Scene 이란 GameObject 들의 계층 구조의 집합을 정의해놓고 모든 로직이 그 안에서 돌아가게 합니다. GameObject 들은 여러 Component 들을 붙이거나 뗄 수 있습니다. CBD 기반이지요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unity_HierarchyWindowCallout.png&quot; alt=&quot;Unity Hierarchy 뷰어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Unrealengine 에서는 레벨이란 단위안에 지형, 액터등 많은 것들을 가지고 사용자가 직접 로드하게 하거나 자동으로 로드해줍니다. 또한 여러 오브젝트들에 하위 컴포넌트나, Blueprint 스크립트를 붙일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unityandue4.jpg&quot; alt=&quot;Unity 와 UE4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unrealengine.com/latest/INT/GettingStarted/FromUnity/index.html&quot;&gt;Unrea Engine 4 For Unity Developers&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;개발 언어 환경&lt;/h3&gt;

&lt;p&gt;Unity 는 C#, JavaScript, Boo 이 세 가지 언어로 개발을 할 수 있습니다. 특히 가장 유명한 것은 C# 이겠지요. Mono 프로젝트의 공이 크다고 생각됩니다. 현 세대의 아주 강력한 Miscrosoft 에서 주도하는 언어 C# 을 모든 플랫폼에서 개발을 가능하게 만들고, Unity 에서는 이를 채택해 거의 모든 플랫폼의 개발이 가능해졌지요. 게다가 Mono 프로젝트를 이끌던 Xamarin 회사는 작년에 Miscrosoft 에서 인수했다는 소식이 있었습니다. 하여튼 Unity 는 C# 과 함께 성장할것 같이 보입니다.&lt;/p&gt;

&lt;p&gt;Unreal Engine 4 은 C++, Blueprint 로 개발이 가능합니다. C++ 은 OOP 언어의 대부분이 가지고 있는 리플렉션의 개념이 없습니다. 쓰더라도 전처리 과정에서만 가능하지요. 하지만 Unreal Engine 4 에서는 시스템을 덧붙여 가능하게 만들었습니다. 또한 코드 타이핑을 하지 않고 GUI 로 프로그래밍이 가능한 BluePrint 라는 강력한 방법도 지원합니다. 가장 놀라운 점은 이 기능들을 자체적으로 만든 것입니다.&lt;/p&gt;

&lt;h2&gt;Unreal Engine 4 의 장점?&lt;/h2&gt;

&lt;p&gt;Unreal Engine 4 의 장점 몇가지를 뽑아보겠습니다.&lt;/p&gt;

&lt;p&gt;첫 항목에 규모가 크다는 말을 했었습니다. 전문화된 툴이 정말 많습니다. 시네마틱을 제작하는 시퀀서, 3D 모델, 애니메이션 정보들을 편집 가능한 스켈레톤 시스템, AI 를 위한 비헤이비어 트리 시스템 등 많은 기능들을 지원합니다.&lt;/p&gt;

&lt;p&gt;두번째로는 엔진 자체가 오픈 소스이고, 엔진 구현에 관한 문서들이 자세하게 잘 설명되어 있습니다. 오픈 소스인 만큼 엔진 자체에 문제가 생겼을 시 직접 소스코드를 수정해 사용이 가능하고, GitHub 페이지를 사용해 문제를 제기할 수 있어 “공생” 이라는 슬로건에 알맞는 정책입니다. 상세한 문서화는 Unreal Engine 4 를 처음 접하는 개발자도, 개발에 쓰고있는 개발자들에게도 많은 도움을 줍니다.&lt;/p&gt;

&lt;p&gt;마지막은 언리얼 데브 그랜트 라는 정책이 있습니다. 이는 Unreal Engine 으로 개발된 가능성 있는 게임들을 신청받아 한화로 약 5백만원에서 5천만원 사이의 지원금을 보조하는 정책입니다. 지원금의 사용은 자유로우며 지적재산권도 개발사가 소유합니다. 아무런 권리도 가져가지 않고 지원하는 것이지요.&lt;/p&gt;

&lt;h2&gt;마지막으로&lt;/h2&gt;

&lt;p&gt;Unreal Engine 4 는 특별한 움직임은 보이지 않습니다. 하지만 여태까지 했던 것들만 해도 정말 대단합니다. 약 2,3달 간격의 버젼업은 무릎을 탁 치다 못해 탈골될 지경이지요. 자체적으로 보유한 기술을 따지면.. 엄청난 가치들이 있습니다.&lt;/p&gt;

&lt;p&gt;Unity 는 2017 버젼과 Unity5 마지막 버젼을 앞에 두고 있습니다. 이전에 릴리즈된 Unity 5.5 버젼에서는 꽤 발전된 모습을 보여주었습니다. 가장 돋보이는 점은 Mono C# 컴파일러 버젼을 Mono 4.4 버젼으로 업그레이드 한 것입니다. 드디어 4버젼부터 가져오던 Mono 프레임워크 문제를 해결하려 하는게 보입니다.&lt;/p&gt;

&lt;p&gt;둘다 장단점이 있지만 여태까지 행보를 보면 Unreal Engine 4 가 우세하다고 봅니다. 표면적으로 드러난 기술력, 자본만 보아도 엔진 자체만 보더라도 말이지요. 하지만 앞일은 모르니 조금 더 지켜봐야할 필요는 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="edu" />
      
        <category term="ue4" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">이 글은 강의를 듣는 분들을 위해 작성된 심심풀이 땅콩같은 글임을 알립니다. 절대 논란의 여지가 되고 싶지 않습니다. Unity 로 게임 개발을 시작한지 약 2년이 넘었습니다. 이제 언리얼 엔진 4에 발을 들여놓으려고 합니다. 막 파악하면서 느낀 점을 적어보려고 합니다. 기존 개발을 해오던 분들과 의견이 다를수도 있으니 너그러운 마음으로 읽어주시길 바랍니다.</summary>
      

      
      
    </entry>
  
  
</feed>
