<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko">
  <generator uri="http://jekyllrb.com" version="3.4.1">Jekyll</generator>
  
  
  <link href="hrmrzizon.github.io/feed.xml" rel="self" type="application/atom+xml" />
  <link href="hrmrzizon.github.io/" rel="alternate" type="text/html" hreflang="ko" />
  <updated>2017-03-26T12:39:32+00:00</updated>
  <id>hrmrzizon.github.io//</id>

  
    <title type="html">Apocrypha</title>
  

  
    <subtitle>지식을 정리합니다.</subtitle>
  

  
    <author>
        <name>hermaeus mora</name>
      
      
    </author>
  

  
  
    <entry>
      
      <title type="html">Csharp Class Method Extension</title>
      
      <link href="hrmrzizon.github.io/2017/03/13/csharp-class-method-extension/" rel="alternate" type="text/html" title="Csharp Class Method Extension" />
      <published>2017-03-13T00:00:00+00:00</published>
      <updated>2017-03-13T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/13/csharp-class-method-extension</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/13/csharp-class-method-extension/">&lt;p&gt;unirx 를 살펴보다 모르는 문법이 나와서 기록해둔다. &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/bb383977.aspx&quot;&gt;MSDN 확장 메서드 문서&lt;/a&gt; 를 참고했다.&lt;/p&gt;

&lt;h2&gt;C# 클래스 확장 메서드&lt;/h2&gt;

&lt;p&gt;C# 3.0 문법부터 사용자가 기존에 정의된 클래스에 메소드를 확장 가능하게 되었다. obj-c 의 카테고리와 조금 비슷한것 같다. 자세한 사항은 코드와 함께 보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Linq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CustomExtensions&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Extension methods must be defined in a static class
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringExtension&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// This is the extension method.
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// The first parameter takes the &quot;this&quot; modifier
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// and specifies the type for which the method is defined.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WordCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'?'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringSplitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RemoveEmptyEntries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;선언 방식은 위와 같다. 반드시 static class 에 static method 로 선언해주어야 하며, 첫번째 파라미터는 확장할 타겟 클래스의 인스턴스와 함께 앞에 this 키워드를 사용해주면 된다. 필요한 파라미터가 있다면 그 뒤에다 쭉 써주면 된다. 다만 외부에서 호출해주는 것이기 때문에 한정자의 제한을 받는다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Extension_Methods_Simple&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Import the extension method namespace.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CustomExtensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Program&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;The quick brown fox jumped over the lazy dog.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//  Call the method as if it were an
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//  instance method on the type. Note that the first
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//  parameter is not specified by the calling code.
&lt;/span&gt;            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WordCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Word count of s is {0}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;사용 방법은 간단하다. 구현한 네임스페이스를 임포트 해주고, 확장한 메서드를 (인스턴스).(메서드) 형식으로 호출해주면 된다. 첫번째 타겟 클래스 인스턴스는 생략하고 파라미터를 넣어주면 된다. 다만 자기 자신의 함수를 호출해줄 때도 this 를 활용해 (인스턴스).(메서드) 형식으로 호출해주어야 한다.&lt;/p&gt;

&lt;h2&gt;주의점&lt;/h2&gt;

&lt;p&gt;이 기능은 참 편하다. 쉽게 클래스의 기능을 확장하기 때문이다. 근데 잘못 남용하다가는 아주 개판이 날 가능성이 높다. MSDN 에서는 반드시 필요한 곳에서만 사용하라고 권장하고 있다. 그리고 내 생각도 별반 다를바 없다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="csharp" />
      
        <category term="c#" />
      

      
        <summary type="html">unirx 를 살펴보다 모르는 문법이 나와서 기록해둔다. MSDN 확장 메서드 문서 를 참고했다. C# 클래스 확장 메서드 C# 3.0 문법부터 사용자가 기존에 정의된 클래스에 메소드를 확장 가능하게 되었다. obj-c 의 카테고리와 조금 비슷한것 같다. 자세한 사항은 코드와 함께 보자. using System.Linq; using System.Text; using System; namespace CustomExtensions { //Extension methods must be defined in a static class public static class StringExtension { // This is the extension method. // The first parameter takes the &quot;this&quot; modifier // and specifies the type for which the method is defined. public static int WordCount(this String str) { return str.Split(new char[] {' ', '.','?'}, StringSplitOptions.RemoveEmptyEntries).Length; } } } 선언 방식은 위와 같다. 반드시 static class 에 static method 로 선언해주어야 하며, 첫번째 파라미터는 확장할 타겟 클래스의 인스턴스와 함께 앞에 this 키워드를 사용해주면 된다. 필요한 파라미터가 있다면 그 뒤에다 쭉 써주면 된다. 다만 외부에서 호출해주는 것이기 때문에 한정자의 제한을 받는다. namespace Extension_Methods_Simple { //Import the extension method namespace. using CustomExtensions; class Program { static void Main(string[] args) { string s = &quot;The quick brown fox jumped over the lazy dog.&quot;; // Call the method as if it were an // instance method on the type. Note that the first // parameter is not specified by the calling code. int i = s.WordCount(); System.Console.WriteLine(&quot;Word count of s is {0}&quot;, i); } } } 사용 방법은 간단하다. 구현한 네임스페이스를 임포트 해주고, 확장한 메서드를 (인스턴스).(메서드) 형식으로 호출해주면 된다. 첫번째 타겟 클래스 인스턴스는 생략하고 파라미터를 넣어주면 된다. 다만 자기 자신의 함수를 호출해줄 때도 this 를 활용해 (인스턴스).(메서드) 형식으로 호출해주어야 한다. 주의점 이 기능은 참 편하다. 쉽게 클래스의 기능을 확장하기 때문이다. 근데 잘못 남용하다가는 아주 개판이 날 가능성이 높다. MSDN 에서는 반드시 필요한 곳에서만 사용하라고 권장하고 있다. 그리고 내 생각도 별반 다를바 없다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 5 S3 Texture Compression</title>
      
      <link href="hrmrzizon.github.io/2017/03/12/unity-texture-compression-5-s3-texture-compression/" rel="alternate" type="text/html" title="Unity Texture Compression 5 S3 Texture Compression" />
      <published>2017-03-12T00:00:00+00:00</published>
      <updated>2017-03-12T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/12/unity-texture-compression-5-s3-texture-compression</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/12/unity-texture-compression-5-s3-texture-compression/">&lt;h2&gt;5. S3TCs&lt;/h2&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      

      
        <summary type="html">5. S3TCs</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 4 Powervr Texture Compression</title>
      
      <link href="hrmrzizon.github.io/2017/03/12/unity-texture-compression-4-powervr-texture-compression/" rel="alternate" type="text/html" title="Unity Texture Compression 4 Powervr Texture Compression" />
      <published>2017-03-12T00:00:00+00:00</published>
      <updated>2017-03-12T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/12/unity-texture-compression-4-powervr-texture-compression</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/12/unity-texture-compression-4-powervr-texture-compression/">&lt;h2&gt;4. PVRTC&lt;/h2&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      

      
        <summary type="html">4. PVRTC</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 3 Erricson Texture Compression 2</title>
      
      <link href="hrmrzizon.github.io/2017/03/12/unity-texture-compression-3-erricson-texture-compression-2/" rel="alternate" type="text/html" title="Unity Texture Compression 3 Erricson Texture Compression 2" />
      <published>2017-03-12T00:00:00+00:00</published>
      <updated>2017-03-12T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/12/unity-texture-compression-3-erricson-texture-compression-2</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/12/unity-texture-compression-3-erricson-texture-compression-2/">&lt;p&gt;모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(&lt;a href=&quot;http://www.jacobstrom.com/output.html&quot;&gt;http://www.jacobstrom.com/output.html&lt;/a&gt;)&lt;/p&gt;

&lt;h2&gt;3. ETC2&lt;/h2&gt;

&lt;p&gt;ETC2 는 ETC 에서 블록의 모드를 더 추가해 다양한 방식으로 표현할 수 있는 텍스쳐 압축 방식이다. 다른 압축 방식들에서는 잉여 공간을 활용해 다른 데이터의 표현 수단으로 사용한 것을 보고, 고안해낸 사람은 ETC 에서도 같은 방식으로 잉여 공간을 찾아 활용할 계획을 한것 같다. 남는 공간은 없었지만 유효하지 않은(invalid) 비트 공간을 활용해 노말 모드, 동차(difference) 모드 외에도 세가지의 표현 방식을 추가했다.&lt;/p&gt;

&lt;h4&gt;(1) 유효하지 않은 비트 공간이란?&lt;/h4&gt;

&lt;p&gt;ETC 에서 동차(difference) 모드는 서브블록의 색 공간을 합쳐서 활용하여 RGB555+dRGB333 으로 색을 표현했다. 여기서 유효하지 않은 비트 공간을 일부로 만들 수 있다. 바로 각자 색 성분이 합쳐져 0미만으로 언더 플로우가 나게하거나, 32 이상으로 만들어 오버플로우를(RGB555) 줘서 신호를 주는 것이다. 그렇게 RGB 세 성분을 유효하지 않게 만들어 3가지의 모드를 확보한다. ETC2 는 이 3가지 모드를 보조(auxiliary) 모드라고 칭한다. 아래 그림은 모드를 선택하는 다이어그램이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/etc2_invalid_bit_diagram.png&quot; alt=&quot;diagram&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ETC2 의 모드 선택 다이어그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 그림에서 오버플로우, 언더플로우가 생길 떄 보조 모드에서 55bit 가 남는다고 쓰여있다. diffbit 을 사용하는 1bit, 색상의 빨간색 컴포넌트 R0, dR 두개를 합치면 8bit 로 63bit 에서 값을 빼서 구한 값이다. 사실 55bit 가 아닌 59bit 를 사용가능하다.&lt;/p&gt;

&lt;p&gt;오버플로우, 언더플로우가 생기는 모든 케이스가 아래 표에 표현되어 있다. 데이터를 이진수로 보면 R0, dR 컴포넌트의 맨 마지막&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/etc2_overflow_bit_table.png&quot; alt=&quot;diagram&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ETC2 의 invalid 한 색상 테이블&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;RGB555+dRGB333 색 조합 오버,언더플로우 방식으로 특이점을 주어 59, 58, 57 의 페이로드를 확보함.
근데 왜 아직도 1bit 씩 공간이 필요한지 모르겠음. 그리고 디스크에 기록할때 4bit 로 줄여서 기록하면 그 줄어든 데이터는 어케 알아봄??;&lt;/p&gt;

&lt;p&gt;이렇게 새로운 모드를 구별 가능한데, 이전의 ETC 텍스쳐 데이터를 ETC2 디코더가 읽어도 오버,언더플로우가 나지 않기 때문에 이전 버젼의 텍스쳐를 읽어도 정상적으로 표현이 가능하다. 즉 ETC2는 ETC 의 하위 호환을 지원한다는 말이다.&lt;/p&gt;

&lt;h4&gt;(2) 추가된 세가지 모드&lt;/h4&gt;

&lt;h6&gt;(1) T 모드&lt;/h6&gt;
&lt;h6&gt;(2) H 모드&lt;/h6&gt;
&lt;h6&gt;(3) planar 모드&lt;/h6&gt;

&lt;h4&gt;(3) 특징&lt;/h4&gt;

&lt;p&gt;ETC2 는 OpenGL ES 3.0 이상에서만 사용가능하기 때문에 ES 3.0 을 지원하지 않으면 아예 쓸 수가 없다. 요즈음 모바일 기기들은 꽤 발전하긴 하지만 아직 많이 남아있는 기기들이 OpenGL ES 2.X 버젼까지만 지원한다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      

      
        <summary type="html">모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(http://www.jacobstrom.com/output.html) 3. ETC2 ETC2 는 ETC 에서 블록의 모드를 더 추가해 다양한 방식으로 표현할 수 있는 텍스쳐 압축 방식이다. 다른 압축 방식들에서는 잉여 공간을 활용해 다른 데이터의 표현 수단으로 사용한 것을 보고, 고안해낸 사람은 ETC 에서도 같은 방식으로 잉여 공간을 찾아 활용할 계획을 한것 같다. 남는 공간은 없었지만 유효하지 않은(invalid) 비트 공간을 활용해 노말 모드, 동차(difference) 모드 외에도 세가지의 표현 방식을 추가했다. (1) 유효하지 않은 비트 공간이란? ETC 에서 동차(difference) 모드는 서브블록의 색 공간을 합쳐서 활용하여 RGB555+dRGB333 으로 색을 표현했다. 여기서 유효하지 않은 비트 공간을 일부로 만들 수 있다. 바로 각자 색 성분이 합쳐져 0미만으로 언더 플로우가 나게하거나, 32 이상으로 만들어 오버플로우를(RGB555) 줘서 신호를 주는 것이다. 그렇게 RGB 세 성분을 유효하지 않게 만들어 3가지의 모드를 확보한다. ETC2 는 이 3가지 모드를 보조(auxiliary) 모드라고 칭한다. 아래 그림은 모드를 선택하는 다이어그램이다. ETC2 의 모드 선택 다이어그램   위 그림에서 오버플로우, 언더플로우가 생길 떄 보조 모드에서 55bit 가 남는다고 쓰여있다. diffbit 을 사용하는 1bit, 색상의 빨간색 컴포넌트 R0, dR 두개를 합치면 8bit 로 63bit 에서 값을 빼서 구한 값이다. 사실 55bit 가 아닌 59bit 를 사용가능하다. 오버플로우, 언더플로우가 생기는 모든 케이스가 아래 표에 표현되어 있다. 데이터를 이진수로 보면 R0, dR 컴포넌트의 맨 마지막 ETC2 의 invalid 한 색상 테이블   RGB555+dRGB333 색 조합 오버,언더플로우 방식으로 특이점을 주어 59, 58, 57 의 페이로드를 확보함. 근데 왜 아직도 1bit 씩 공간이 필요한지 모르겠음. 그리고 디스크에 기록할때 4bit 로 줄여서 기록하면 그 줄어든 데이터는 어케 알아봄??; 이렇게 새로운 모드를 구별 가능한데, 이전의 ETC 텍스쳐 데이터를 ETC2 디코더가 읽어도 오버,언더플로우가 나지 않기 때문에 이전 버젼의 텍스쳐를 읽어도 정상적으로 표현이 가능하다. 즉 ETC2는 ETC 의 하위 호환을 지원한다는 말이다. (2) 추가된 세가지 모드 (1) T 모드 (2) H 모드 (3) planar 모드 (3) 특징 ETC2 는 OpenGL ES 3.0 이상에서만 사용가능하기 때문에 ES 3.0 을 지원하지 않으면 아예 쓸 수가 없다. 요즈음 모바일 기기들은 꽤 발전하긴 하지만 아직 많이 남아있는 기기들이 OpenGL ES 2.X 버젼까지만 지원한다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 2 Erricsson Texture Compression</title>
      
      <link href="hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression/" rel="alternate" type="text/html" title="Unity Texture Compression 2 Erricsson Texture Compression" />
      <published>2017-03-12T00:00:00+00:00</published>
      <updated>2017-03-12T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression/">&lt;h4&gt;이 글은 &lt;a href=&quot;jhedde.tistory.com&quot;&gt;이전 블로그&lt;/a&gt;에서 가져온 글입니다.&lt;/h4&gt;

&lt;p&gt;모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(&lt;a href=&quot;http://www.jacobstrom.com/output.html&quot;&gt;http://www.jacobstrom.com/output.html&lt;/a&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. ETC(Erricsson Texture Compression)&lt;/h2&gt;

&lt;p&gt;처음 알아볼 압축 방식은 ETC(Erricsson Texture Comperssion) 이다. Jacob Ström&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, Tomas Akenine-Möller 두 사람이 학부 실저에 고안해낸 PACKMAN(2004) 을 더 발전시켜 iPACKMAN(2005) 이라는 학명으로 SIGGRAPH 라는 유명한 컨퍼런스에 등장했다. 이 후 iPACKMAN 의 공식 명칭이 Errcisson Texture Compression(ETC1) 으로 되어 쓰이게 된다. ETC 를 알아보기 전, 먼저 고안된 PACKMAN 을 알아보기로 하자.&lt;/p&gt;

&lt;h4&gt;(1) PACKMAN?&lt;/h4&gt;

&lt;p&gt;PACKMAN 은 블록 방식의 텍스쳐 압축 기법으로, 직사각형 픽셀 그룹을 만들어 압축한다. RGB 채널이 각각 8bit인 픽셀 8개를(2*4=8) 총 32bit로 압축시킨다. 압축을 안할 시 192bit 이니 1/6 의 공간을 차지하게 압축한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/etc1_12bit_general_color.png&quot; alt=&quot;12bit_general_color&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;+&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/etc1_per-pixel_luminance.png&quot; alt=&quot;per-pixel_luminance&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;+&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/etc1_packman-compressed.png&quot; alt=&quot;packman-compressed&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12bit general color&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;per-pixel_luminance&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;packman-compressed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;PACKMAN 의 정보는 블록에서 평균색(첫번째 그림:general color)과 색 편차가 들어가 있는 테이블의 인덱스를 픽셀별로 기록해(두번째 그림:per-pixel luminance) 평균 색 + 색 편차로 각 픽셀의 색을 결정해 텍스쳐를 구성한다.(세번째 그림:packman-compressed)&lt;/p&gt;

&lt;p&gt;평균색은 말 그대로 픽셀들간의 평균 색이고, 색 편차는 픽셀별로 다른 색들을 평균 색과 비교해서 가장 가까운 편차를 선정한다. 위 문단에서 테이블의 인덱스를 기록한다고 했는데 더 자세하게 알아보기 위해 테이블을 가져왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/etc1_luminance_table.png&quot; alt=&quot;luminancetable&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 표는 자주 사용될만한 색 편차들을 정해놓은 표다. 원래는 4개의 숫자가 한개의 세트로 16세트로 구성되어 있으나, 위 표에는 앞의 8개만 나와있다.&lt;/p&gt;

&lt;p&gt;색 편차 데이터가 구성되는 방식은 8개의 픽셀들간에 가장 오차가 적을만한 table codeword 를 선정한 후 4개의 데이터 중 하나를 골라 인덱스를 저장한다. 색편차를 저장하는 데이터의 종류는 table codeword 와 그 세트안의 인덱스 정보 두개다. 또한 픽셀 인덱스는 픽셀별로 필요하기 때문에 8개가 필요하다.&lt;/p&gt;

&lt;p&gt;색 편차 데이터의 구성 방식을 알아보았으니 전체 색 구성 방식을 알아보자. 필요한 정보와 데이터의 크기는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;픽셀간의 평균색 : RGB444(12bit)&lt;/li&gt;
    &lt;li&gt;테이블 코드워드 : 0~15(4bit)&lt;/li&gt;
    &lt;li&gt;픽셀별 인덱스 : 0~3(2bit)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;평균색은 RGB444 방식으로 12bit로 표현되며, table codeword 는 총 16개가 있으니 4bit 가 필요하다, 그리고 픽셀별 인덱스는 4가지의 숫자만 표현하면 되니 2bit 면 충분하다. 그래서 8개의 픽셀색을 표현하는데 필요한 비트는 12+4+2*8= 32bit 가 필요하다.&lt;/p&gt;

&lt;h4&gt;(2) iPACKMAN?&lt;/h4&gt;

&lt;p&gt;PACKMAN 압축 방식은 문제가 있었다. PACKMAN 방식으로 압축된 이미지와 각 픽셀당 RGB444 로 압축된 이미지를 비교했을 때 휘도(luminance)만 보면 더 좋은 결과를 보여주었지만 색차(chrominance) 면에서 보면 더 안좋은 결과를 보였다. 특히 그라데이션 같이 색이 천천히 바뀌는 이미지에서 색차 밴딩(chrominance banding)이 심했다고 한다. RGB444 방식을 사용해서 작은 차이를 표현하기 어렵고, 한 블록(8개의 픽셀)당 한개의 RGB444 색만 사용하기 때문이다.&lt;/p&gt;

&lt;p&gt;그래서 iPACKMAN 에서는 색차 밴딩을 해결하기 위해 PACKMAN 의 방식에서 변형된 모드를 하나 추가했다. 그 모드 때문에 꽤 많은 부분이 바뀌었다. 모드를 제외한 변경사항은 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;table codeword 가 3bit 로 줄었다.&lt;/li&gt;
    &lt;li&gt;블록의 개념이 2&lt;em&gt;4 픽셀 그룹 하나에서 2&lt;/em&gt;4 픽셀 그룹 두개를 합친 4*4 픽셀 그룹으로 확장됬다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위에서 색차 밴딩이 심하다고 언급했다. 그리고 원인은 RGB444 에 있다고도 말했다. 그래서 데이터의 정밀도를 높이기 위해, 두 2*4 픽셀 그룹의 공간을 합쳐 기존에 독립적으로 2개의 RGB444 색상이 구성되던 방식과 달리 약간의 변화를 주어 RGB555+dRGB333 으로 데이터를 구성하는 방식을 고안해냈다.&lt;/p&gt;

&lt;p&gt;RGB444의 한계를 느끼고 RGB555 로 평균 색을 확장해서 색차의 범위를 확인했다. 20개의 서로 다른 이미지들의 색 편차(deviation)의 통계 데이터를 확인해보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/etc1_histogram_difference_average_color.png&quot; alt=&quot;histogram_difference&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RGB555로 양자화된 평균 색상의 편차 그래프&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;데이터를 보면 대부분 가운데에 몰려있다. 그래서 88%의 데이터를 포함가능한 -4 ~ 3 간격을 타겟으로 RGB555 를 사용후, RGB333 을 편차값으로 사용해 두 블록을 사용하는 방법을 사용했다.&lt;/p&gt;

&lt;p&gt;table codeword 가 3bit 로 줄은 이유는 이미지를 표현할 공간을 만들어야 했기 때문에 다른 것들을 살피다가 table codeword 를 줄인것으로 예측된다. table codeword 는 고정된 색상 편차 테이블의 인덱스인데, 20개의 이미지 테스트에서 3bit 로 줄이는 테스트를 해 보았을 때, 놀랍게도 평균 0.2db 차이가 안나 바꾸었다고 한다.&lt;/p&gt;

&lt;p&gt;table codeword 의 사이즈를 1bit 씩 줄여 2*4 픽셀 그룹이 2개니 2bit 여유 공간이 남았다. 이 공간들은 데이터의 구성을 표현하는 데이터가 된다. 1bit 는 새롭게 추가된 difference mode 냐, normal mode 냐를 표현하는 비트 플래그로, 1bit 는 수직으로 데이터가 구성되는지, 수평으로 데이터가 구성되는지에 대한 비트 플래그로 표현했다.&lt;/p&gt;

&lt;p&gt;직관적으로 데이터 구성을 이해하기 위해 논문에 있던 이미지를 첨부하겠다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/etc1_table_diff_vs_normal.png&quot; alt=&quot;histogram_difference&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;데이터 구성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4&gt;(3) 특징&lt;/h4&gt;

&lt;p&gt;ETC 의 특징은 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;모바일 디바이스를 기준으로 한 손실 압축 기법이다.&lt;/li&gt;
    &lt;li&gt;투명하지 않은(Non-Alpha) 텍스쳐(RGB24)를 지원한다. &lt;/li&gt;
    &lt;li&gt;OpenGL ES 2.0 이상 부터 표준 포맷이 되었으며, 안드로이드 프로요(2.2) 부터 공식 지원하기 시작했다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;ETC 는 기본적으로 모바일 디바이스를 타겟으로 만들어진 텍스쳐 압축 알고리즘이다. 그렇기에 구현 방식 또한 상당히 간단하고 명료하다. 보통 ETC 는 OpenGL ES 3.0 아래 버젼을 지원하는 GPU 를 탑재한 디바이스를 지원할 때 주로 사용되는 방식이다. 또한 알파를 설정할 수 없어 상당히 불편한 경우가 많다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;이 사람은 추후 ETC2 연구에도 참여하였다.&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      

      
        <summary type="html">이 글은 이전 블로그에서 가져온 글입니다. 모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(http://www.jacobstrom.com/output.html) 2. ETC(Erricsson Texture Compression) 처음 알아볼 압축 방식은 ETC(Erricsson Texture Comperssion) 이다. Jacob Ström1, Tomas Akenine-Möller 두 사람이 학부 실저에 고안해낸 PACKMAN(2004) 을 더 발전시켜 iPACKMAN(2005) 이라는 학명으로 SIGGRAPH 라는 유명한 컨퍼런스에 등장했다. 이 후 iPACKMAN 의 공식 명칭이 Errcisson Texture Compression(ETC1) 으로 되어 쓰이게 된다. ETC 를 알아보기 전, 먼저 고안된 PACKMAN 을 알아보기로 하자. (1) PACKMAN? PACKMAN 은 블록 방식의 텍스쳐 압축 기법으로, 직사각형 픽셀 그룹을 만들어 압축한다. RGB 채널이 각각 8bit인 픽셀 8개를(2*4=8) 총 32bit로 압축시킨다. 압축을 안할 시 192bit 이니 1/6 의 공간을 차지하게 압축한다. + + 12bit general color   per-pixel_luminance   packman-compressed           PACKMAN 의 정보는 블록에서 평균색(첫번째 그림:general color)과 색 편차가 들어가 있는 테이블의 인덱스를 픽셀별로 기록해(두번째 그림:per-pixel luminance) 평균 색 + 색 편차로 각 픽셀의 색을 결정해 텍스쳐를 구성한다.(세번째 그림:packman-compressed) 평균색은 말 그대로 픽셀들간의 평균 색이고, 색 편차는 픽셀별로 다른 색들을 평균 색과 비교해서 가장 가까운 편차를 선정한다. 위 문단에서 테이블의 인덱스를 기록한다고 했는데 더 자세하게 알아보기 위해 테이블을 가져왔다. 위 표는 자주 사용될만한 색 편차들을 정해놓은 표다. 원래는 4개의 숫자가 한개의 세트로 16세트로 구성되어 있으나, 위 표에는 앞의 8개만 나와있다. 색 편차 데이터가 구성되는 방식은 8개의 픽셀들간에 가장 오차가 적을만한 table codeword 를 선정한 후 4개의 데이터 중 하나를 골라 인덱스를 저장한다. 색편차를 저장하는 데이터의 종류는 table codeword 와 그 세트안의 인덱스 정보 두개다. 또한 픽셀 인덱스는 픽셀별로 필요하기 때문에 8개가 필요하다. 색 편차 데이터의 구성 방식을 알아보았으니 전체 색 구성 방식을 알아보자. 필요한 정보와 데이터의 크기는 아래와 같다. 픽셀간의 평균색 : RGB444(12bit) 테이블 코드워드 : 0~15(4bit) 픽셀별 인덱스 : 0~3(2bit) 평균색은 RGB444 방식으로 12bit로 표현되며, table codeword 는 총 16개가 있으니 4bit 가 필요하다, 그리고 픽셀별 인덱스는 4가지의 숫자만 표현하면 되니 2bit 면 충분하다. 그래서 8개의 픽셀색을 표현하는데 필요한 비트는 12+4+2*8= 32bit 가 필요하다. (2) iPACKMAN? PACKMAN 압축 방식은 문제가 있었다. PACKMAN 방식으로 압축된 이미지와 각 픽셀당 RGB444 로 압축된 이미지를 비교했을 때 휘도(luminance)만 보면 더 좋은 결과를 보여주었지만 색차(chrominance) 면에서 보면 더 안좋은 결과를 보였다. 특히 그라데이션 같이 색이 천천히 바뀌는 이미지에서 색차 밴딩(chrominance banding)이 심했다고 한다. RGB444 방식을 사용해서 작은 차이를 표현하기 어렵고, 한 블록(8개의 픽셀)당 한개의 RGB444 색만 사용하기 때문이다. 그래서 iPACKMAN 에서는 색차 밴딩을 해결하기 위해 PACKMAN 의 방식에서 변형된 모드를 하나 추가했다. 그 모드 때문에 꽤 많은 부분이 바뀌었다. 모드를 제외한 변경사항은 아래와 같다. table codeword 가 3bit 로 줄었다. 블록의 개념이 24 픽셀 그룹 하나에서 24 픽셀 그룹 두개를 합친 4*4 픽셀 그룹으로 확장됬다. 위에서 색차 밴딩이 심하다고 언급했다. 그리고 원인은 RGB444 에 있다고도 말했다. 그래서 데이터의 정밀도를 높이기 위해, 두 2*4 픽셀 그룹의 공간을 합쳐 기존에 독립적으로 2개의 RGB444 색상이 구성되던 방식과 달리 약간의 변화를 주어 RGB555+dRGB333 으로 데이터를 구성하는 방식을 고안해냈다. RGB444의 한계를 느끼고 RGB555 로 평균 색을 확장해서 색차의 범위를 확인했다. 20개의 서로 다른 이미지들의 색 편차(deviation)의 통계 데이터를 확인해보자. RGB555로 양자화된 평균 색상의 편차 그래프   데이터를 보면 대부분 가운데에 몰려있다. 그래서 88%의 데이터를 포함가능한 -4 ~ 3 간격을 타겟으로 RGB555 를 사용후, RGB333 을 편차값으로 사용해 두 블록을 사용하는 방법을 사용했다. table codeword 가 3bit 로 줄은 이유는 이미지를 표현할 공간을 만들어야 했기 때문에 다른 것들을 살피다가 table codeword 를 줄인것으로 예측된다. table codeword 는 고정된 색상 편차 테이블의 인덱스인데, 20개의 이미지 테스트에서 3bit 로 줄이는 테스트를 해 보았을 때, 놀랍게도 평균 0.2db 차이가 안나 바꾸었다고 한다. table codeword 의 사이즈를 1bit 씩 줄여 2*4 픽셀 그룹이 2개니 2bit 여유 공간이 남았다. 이 공간들은 데이터의 구성을 표현하는 데이터가 된다. 1bit 는 새롭게 추가된 difference mode 냐, normal mode 냐를 표현하는 비트 플래그로, 1bit 는 수직으로 데이터가 구성되는지, 수평으로 데이터가 구성되는지에 대한 비트 플래그로 표현했다. 직관적으로 데이터 구성을 이해하기 위해 논문에 있던 이미지를 첨부하겠다. 데이터 구성   (3) 특징 ETC 의 특징은 아래와 같다. 모바일 디바이스를 기준으로 한 손실 압축 기법이다. 투명하지 않은(Non-Alpha) 텍스쳐(RGB24)를 지원한다.  OpenGL ES 2.0 이상 부터 표준 포맷이 되었으며, 안드로이드 프로요(2.2) 부터 공식 지원하기 시작했다. ETC 는 기본적으로 모바일 디바이스를 타겟으로 만들어진 텍스쳐 압축 알고리즘이다. 그렇기에 구현 방식 또한 상당히 간단하고 명료하다. 보통 ETC 는 OpenGL ES 3.0 아래 버젼을 지원하는 GPU 를 탑재한 디바이스를 지원할 때 주로 사용되는 방식이다. 또한 알파를 설정할 수 없어 상당히 불편한 경우가 많다. 이 사람은 추후 ETC2 연구에도 참여하였다.&amp;nbsp;&amp;#8617;</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Garbage collecting</title>
      
      <link href="hrmrzizon.github.io/2017/03/12/garbage-collecting/" rel="alternate" type="text/html" title="Garbage collecting" />
      <published>2017-03-12T00:00:00+00:00</published>
      <updated>2017-03-12T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/12/garbage%20collecting</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/12/garbage-collecting/"></content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="gc" />
      
        <category term="common" />
      

      
        <summary type="html"></summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 1 Start</title>
      
      <link href="hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start/" rel="alternate" type="text/html" title="Unity Texture Compression 1 Start" />
      <published>2017-03-11T00:00:00+00:00</published>
      <updated>2017-03-11T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start/">&lt;h4&gt;이 글은 &lt;a href=&quot;jhedde.tistory.com&quot;&gt;이전 블로그&lt;/a&gt;에서 가져온 글입니다.&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;몇달 전 Unity 로 게임을 개발하던 도중 텍스쳐 압축에 호기심이 생겨 공부하기 + 호기심을 풀기 위해 텍스쳐 압축에 대해 알아보기로 하였다.&lt;/p&gt;

&lt;h2&gt;1. 텍스쳐 압축(Texture Compression)이란?&lt;/h2&gt;

&lt;h4&gt;1) 뜻&lt;/h4&gt;

&lt;p&gt;일반적으로 압축(Compression) 이란 원본 데이터를 조금 없에거나, 보존해서 파일의 크기를 줄이는 방법을 칭한다. 대표적인 예로 우리가 큰 파일을 전송할 때 압축을 해서 전송하는 경우가 있겠다.(zip, 7z) 이러한 파일 압축 기법들은 모든 데이터를 보존해야 하기 때문에 비손실 압축으로 되어 있다. 하지만 미디어 파일(오디오, 영상, 이미지) 들은 모든 데이터를 저장하지 않고 사람이 인식할 정도만 데이터를 저장하는 비손실 압축 기법이 대부분을 차지한다. (mp3, mp4, jpg) 비 손실 압축방법 중 잘 알려진 포맷은 PNG 포맷이 있다. JPEG, PNG 방식들은 통칭 이미지 압축(Image Compression) 이라 부른다. 하지만 텍스쳐 압축과 이미지 압축의 의미는 조금 다르다.&lt;/p&gt;

&lt;p&gt;텍스쳐 압축(Texture Compression) 위키피디아를 참조해보면 &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Texture compression is a specialized form of designed for storing in rendering systems. Unlike conventional image compression algorithms, texture compression algorithms are optimized for random access.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;문장들을 해석해보면 “텍스쳐 압축은 3D 컴퓨터 그래픽스 렌더링 시스템에서 텍스쳐 맵들을 저장하기위해 고안된 특별한 방식의 이미지 압축이다. 텍스쳐 압축 알고리즘은 전통적인 이미지 압축 알고리즘과 다르게 무작위 접근에 최적화 되어있다.” 라고 한다.&lt;/p&gt;

&lt;p&gt;텍스쳐 압축 알고리즘 자체는 이미지 압축 알고리즘이라 할 수 있다. 하지만 텍스쳐 압축 알고리즘이 이미지 압축과 다른 점은 3D 렌더링 시스템에서 빠르게 접근하기 위해 이미지의 픽셀별로 빠르게 접근이 가능하다는 것이다. 빠르게 접근 한다는 뜻은, &lt;strong&gt;압축된 텍스쳐 데이터 그대로에서 픽셀별로 데이터를 가져올 수 있어야 한다는 뜻이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;대부분의 미디어 압축 포맷에 응용되어 상당히 많이 쓰이는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%9F%B0_%EB%A0%9D%EC%8A%A4_%EB%B6%80%ED%98%B8%ED%99%94&quot;&gt;Run-Length Encoding&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%97%88%ED%94%84%EB%A7%8C_%EB%B6%80%ED%98%B8%ED%99%94&quot;&gt;Huffman Encoding&lt;/a&gt; 방식들은 Encode 된 상태에서 원하는 픽셀의 정보만 가져올려면 모든 데이터를 Decoding 한 후에 가져와야 한다.  즉 저 방식들이 들어간 압축 방식들은 빠른 무작위 접근이 힘들기 때문에 텍스쳐 압축 알고리즘에 응용될 수 없다.&lt;/p&gt;

&lt;h4&gt;2) 쓰임새 &lt;/h4&gt;

&lt;p&gt;실제로 텍스쳐 압축을 사용하려면 요구조건이 몇가지 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;그래픽 시스템(OpenGL, DirectX)에서 텍스쳐 압축을 지원해야 한다.&lt;/li&gt;
    &lt;li&gt;해당 컴퓨터의 GPU 에서 텍스쳐 압축을 지원해야 한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;자주 사용되는 텍스쳐 압축 방식은 그래픽 시스템에서 지원한다. 그래픽 시스템에 대한 걱정은 안해도 된다. 하지만 GPU 에서 지원하는 텍스쳐 압축 방식들은 알아야 한다. GPU 에서 지원하는 압축 포맷의 경우 압축된 데이터를 알아서 디코딩하지만, 지원 안하는 포맷의 경우 SW 디코딩을 하거나, 다른 포맷으로 바꿔주어야 한다.&lt;/p&gt;

&lt;p&gt;스마트폰을 예로 들면, 모바일 플랫폼은 GPU 의 종류가 4가지가 넘고, GPU 별, GPU 제조사 별로 지원하는 텍스쳐 압축 방식이 다 다르다.&lt;/p&gt;

&lt;p&gt;대표적으로 Apple 의 모바일 기기에서 쓰이는 Apple A~ 칩셋들은 모두 PowerVR GPU를 탑재했고, PowerVR GPU 는 PVRTC(PowerVR Texture Compression) 만 지원한다. Apple 제품군에서는 PVRTC 만 쓰면 된다.&lt;/p&gt;

&lt;p&gt;이에 반해 다양한 Android 기기들은 다양한 GPU 를 탑재해서 (QualComn Adreno, ARM Mali 등..) 더욱더 다양한 종류의 텍스쳐 압축 기법이 존재한다. Android 기반의 디바이스들은 거의 다 ETC1 을 지원하기 때문에 대표적으로 사용이 가능하긴 하다. 하지만 몇몇 기기가 PowerVR GPU 를 탑재하기 때문에&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; ETC1 만 사용할 수는 없다.&lt;/p&gt;

&lt;p&gt;즉 하나의 모바일 어플리케이션에서 모든 방식을 선택하기는 힘들다. 모든 방식을 지원하려면 다양한 방식의 리소스가 필요한데, 그러면 응용 프로그램의 용량이 엄청나게 될 것이다. 그래서 몇 가지 디바이스를 포기하거나, Unity 에서는 &lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/AssetBundlesIntro.html&quot;&gt;AssetBundle&lt;/a&gt;의 힘을 빌려 &lt;a href=&quot;http://dragonjoon.blogspot.kr/2015/08/blog-post.html&quot;&gt;&lt;strong&gt;이런 방법&lt;/strong&gt;&lt;/a&gt;을 쓸 수도있다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;대표적으로 삼성 Exynos 3110, 5410 이 있다. 쓰인 기기는 갤럭시 S, 갤럭시 탭 7.0, 갤럭시 S4&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      

      
        <summary type="html">이 글은 이전 블로그에서 가져온 글입니다. 몇달 전 Unity 로 게임을 개발하던 도중 텍스쳐 압축에 호기심이 생겨 공부하기 + 호기심을 풀기 위해 텍스쳐 압축에 대해 알아보기로 하였다. 1. 텍스쳐 압축(Texture Compression)이란? 1) 뜻 일반적으로 압축(Compression) 이란 원본 데이터를 조금 없에거나, 보존해서 파일의 크기를 줄이는 방법을 칭한다. 대표적인 예로 우리가 큰 파일을 전송할 때 압축을 해서 전송하는 경우가 있겠다.(zip, 7z) 이러한 파일 압축 기법들은 모든 데이터를 보존해야 하기 때문에 비손실 압축으로 되어 있다. 하지만 미디어 파일(오디오, 영상, 이미지) 들은 모든 데이터를 저장하지 않고 사람이 인식할 정도만 데이터를 저장하는 비손실 압축 기법이 대부분을 차지한다. (mp3, mp4, jpg) 비 손실 압축방법 중 잘 알려진 포맷은 PNG 포맷이 있다. JPEG, PNG 방식들은 통칭 이미지 압축(Image Compression) 이라 부른다. 하지만 텍스쳐 압축과 이미지 압축의 의미는 조금 다르다. 텍스쳐 압축(Texture Compression) 위키피디아를 참조해보면  Texture compression is a specialized form of designed for storing in rendering systems. Unlike conventional image compression algorithms, texture compression algorithms are optimized for random access. 문장들을 해석해보면 “텍스쳐 압축은 3D 컴퓨터 그래픽스 렌더링 시스템에서 텍스쳐 맵들을 저장하기위해 고안된 특별한 방식의 이미지 압축이다. 텍스쳐 압축 알고리즘은 전통적인 이미지 압축 알고리즘과 다르게 무작위 접근에 최적화 되어있다.” 라고 한다. 텍스쳐 압축 알고리즘 자체는 이미지 압축 알고리즘이라 할 수 있다. 하지만 텍스쳐 압축 알고리즘이 이미지 압축과 다른 점은 3D 렌더링 시스템에서 빠르게 접근하기 위해 이미지의 픽셀별로 빠르게 접근이 가능하다는 것이다. 빠르게 접근 한다는 뜻은, 압축된 텍스쳐 데이터 그대로에서 픽셀별로 데이터를 가져올 수 있어야 한다는 뜻이다. 대부분의 미디어 압축 포맷에 응용되어 상당히 많이 쓰이는 Run-Length Encoding, Huffman Encoding 방식들은 Encode 된 상태에서 원하는 픽셀의 정보만 가져올려면 모든 데이터를 Decoding 한 후에 가져와야 한다. 즉 저 방식들이 들어간 압축 방식들은 빠른 무작위 접근이 힘들기 때문에 텍스쳐 압축 알고리즘에 응용될 수 없다. 2) 쓰임새  실제로 텍스쳐 압축을 사용하려면 요구조건이 몇가지 있다. 그래픽 시스템(OpenGL, DirectX)에서 텍스쳐 압축을 지원해야 한다. 해당 컴퓨터의 GPU 에서 텍스쳐 압축을 지원해야 한다. 자주 사용되는 텍스쳐 압축 방식은 그래픽 시스템에서 지원한다. 그래픽 시스템에 대한 걱정은 안해도 된다. 하지만 GPU 에서 지원하는 텍스쳐 압축 방식들은 알아야 한다. GPU 에서 지원하는 압축 포맷의 경우 압축된 데이터를 알아서 디코딩하지만, 지원 안하는 포맷의 경우 SW 디코딩을 하거나, 다른 포맷으로 바꿔주어야 한다. 스마트폰을 예로 들면, 모바일 플랫폼은 GPU 의 종류가 4가지가 넘고, GPU 별, GPU 제조사 별로 지원하는 텍스쳐 압축 방식이 다 다르다. 대표적으로 Apple 의 모바일 기기에서 쓰이는 Apple A~ 칩셋들은 모두 PowerVR GPU를 탑재했고, PowerVR GPU 는 PVRTC(PowerVR Texture Compression) 만 지원한다. Apple 제품군에서는 PVRTC 만 쓰면 된다. 이에 반해 다양한 Android 기기들은 다양한 GPU 를 탑재해서 (QualComn Adreno, ARM Mali 등..) 더욱더 다양한 종류의 텍스쳐 압축 기법이 존재한다. Android 기반의 디바이스들은 거의 다 ETC1 을 지원하기 때문에 대표적으로 사용이 가능하긴 하다. 하지만 몇몇 기기가 PowerVR GPU 를 탑재하기 때문에1 ETC1 만 사용할 수는 없다. 즉 하나의 모바일 어플리케이션에서 모든 방식을 선택하기는 힘들다. 모든 방식을 지원하려면 다양한 방식의 리소스가 필요한데, 그러면 응용 프로그램의 용량이 엄청나게 될 것이다. 그래서 몇 가지 디바이스를 포기하거나, Unity 에서는 AssetBundle의 힘을 빌려 이런 방법을 쓸 수도있다. 대표적으로 삼성 Exynos 3110, 5410 이 있다. 쓰인 기기는 갤럭시 S, 갤럭시 탭 7.0, 갤럭시 S4&amp;nbsp;&amp;#8617;</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Object Communicatoin</title>
      
      <link href="hrmrzizon.github.io/2017/03/08/unity-object-communicatoin/" rel="alternate" type="text/html" title="Unity Object Communicatoin" />
      <published>2017-03-08T00:00:00+00:00</published>
      <updated>2017-03-08T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/08/unity-object-communicatoin</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/08/unity-object-communicatoin/">&lt;ol&gt;
  &lt;li&gt;function call&lt;/li&gt;
  &lt;li&gt;event, delegate&lt;/li&gt;
  &lt;li&gt;unityevent&lt;/li&gt;
  &lt;li&gt;messaging system&lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="unity" />
      
        <category term="csharp" />
      

      
        <summary type="html">function call event, delegate unityevent messaging system</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Make Jekyll+github Blog 1</title>
      
      <link href="hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1/" rel="alternate" type="text/html" title="Make Jekyll+github Blog 1" />
      <published>2017-03-08T00:00:00+00:00</published>
      <updated>2017-03-08T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1/">&lt;p&gt;아는 지인이 좋다고 추천해서 jekyll+github 으로 블로그를 만들게 되었다.
한글로 된 자료가 그리 많지 않아 직접 기록해보려 한다.&lt;/p&gt;

&lt;h2&gt;개요&lt;/h2&gt;

&lt;p&gt;원리는 간단하다. GitHub 에서 jekyll 로 만들어진 블로그 백엔드 서비스(BaaS)를 지원하고, 사용자는 일정한 형식으로 레포지토리를 구성하면 블로그가 짠! 하고 나타난다.&lt;/p&gt;

&lt;h2&gt;GitHub 에서 작업할 것들&lt;/h2&gt;

&lt;p&gt;순서는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;GitHub 계정이 없을 시 가입하기&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;GitHub 에 블로그 레포지토리 만들기&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3&gt;GitHub 가입하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/github_homepage_signup.png&quot; alt=&quot;Github.com&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com&quot;&gt;Github.com&lt;/a&gt;에서 가입하면 된다. 가입 절차는 간단하니 직접 해보라.&lt;/p&gt;

&lt;h3&gt;GitHub 에 블로그 레포지토리 만들기&lt;/h3&gt;

&lt;p&gt;하나의 저장소를 만든다. 이때 중요한 것은 레포지토리 이름을 반드시 “&lt;strong&gt;(닉네임)&lt;/strong&gt;.githum.com” 으로 적어주여야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/github_make_repo.png&quot; alt=&quot;make_repo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 말이다. 우리는 원격 블로그 저장소를 만들었다. 이제 저장할 블로그 내용물을 만들 차례다.&lt;/p&gt;

&lt;h2&gt;블로그 만들기&lt;/h2&gt;

&lt;p&gt;Github 에서는 Ruby 로 만들어진 Jekyll 프레임워크 기반의 블로그를 지원한다. 즉 Jekyll 로 블로그를 만들어 GitHub 레포지토리에 올리면 잘 보인다. 만들어진 GitHub 레포지토리를 들어가보면 기본적으로 만들어진 블로그가 있다. 포스팅이 가능하고 기본적인 정보를 올릴 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 이 블로그는 만들어진 테마를 가져와서 세팅하는 것이기 때문에 내 멋대로 커스터마이징이 힘들다. 그렇다고 직접 스킨을 만들기에는.. 아무것도 모르는 사람이 처음부터 직접 만들기는 힘들다. 그러면 다른 사람이 만들어진걸 가져다 쓰는게 가장 빠르고 간편한 방법이다.&lt;/p&gt;

&lt;h3&gt;만들어진 테마 가져오기&lt;/h3&gt;

&lt;p&gt;우선 &lt;a href=&quot;https://jekyllthemes.org&quot;&gt;jekyll 테마 홈페이지&lt;/a&gt;이나 github에서 민들어진 jekyll 테마들을 찾아볼 수 있다. github 에서 가져오거나, &lt;a href=&quot;https://jekyllthemes.org&quot;&gt;jekyll 테마 홈페이지&lt;/a&gt;에서 직접 파일을 받아 쓸 수 있다.&lt;/p&gt;

&lt;h4&gt;1. GitHub 에서 테마 가져오기&lt;/h4&gt;

&lt;p&gt;여러 방법이 있지만 필자는&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;clone 해서 로컬 저장소를 만든다.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;연결된 remote repository 를 블로그 repository 로 바꾼다.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 방식으로 진행했다.&lt;/p&gt;

&lt;p&gt;GitHub 에서 원하는 jekyll 테마를 clone 해준다. 이 글을 쓸 무렵 필자는 &lt;a href=&quot;https://github.com/yous/whiteglass&quot;&gt;whiteglass&lt;/a&gt; 테마를 사용했었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/github_jekyll_whiteglass_theme.png&quot; alt=&quot;whiteglass_theme&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git clone {other’s url}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 그림의 위치에서 url 을 복사해 세팅할 디렉토리에 위와 같이 입력해주면 된다.&lt;/p&gt;

&lt;p&gt;clone 을 한 후에는 가져온 remote repository 가 연결되어 있을 것이다. 일단 확인부터 해보자. 우선 프로젝트 루트 디렉토리로 이동해 shell 을 키고 아래 커맨드를 입력한다&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote -v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그럼 아마도 아래와 같이 나올것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;origin (other’s-url) (fetch)&lt;/p&gt;

  &lt;p&gt;origin (other’s-url) (push)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;잘 살펴보면 알겠지만 중간에 들어간 url 은 가져온 프로젝트의 url 이다. 변경하려면 다음과 같이 하면된다&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote remote origin // 등록된 origin을 지운다.
git remote add origin &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;repository-url&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; // 본인 블로그 레포지토리 url 을 등록시켜 준다.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그 다음 다시 등록된 remote repository 를 확인해보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote -v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;등록한 url 로 나오면 성공이다. 이제 연결을 해주었으니 원할 때 remote repository 로 보내면 된다.&lt;/p&gt;

&lt;p&gt;정석인 방법은 원본 프로젝트를 fork 해서 나의 레포지토리로 바꾼 후 수정을 거쳐 하는것이지만, 언제 스킨을 바꿀지 모르기에 위 방식대로 진행했다.&lt;/p&gt;

&lt;h4&gt;2. jekyll 테마 프로젝트를 구해서 설정하기&lt;/h4&gt;

&lt;p&gt;이 방법도 크게 다르지 않다. 단지 local repository의 설정이 다를뿐이다. 아래와 같이 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;jekyll 테마 프로젝트의 루트 디렉토리에서 git 저장소로 설정한다.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;블로그 repository 를 remote repository 로 등록시켜 준다.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 방식으로 진행했다.&lt;/p&gt;

&lt;p&gt;프로젝트의 루트 디렉토리로 shell 을 이동해 아래와 같이 명령을 입력해준다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git init&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;맨 처음 local repository로 설정해주는 명령어다. 인자가 따로 필요없이 그냥 저렇게만 쳐주면 된다.&lt;/p&gt;

&lt;p&gt;기존에 연결된 remote repository 가 없으니 바로 remote repository 를 설정해주면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote add origin &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;repository-url&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; // 본인 블로그 레포지토리 url 을 등록시켜 준다.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;여기까지 하면 local repository 를 설정하는건 끝이다.&lt;/p&gt;

&lt;h3&gt;jekyll 개발환경 설정하기&lt;/h3&gt;

&lt;p&gt;테마까지 로컬 저장소에 설정을 해놓았으니 컴퓨터에서 가상의 서버를 돌려가면서 본인의 포스팅을 확인할 환경을 만들어 주어야 한다. 물론 세팅을 하지않고 포스팅을 할수는 있다. 변경하고 push 하고, 확인하고, 변경후 push하고 확인하는 루틴이 계속될 것이다.&lt;/p&gt;

&lt;p&gt;하지만 위에서 말한 방법은 &lt;em&gt;매우&lt;/em&gt; 귀찮다. 쓰는대로 바로바로 진행이 되어야 편할 것이라 생각했기에 직접 jekyll 개발환경을 세팅하는 방향을 선택했다.&lt;/p&gt;

&lt;p&gt;리눅스 계열 OS 를 사용하는 개발자들은 대부분 구버젼의 Ruby 가 깔려 있겠지만 Windows 환경에서는 전혀 그런게 없다. 그래서 필자는 직접 설치 해주었다. &lt;a href=&quot;https://rubyinstaller.org&quot;&gt;Ruby installer&lt;/a&gt; 사이트에 들어가면 간단하게 isntaller 만 받아 설치를 해줄 수 있다. 설치 과정 중 환경변수(Path) 설정하는 옵션을 설정하면 간단하게 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;bundler&lt;/em&gt; 라는 툴을 깔아주어야 한다. 쉘에서 많이 사용하며 Ruby 의 불편한 의존성 관리를 도와주는 툴이라고 한다. jekyll 에서는 기본적으로 &lt;em&gt;bundler&lt;/em&gt; 를 사용하기 때문에 꼭 설치해주어야 한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;gem install bundler&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 jekyll 만 깔아주면 개발 환경 구축은 끝이다. 아래 명령어를 입력하자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;gem install jekyll&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3&gt;로컬 환경에서 블로그 확인하기&lt;/h3&gt;

&lt;p&gt;모든 세팅이 다 끝났다면 이제 블로그를 직접 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;jekyll serve&lt;/p&gt;

&lt;p&gt;위 명령어를 입력 후, 루프백 IP(127.0.0.1)나, localhost 도메인을 통해 블로그 서버를 직접 확인할 수 있다. 참고로 jekyll 은 4000 포트를 쓰니 참고 바란다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="jekyll" />
      
        <category term="makeblog" />
      

      
        <summary type="html">아는 지인이 좋다고 추천해서 jekyll+github 으로 블로그를 만들게 되었다. 한글로 된 자료가 그리 많지 않아 직접 기록해보려 한다. 개요 원리는 간단하다. GitHub 에서 jekyll 로 만들어진 블로그 백엔드 서비스(BaaS)를 지원하고, 사용자는 일정한 형식으로 레포지토리를 구성하면 블로그가 짠! 하고 나타난다. GitHub 에서 작업할 것들 순서는 아래와 같다. GitHub 계정이 없을 시 가입하기 GitHub 에 블로그 레포지토리 만들기 GitHub 가입하기 Github.com에서 가입하면 된다. 가입 절차는 간단하니 직접 해보라. GitHub 에 블로그 레포지토리 만들기 하나의 저장소를 만든다. 이때 중요한 것은 레포지토리 이름을 반드시 “(닉네임).githum.com” 으로 적어주여야 한다. 위와 같이 말이다. 우리는 원격 블로그 저장소를 만들었다. 이제 저장할 블로그 내용물을 만들 차례다. 블로그 만들기 Github 에서는 Ruby 로 만들어진 Jekyll 프레임워크 기반의 블로그를 지원한다. 즉 Jekyll 로 블로그를 만들어 GitHub 레포지토리에 올리면 잘 보인다. 만들어진 GitHub 레포지토리를 들어가보면 기본적으로 만들어진 블로그가 있다. 포스팅이 가능하고 기본적인 정보를 올릴 수 있다. 하지만 이 블로그는 만들어진 테마를 가져와서 세팅하는 것이기 때문에 내 멋대로 커스터마이징이 힘들다. 그렇다고 직접 스킨을 만들기에는.. 아무것도 모르는 사람이 처음부터 직접 만들기는 힘들다. 그러면 다른 사람이 만들어진걸 가져다 쓰는게 가장 빠르고 간편한 방법이다. 만들어진 테마 가져오기 우선 jekyll 테마 홈페이지이나 github에서 민들어진 jekyll 테마들을 찾아볼 수 있다. github 에서 가져오거나, jekyll 테마 홈페이지에서 직접 파일을 받아 쓸 수 있다. 1. GitHub 에서 테마 가져오기 여러 방법이 있지만 필자는 clone 해서 로컬 저장소를 만든다. 연결된 remote repository 를 블로그 repository 로 바꾼다. 위 방식으로 진행했다. GitHub 에서 원하는 jekyll 테마를 clone 해준다. 이 글을 쓸 무렵 필자는 whiteglass 테마를 사용했었다. git clone {other’s url} 위의 그림의 위치에서 url 을 복사해 세팅할 디렉토리에 위와 같이 입력해주면 된다. clone 을 한 후에는 가져온 remote repository 가 연결되어 있을 것이다. 일단 확인부터 해보자. 우선 프로젝트 루트 디렉토리로 이동해 shell 을 키고 아래 커맨드를 입력한다 git remote -v 그럼 아마도 아래와 같이 나올것이다. origin (other’s-url) (fetch) origin (other’s-url) (push) 잘 살펴보면 알겠지만 중간에 들어간 url 은 가져온 프로젝트의 url 이다. 변경하려면 다음과 같이 하면된다 git remote remote origin // 등록된 origin을 지운다. git remote add origin (repository-url) // 본인 블로그 레포지토리 url 을 등록시켜 준다. 그 다음 다시 등록된 remote repository 를 확인해보자. git remote -v 등록한 url 로 나오면 성공이다. 이제 연결을 해주었으니 원할 때 remote repository 로 보내면 된다. 정석인 방법은 원본 프로젝트를 fork 해서 나의 레포지토리로 바꾼 후 수정을 거쳐 하는것이지만, 언제 스킨을 바꿀지 모르기에 위 방식대로 진행했다. 2. jekyll 테마 프로젝트를 구해서 설정하기 이 방법도 크게 다르지 않다. 단지 local repository의 설정이 다를뿐이다. 아래와 같이 진행하면 된다. jekyll 테마 프로젝트의 루트 디렉토리에서 git 저장소로 설정한다. 블로그 repository 를 remote repository 로 등록시켜 준다. 위 방식으로 진행했다. 프로젝트의 루트 디렉토리로 shell 을 이동해 아래와 같이 명령을 입력해준다. git init 맨 처음 local repository로 설정해주는 명령어다. 인자가 따로 필요없이 그냥 저렇게만 쳐주면 된다. 기존에 연결된 remote repository 가 없으니 바로 remote repository 를 설정해주면 된다. git remote add origin (repository-url) // 본인 블로그 레포지토리 url 을 등록시켜 준다. 여기까지 하면 local repository 를 설정하는건 끝이다. jekyll 개발환경 설정하기 테마까지 로컬 저장소에 설정을 해놓았으니 컴퓨터에서 가상의 서버를 돌려가면서 본인의 포스팅을 확인할 환경을 만들어 주어야 한다. 물론 세팅을 하지않고 포스팅을 할수는 있다. 변경하고 push 하고, 확인하고, 변경후 push하고 확인하는 루틴이 계속될 것이다. 하지만 위에서 말한 방법은 매우 귀찮다. 쓰는대로 바로바로 진행이 되어야 편할 것이라 생각했기에 직접 jekyll 개발환경을 세팅하는 방향을 선택했다. 리눅스 계열 OS 를 사용하는 개발자들은 대부분 구버젼의 Ruby 가 깔려 있겠지만 Windows 환경에서는 전혀 그런게 없다. 그래서 필자는 직접 설치 해주었다. Ruby installer 사이트에 들어가면 간단하게 isntaller 만 받아 설치를 해줄 수 있다. 설치 과정 중 환경변수(Path) 설정하는 옵션을 설정하면 간단하게 사용이 가능하다. 이제 bundler 라는 툴을 깔아주어야 한다. 쉘에서 많이 사용하며 Ruby 의 불편한 의존성 관리를 도와주는 툴이라고 한다. jekyll 에서는 기본적으로 bundler 를 사용하기 때문에 꼭 설치해주어야 한다. gem install bundler 이제 jekyll 만 깔아주면 개발 환경 구축은 끝이다. 아래 명령어를 입력하자. gem install jekyll 로컬 환경에서 블로그 확인하기 모든 세팅이 다 끝났다면 이제 블로그를 직접 확인할 수 있다. jekyll serve 위 명령어를 입력 후, 루프백 IP(127.0.0.1)나, localhost 도메인을 통해 블로그 서버를 직접 확인할 수 있다. 참고로 jekyll 은 4000 포트를 쓰니 참고 바란다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Ue4 Class Tutorial</title>
      
      <link href="hrmrzizon.github.io/2017/03/06/ue4-class-tutorial/" rel="alternate" type="text/html" title="Ue4 Class Tutorial" />
      <published>2017-03-06T00:00:00+00:00</published>
      <updated>2017-03-06T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/06/ue4-class-tutorial</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/06/ue4-class-tutorial/">&lt;p&gt;이 글은 언리얼 엔진 4 교육을 위한 글입니다.&lt;/p&gt;

&lt;h2&gt;강의를 듣는 태도?&lt;/h2&gt;

&lt;p&gt;강사는 강의를 합니다. 아마 목청껏 떠들겁니다. 듣는 사람, 강의자를 위해 실례되는 행동은 삼가주시기 바랍니다. 실습 진행시에는 집중을 위해 잡담은 지양해주세요.&lt;/p&gt;

&lt;h2&gt;게임 엔진을 다루는 태도?&lt;/h2&gt;

&lt;p&gt;일반적인 게임 엔진은 많은 시스템을 구축해 놓고 그 시스템들 안에서 개발하는 방식을 채택합니다. 특히 언리얼 엔진 4 는 많은 시스템들이 존재합니다. 이 시스템들을 현명하게 활용해 게임을 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;간단하게 “현명하게 활용하는 방법” 을 살펴보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;엔진에 존재하는 기능을 활용하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;존재하는 기능을 활용하세요. 만약 문제가 있는 기능이라면 사용하지 말아야 겠지만 대부분의 기능들은 검증된 기능일 것입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;안정성이 보장된 기능을 사용하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;언리얼 엔진 4는 기능을 공식으로 지원하기 전에 실험 단계를 거칩니다. 공식으로 지원하는 기능만 사용해도 안정성을 보장받을 것 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;지원하는 문서들을 적극적으로 읽어보라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;설명이 필요 없네요.&lt;/p&gt;

&lt;h2&gt;이것들은 꼭 알고 있어야 합니다!!&lt;/h2&gt;

&lt;p&gt;언리얼 엔진 4 는 개발 언어를 C++ 과 Blueprint 를 사용합니다. 프로그램의 로직을 직접 짤 수 있어야 하고, C++ 의 문법들을 숙지하고 있어야 합니다. 언리얼 엔진 4 자체에서 C++ 문법을 확장한 부분도 있기 때문에 구분할 필요도 있구요.&lt;/p&gt;

&lt;h2&gt;도움될만한 지식들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;component base development&lt;/li&gt;
  &lt;li&gt;
    &lt;h2&gt;object oriented programming&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="edu" />
      
        <category term="ue4" />
      

      
        <summary type="html">이 글은 언리얼 엔진 4 교육을 위한 글입니다. 강의를 듣는 태도? 강사는 강의를 합니다. 아마 목청껏 떠들겁니다. 듣는 사람, 강의자를 위해 실례되는 행동은 삼가주시기 바랍니다. 실습 진행시에는 집중을 위해 잡담은 지양해주세요. 게임 엔진을 다루는 태도? 일반적인 게임 엔진은 많은 시스템을 구축해 놓고 그 시스템들 안에서 개발하는 방식을 채택합니다. 특히 언리얼 엔진 4 는 많은 시스템들이 존재합니다. 이 시스템들을 현명하게 활용해 게임을 만들어야 합니다. 간단하게 “현명하게 활용하는 방법” 을 살펴보겠습니다. 엔진에 존재하는 기능을 활용하라. 존재하는 기능을 활용하세요. 만약 문제가 있는 기능이라면 사용하지 말아야 겠지만 대부분의 기능들은 검증된 기능일 것입니다. 안정성이 보장된 기능을 사용하라. 언리얼 엔진 4는 기능을 공식으로 지원하기 전에 실험 단계를 거칩니다. 공식으로 지원하는 기능만 사용해도 안정성을 보장받을 것 입니다. 지원하는 문서들을 적극적으로 읽어보라. 설명이 필요 없네요. 이것들은 꼭 알고 있어야 합니다!! 언리얼 엔진 4 는 개발 언어를 C++ 과 Blueprint 를 사용합니다. 프로그램의 로직을 직접 짤 수 있어야 하고, C++ 의 문법들을 숙지하고 있어야 합니다. 언리얼 엔진 4 자체에서 C++ 문법을 확장한 부분도 있기 때문에 구분할 필요도 있구요. 도움될만한 지식들 component base development object oriented programming</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Ue4 Class Language Guide</title>
      
      <link href="hrmrzizon.github.io/2017/03/06/ue4-class-language-guide/" rel="alternate" type="text/html" title="Ue4 Class Language Guide" />
      <published>2017-03-06T00:00:00+00:00</published>
      <updated>2017-03-06T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/06/ue4-class-language-guide</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/06/ue4-class-language-guide/"></content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="edu" />
      
        <category term="ue4" />
      

      
        <summary type="html"></summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Ue4 Class Editor Basic</title>
      
      <link href="hrmrzizon.github.io/2017/03/06/ue4-class-editor-basic/" rel="alternate" type="text/html" title="Ue4 Class Editor Basic" />
      <published>2017-03-06T00:00:00+00:00</published>
      <updated>2017-03-06T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/06/ue4-class-editor-basic</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/06/ue4-class-editor-basic/">&lt;p&gt;이 글은 언리얼 엔진 4 교육을 위한 글입니다.&lt;/p&gt;

&lt;h2&gt;에디터 활용하기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/unityandue4.jpg&quot; alt=&quot;Unity 와 UE4&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="edu" />
      
        <category term="ue4" />
      

      
        <summary type="html">이 글은 언리얼 엔진 4 교육을 위한 글입니다. 에디터 활용하기</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Ue4 Vs Unity5</title>
      
      <link href="hrmrzizon.github.io/2017/03/05/ue4-vs-unity5/" rel="alternate" type="text/html" title="Ue4 Vs Unity5" />
      <published>2017-03-05T00:00:00+00:00</published>
      <updated>2017-03-05T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/05/ue4-vs-unity5</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/05/ue4-vs-unity5/">&lt;h3&gt;&lt;em&gt;이 글은 강의를 듣는 분들을 위해 작성된 심심풀이 땅콩같은 글임을 알립니다. &lt;strong&gt;절대&lt;/strong&gt; 논란의 여지가 되고 싶지 않습니다.&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Unity 로 게임 개발을 시작한지 약 2년이 넘었습니다. 이제 언리얼 엔진 4에 발을 들여놓으려고 합니다. 막 파악하면서 느낀 점을 적어보려고 합니다. 기존 개발을 해오던 분들과 의견이 다를수도 있으니 너그러운 마음으로 읽어주시길 바랍니다.&lt;/p&gt;

&lt;h2&gt;Overview 의 차이&lt;/h2&gt;

&lt;p&gt;문서를 읽으면서, 예제를 실험해보면서 느낀 점은, 둘의 스케일이 다르다는 것 입니다. Unity 는 비교적 간단하고 심플한 구조를 가진 반면, Unreal Engine 4 는 복잡하나 엔진 차원에서 많은 것을 지원하려 하는 것이 보입니다.&lt;/p&gt;

&lt;h3&gt;게임 시스템&lt;/h3&gt;

&lt;p&gt;게임 시스템을 보면, Unity 는 Scene 이란 GameObject 들의 계층 구조의 집합을 정의해놓고 모든 로직이 그 안에서 돌아가게 합니다. GameObject 들은 여러 Component 들을 붙이거나 뗄 수 있습니다. CBD 기반이지요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/Unity_HierarchyWindowCallout.png&quot; alt=&quot;Unity Hierarchy 뷰어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Unrealengine 에서는 레벨이란 단위안에 지형, 액터등 많은 것들을 가지고 사용자가 직접 로드하게 하거나 자동으로 로드해줍니다. 또한 여러 오브젝트들에 하위 컴포넌트나, Blueprint 스크립트를 붙일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;hrmrzizon.github.io/assets/unityandue4.jpg&quot; alt=&quot;Unity 와 UE4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unrealengine.com/latest/INT/GettingStarted/FromUnity/index.html&quot;&gt;Unrea Engine 4 For Unity Developers&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;개발 언어 환경&lt;/h3&gt;

&lt;p&gt;Unity 는 C#, JavaScript, Boo 이 세 가지 언어로 개발을 할 수 있습니다. 특히 가장 유명한 것은 C# 이겠지요. Mono 프로젝트의 공이 크다고 생각됩니다. 현 세대의 아주 강력한 Miscrosoft 에서 주도하는 언어 C# 을 모든 플랫폼에서 개발을 가능하게 만들고, Unity 에서는 이를 채택해 거의 모든 플랫폼의 개발이 가능해졌지요. 게다가 Mono 프로젝트를 이끌던 Xamarin 회사는 작년에 Miscrosoft 에서 인수했다는 소식이 있었습니다. 하여튼 Unity 는 C# 과 함께 성장할것 같이 보입니다.&lt;/p&gt;

&lt;p&gt;Unreal Engine 4 은 C++, Blueprint 로 개발이 가능합니다. C++ 은 OOP 언어의 대부분이 가지고 있는 리플렉션의 개념이 없습니다. 쓰더라도 전처리 과정에서만 가능하지요. 하지만 Unreal Engine 4 에서는 시스템을 덧붙여 가능하게 만들었습니다. 또한 코드 타이핑을 하지 않고 GUI 로 프로그래밍이 가능한 BluePrint 라는 강력한 방법도 지원합니다. 가장 놀라운 점은 이 기능들을 자체적으로 만든 것입니다.&lt;/p&gt;

&lt;h2&gt;Unreal Engine 4 의 장점?&lt;/h2&gt;

&lt;p&gt;Unreal Engine 4 의 장점 몇가지를 뽑아보겠습니다.&lt;/p&gt;

&lt;p&gt;첫 항목에 규모가 크다는 말을 했었습니다. 전문화된 툴이 정말 많습니다. 시네마틱을 제작하는 시퀀서, 3D 모델, 애니메이션 정보들을 편집 가능한 스켈레톤 시스템, AI 를 위한 비헤이비어 트리 시스템 등 많은 기능들을 지원합니다.&lt;/p&gt;

&lt;p&gt;두번째로는 엔진 자체가 오픈 소스이고, 엔진 구현에 관한 문서들이 자세하게 잘 설명되어 있습니다. 오픈 소스인 만큼 엔진 자체에 문제가 생겼을 시 직접 소스코드를 수정해 사용이 가능하고, GitHub 페이지를 사용해 문제를 제기할 수 있어 “공생” 이라는 슬로건에 알맞는 정책입니다. 상세한 문서화는 Unreal Engine 4 를 처음 접하는 개발자도, 개발에 쓰고있는 개발자들에게도 많은 도움을 줍니다.&lt;/p&gt;

&lt;p&gt;마지막은 언리얼 데브 그랜트 라는 정책이 있습니다. 이는 Unreal Engine 으로 개발된 가능성 있는 게임들을 신청받아 한화로 약 5백만원에서 5천만원 사이의 지원금을 보조하는 정책입니다. 지원금의 사용은 자유로우며 지적재산권도 개발사가 소유합니다. 아무런 권리도 가져가지 않고 지원하는 것이지요.&lt;/p&gt;

&lt;h2&gt;마지막으로&lt;/h2&gt;

&lt;p&gt;Unreal Engine 4 는 특별한 움직임은 보이지 않습니다. 하지만 여태까지 했던 것들만 해도 정말 대단합니다. 약 2,3달 간격의 버젼업은 무릎을 탁 치다 못해 탈골될 지경이지요. 자체적으로 보유한 기술을 따지면.. 엄청난 가치들이 있습니다.&lt;/p&gt;

&lt;p&gt;Unity 는 2017 버젼과 Unity5 마지막 버젼을 앞에 두고 있습니다. 이전에 릴리즈된 Unity 5.5 버젼에서는 꽤 발전된 모습을 보여주었습니다. 가장 돋보이는 점은 Mono C# 컴파일러 버젼을 Mono 4.4 버젼으로 업그레이드 한 것입니다. 드디어 4버젼부터 가져오던 Mono 프레임워크 문제를 해결하려 하는게 보입니다.&lt;/p&gt;

&lt;p&gt;둘다 장단점이 있지만 여태까지 행보를 보면 Unreal Engine 4 가 우세하다고 봅니다. 표면적으로 드러난 기술력, 자본만 보아도 엔진 자체만 보더라도 말이지요. 하지만 앞일은 모르니 조금 더 지켜봐야할 필요는 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="edu" />
      
        <category term="ue4" />
      

      
        <summary type="html">이 글은 강의를 듣는 분들을 위해 작성된 심심풀이 땅콩같은 글임을 알립니다. 절대 논란의 여지가 되고 싶지 않습니다. Unity 로 게임 개발을 시작한지 약 2년이 넘었습니다. 이제 언리얼 엔진 4에 발을 들여놓으려고 합니다. 막 파악하면서 느낀 점을 적어보려고 합니다. 기존 개발을 해오던 분들과 의견이 다를수도 있으니 너그러운 마음으로 읽어주시길 바랍니다. Overview 의 차이 문서를 읽으면서, 예제를 실험해보면서 느낀 점은, 둘의 스케일이 다르다는 것 입니다. Unity 는 비교적 간단하고 심플한 구조를 가진 반면, Unreal Engine 4 는 복잡하나 엔진 차원에서 많은 것을 지원하려 하는 것이 보입니다. 게임 시스템 게임 시스템을 보면, Unity 는 Scene 이란 GameObject 들의 계층 구조의 집합을 정의해놓고 모든 로직이 그 안에서 돌아가게 합니다. GameObject 들은 여러 Component 들을 붙이거나 뗄 수 있습니다. CBD 기반이지요. Unrealengine 에서는 레벨이란 단위안에 지형, 액터등 많은 것들을 가지고 사용자가 직접 로드하게 하거나 자동으로 로드해줍니다. 또한 여러 오브젝트들에 하위 컴포넌트나, Blueprint 스크립트를 붙일 수 있습니다. Unrea Engine 4 For Unity Developers 개발 언어 환경 Unity 는 C#, JavaScript, Boo 이 세 가지 언어로 개발을 할 수 있습니다. 특히 가장 유명한 것은 C# 이겠지요. Mono 프로젝트의 공이 크다고 생각됩니다. 현 세대의 아주 강력한 Miscrosoft 에서 주도하는 언어 C# 을 모든 플랫폼에서 개발을 가능하게 만들고, Unity 에서는 이를 채택해 거의 모든 플랫폼의 개발이 가능해졌지요. 게다가 Mono 프로젝트를 이끌던 Xamarin 회사는 작년에 Miscrosoft 에서 인수했다는 소식이 있었습니다. 하여튼 Unity 는 C# 과 함께 성장할것 같이 보입니다. Unreal Engine 4 은 C++, Blueprint 로 개발이 가능합니다. C++ 은 OOP 언어의 대부분이 가지고 있는 리플렉션의 개념이 없습니다. 쓰더라도 전처리 과정에서만 가능하지요. 하지만 Unreal Engine 4 에서는 시스템을 덧붙여 가능하게 만들었습니다. 또한 코드 타이핑을 하지 않고 GUI 로 프로그래밍이 가능한 BluePrint 라는 강력한 방법도 지원합니다. 가장 놀라운 점은 이 기능들을 자체적으로 만든 것입니다. Unreal Engine 4 의 장점? Unreal Engine 4 의 장점 몇가지를 뽑아보겠습니다. 첫 항목에 규모가 크다는 말을 했었습니다. 전문화된 툴이 정말 많습니다. 시네마틱을 제작하는 시퀀서, 3D 모델, 애니메이션 정보들을 편집 가능한 스켈레톤 시스템, AI 를 위한 비헤이비어 트리 시스템 등 많은 기능들을 지원합니다. 두번째로는 엔진 자체가 오픈 소스이고, 엔진 구현에 관한 문서들이 자세하게 잘 설명되어 있습니다. 오픈 소스인 만큼 엔진 자체에 문제가 생겼을 시 직접 소스코드를 수정해 사용이 가능하고, GitHub 페이지를 사용해 문제를 제기할 수 있어 “공생” 이라는 슬로건에 알맞는 정책입니다. 상세한 문서화는 Unreal Engine 4 를 처음 접하는 개발자도, 개발에 쓰고있는 개발자들에게도 많은 도움을 줍니다. 마지막은 언리얼 데브 그랜트 라는 정책이 있습니다. 이는 Unreal Engine 으로 개발된 가능성 있는 게임들을 신청받아 한화로 약 5백만원에서 5천만원 사이의 지원금을 보조하는 정책입니다. 지원금의 사용은 자유로우며 지적재산권도 개발사가 소유합니다. 아무런 권리도 가져가지 않고 지원하는 것이지요. 마지막으로 Unreal Engine 4 는 특별한 움직임은 보이지 않습니다. 하지만 여태까지 했던 것들만 해도 정말 대단합니다. 약 2,3달 간격의 버젼업은 무릎을 탁 치다 못해 탈골될 지경이지요. 자체적으로 보유한 기술을 따지면.. 엄청난 가치들이 있습니다. Unity 는 2017 버젼과 Unity5 마지막 버젼을 앞에 두고 있습니다. 이전에 릴리즈된 Unity 5.5 버젼에서는 꽤 발전된 모습을 보여주었습니다. 가장 돋보이는 점은 Mono C# 컴파일러 버젼을 Mono 4.4 버젼으로 업그레이드 한 것입니다. 드디어 4버젼부터 가져오던 Mono 프레임워크 문제를 해결하려 하는게 보입니다. 둘다 장단점이 있지만 여태까지 행보를 보면 Unreal Engine 4 가 우세하다고 봅니다. 표면적으로 드러난 기술력, 자본만 보아도 엔진 자체만 보더라도 말이지요. 하지만 앞일은 모르니 조금 더 지켜봐야할 필요는 있습니다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Ue4 Class Equipment</title>
      
      <link href="hrmrzizon.github.io/2017/03/05/ue4-class-equipment/" rel="alternate" type="text/html" title="Ue4 Class Equipment" />
      <published>2017-03-05T00:00:00+00:00</published>
      <updated>2017-03-05T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/05/ue4-class-equipment</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/05/ue4-class-equipment/">&lt;p&gt;이 글은 언리얼 엔진 4 교육을 위한 글입니다.&lt;/p&gt;

&lt;h2&gt;강의 환경&lt;/h2&gt;

&lt;h3&gt;강의 자료&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://hrmrzizon.github.io&quot;&gt;http://hrmrzizon.github.io&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unrealengine.com/latest/KOR/index.html&quot;&gt;언리얼 엔진 4 웹 문서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unrealengine.com/latest/KOR/Resources/index.html&quot;&gt;언리얼 엔진 4 에서 지원하는 예제들&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;추천 하드웨어 사양&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;OS&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;CPU&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Ram&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;여유 디스크 공간&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;windows 7,8,10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Intell 혹은 AMD, 쿼드 코어, 2.5GHz 이상&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8GB 이상&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100GB 이상&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;사양 확인하기 : &lt;a href=&quot;http://www.cpuid.com/softwares/cpu-z.html&quot;&gt;CPU-Z 다운로드 페이지&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;소프트웨어 설치&lt;/h3&gt;

&lt;p&gt;우선 &lt;a href=&quot;https://www.unrealengine.com/ko&quot;&gt;언리얼 엔진 4 공식 홈페이지&lt;/a&gt;에 접속해 전용 런쳐를 다운로드 합니다. 홈페이지 우측 상단에 링크가 있습니다. 런처 설치는 오래 걸리지 않습니다.&lt;/p&gt;

&lt;p&gt;런처 설치가 끝나면 엔진을 설치할 수 있습니다. &lt;strong&gt;그런데 주의할 사항이 있습니다.&lt;/strong&gt; 엔진과 앞으로의 엔진 사용은 꽤 많은 공간을 요구하기 때문에 디스크 여유 공간이 많이 있어야 합니다. 현재 4.15 버젼이 차지하는 디스크 공간은 &lt;strong&gt;21.9GB&lt;/strong&gt; 입니다. 앞으로 디스크 렌더 캐싱, 프로젝트 등 디스크 공간을 요구하는 일이 많아질 것입니다. 또한 빠른 설치를 위해 원활한 네트워크 환경에서 설치를 진행하시길 바랍니다.&lt;/p&gt;

&lt;p&gt;이제 런처에서 엔진 바이너리를 설치합니다. 현재 최신 버젼인 4.15 버젼을 설치해줍니다.&lt;/p&gt;

&lt;p&gt;엔진 설치가 끝나거나 환경이 원활하다면 &lt;a href=&quot;https://www.visualstudio.com/ko/downloads/&quot;&gt;Visual Studio 2015 다운로드 페이지&lt;/a&gt;에서 다운로드 받아 설치합니다. IDE도 필요하지만 대부분 Windows 환경에서 실행하기 때문에 Windows SDK도 설치해주어야 합니다. 역시 많은 디스크 공간을 요구합니다. 또한 원활한 네트워크 환경에서 진행하길 바랍니다.&lt;/p&gt;

&lt;h3&gt;설치하면서 읽어볼 거리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unrealengine.com/latest/KOR/Engine/Performance/Scalability/ScalabilityAndYou/index.html&quot;&gt;Scalability, 엔진 퀄리티와 개발자&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      
        <category term="edu,ue4" />
      

      
        <category term="edu" />
      
        <category term="ue4" />
      

      
        <summary type="html">이 글은 언리얼 엔진 4 교육을 위한 글입니다. 강의 환경 강의 자료 http://hrmrzizon.github.io 언리얼 엔진 4 웹 문서 언리얼 엔진 4 에서 지원하는 예제들 추천 하드웨어 사양 OS CPU Ram 여유 디스크 공간 windows 7,8,10 Intell 혹은 AMD, 쿼드 코어, 2.5GHz 이상 8GB 이상 100GB 이상 사양 확인하기 : CPU-Z 다운로드 페이지 소프트웨어 설치 우선 언리얼 엔진 4 공식 홈페이지에 접속해 전용 런쳐를 다운로드 합니다. 홈페이지 우측 상단에 링크가 있습니다. 런처 설치는 오래 걸리지 않습니다. 런처 설치가 끝나면 엔진을 설치할 수 있습니다. 그런데 주의할 사항이 있습니다. 엔진과 앞으로의 엔진 사용은 꽤 많은 공간을 요구하기 때문에 디스크 여유 공간이 많이 있어야 합니다. 현재 4.15 버젼이 차지하는 디스크 공간은 21.9GB 입니다. 앞으로 디스크 렌더 캐싱, 프로젝트 등 디스크 공간을 요구하는 일이 많아질 것입니다. 또한 빠른 설치를 위해 원활한 네트워크 환경에서 설치를 진행하시길 바랍니다. 이제 런처에서 엔진 바이너리를 설치합니다. 현재 최신 버젼인 4.15 버젼을 설치해줍니다. 엔진 설치가 끝나거나 환경이 원활하다면 Visual Studio 2015 다운로드 페이지에서 다운로드 받아 설치합니다. IDE도 필요하지만 대부분 Windows 환경에서 실행하기 때문에 Windows SDK도 설치해주어야 합니다. 역시 많은 디스크 공간을 요구합니다. 또한 원활한 네트워크 환경에서 진행하길 바랍니다. 설치하면서 읽어볼 거리 Scalability, 엔진 퀄리티와 개발자</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Make Jekyll+github Blog 2</title>
      
      <link href="hrmrzizon.github.io/2017/03/05/make-jekyll+github-blog-2/" rel="alternate" type="text/html" title="Make Jekyll+github Blog 2" />
      <published>2017-03-05T00:00:00+00:00</published>
      <updated>2017-03-05T00:00:00+00:00</updated>
      <id>hrmrzizon.github.io/2017/03/05/make-jekyll+github-blog-2</id>
      <content type="html" xml:base="hrmrzizon.github.io/2017/03/05/make-jekyll+github-blog-2/">&lt;p&gt;아는 지인이 좋다고 추천해서 jekyll+github 으로 블로그를 만들게 되었다.
한글로 된 자료가 그리 많지 않아 직접 기록해보려 한다.&lt;/p&gt;

&lt;h3&gt;atom 에디터 설정하기&lt;/h3&gt;

&lt;p&gt;에디터 다운 받기~&lt;/p&gt;

&lt;h2&gt;댓글 기능 붙이기&lt;/h2&gt;

&lt;p&gt;간단하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://disqus.com/&quot;&gt;disqus 홈페이지&lt;/a&gt; 에 가입한다.&lt;/li&gt;
  &lt;li&gt;가입할 때 만든 페이지 관리 창으로 간다.&lt;/li&gt;
  &lt;li&gt;Installing disqus 를 선택 후 jekyll 을 선택한다.&lt;/li&gt;
  &lt;li&gt;포스팅 위의 header 정보에 “comments: true” 가 되어 있어야 댓글이 나온다.&lt;/li&gt;
  &lt;li&gt;그 다음 Embeded Code 를 _includes 폴더에 파일로 하나 만들어 둔다.&lt;/li&gt;
  &lt;li&gt;그리고 post.html 에 {\% include (파일이름) \%} 이 코드를 원하는 곳에 넣어주면 작동한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;travis-ci 설정하기&lt;/h2&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-hyeok Kim</name>
          
          
        </author>
      

      

      
        <category term="jekyll" />
      
        <category term="makeblog" />
      

      
        <summary type="html">아는 지인이 좋다고 추천해서 jekyll+github 으로 블로그를 만들게 되었다. 한글로 된 자료가 그리 많지 않아 직접 기록해보려 한다. atom 에디터 설정하기 에디터 다운 받기~ 댓글 기능 붙이기 간단하다. disqus 홈페이지 에 가입한다. 가입할 때 만든 페이지 관리 창으로 간다. Installing disqus 를 선택 후 jekyll 을 선택한다. 포스팅 위의 header 정보에 “comments: true” 가 되어 있어야 댓글이 나온다. 그 다음 Embeded Code 를 _includes 폴더에 파일로 하나 만들어 둔다. 그리고 post.html 에 {\% include (파일이름) \%} 이 코드를 원하는 곳에 넣어주면 작동한다. travis-ci 설정하기</summary>
      

      
      
    </entry>
  
  
</feed>
