<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko">
  <generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator>
  
  
  <link href="https://hrmrzizon.github.io/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hrmrzizon.github.io/" rel="alternate" type="text/html" hreflang="ko" />
  <updated>2017-04-24T02:46:02+00:00</updated>
  <id>https://hrmrzizon.github.io//</id>

  
    <title type="html">Appocrypha</title>
  

  
    <subtitle>Software 정보를 취급합니다.</subtitle>
  

  
    <author>
        <name>Su-Hyeok Kim</name>
      
      
    </author>
  

  
  
    <entry>
      
      <title type="html">Usage Of Coroutine</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/21/usage-of-coroutine/" rel="alternate" type="text/html" title="Usage Of Coroutine" />
      <published>2017-04-21T00:00:00+00:00</published>
      <updated>2017-04-21T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/21/usage-of-coroutine</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/21/usage-of-coroutine/">&lt;p&gt;Unity 는 코루틴이라는 괴상한(?) 코딩 방식을 지원한다. 맨 처음에 발견했을 때는 Synchronize 한 코딩 방식에 익숙해져 있어 상당히 낯설고 적응이 안됐다. 하지만 응용 범위를 늘려가다보니 상당히 편한 코딩 방식이라는 것을 깨닳았다. 한번 코루틴에 대해 알아보자.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2&gt;Coroutine 사용하기&lt;/h2&gt;

&lt;p&gt;아래 예제를 보자. 몇초를 기다리는 로직을 코루틴을 사용해 구현했다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait3Second&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait3Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Start.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;After 3 second.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait3Second&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;시작 후 3초를 기다리는 간단한 코드다. 이 코드는 시작할 때 로그가 출력되고, 3초가 지난 후에 로그를 출력한다. 그리고 3초가 지가가기 전에 스페이스바를 누르면 실행하던 코루틴을 취소한다. &lt;strong&gt;StartCoroutine&lt;/strong&gt; 으로 코루틴 함수를 실행하면 코드에서 &lt;em&gt;yield return&lt;/em&gt; 구문이 나오기 전까지 실행하다가 &lt;em&gt;yield return&lt;/em&gt; 에서 반환하는 데이터에 따라 기다리기를 끝날때까지 반복한다. 아래 그림을 보면 이해가 쉬울 것 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/common_coroutine_execute.png&quot; alt=&quot;coroutine execute&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코루틴의 동작을 매우 간단하게 표현한 그림이다. 그런데 코루틴은 위 예제에서 호출한 방식 말고도 다른 방식으로 제어가 가능하다. 아래 예제를 살펴보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;Coroutine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait Start: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait Mid: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ~ &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait End: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ~ &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Start] \&quot;Wait\&quot; by method call and store enumerator, coroutine&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Start] \&quot;Wait\&quot; by method name and store coroutine&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Stop] \&quot;Wait\&quot; by using enumerator&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Stop] \&quot;Wait\&quot; by using method name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Stop] \&quot;Wait\&quot; by using coroutine&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;StopAllCoroutines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Stop] all \&quot;Wait\&quot; context&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 예제는 A, S 키를 누르면 &lt;em&gt;Wait&lt;/em&gt; 코루틴을 실행시키고, Z,X,C,V 키를 누르면 실행하던 &lt;em&gt;Wait&lt;/em&gt; 코루틴을 멈추는 코드로 되어 있다.&lt;/p&gt;

&lt;p&gt;조금 더 자세하게 설명하자면, 실행한 방식과 멈추는 방식이 비슷한 제어 방법은 두가지가 있다. 하나는 메소드를 실행시켜 나온 &lt;strong&gt;IEnumerator&lt;/strong&gt; 객체를 통하여 실행하고(A키) 멈추는(Z키) 방법, 나머지 하나는 메소드 이름을 통하여 코루틴을 실행시키고(S키) 멈추는(X키) 방법이 있다.&lt;/p&gt;

&lt;p&gt;다만 이름을 통해서 코루틴을 실행하는 방법은 같은 이름의 메소드가 존재할 때는 코드의 위쪽에 있는 것을 실행하고, 이름을 통해 코루틴을 멈추는 방법은 같은 메소드로 호출한 코루틴을 전부 멈추기 때문에 주의하기 바란다.&lt;/p&gt;

&lt;p&gt;그리고 코루틴을 멈추는 방법 중 두가지가 더 있는데, 하나는 MonoBehaviour 인스턴스에서 실행한 코루틴을 전부 멈추는 방법, 나머지 하나는 &lt;strong&gt;StartCoroutine&lt;/strong&gt; 이 반환한 객체 &lt;strong&gt;Coroutine&lt;/strong&gt; 을 사용하여 실행한 코루틴 하나를 멈추는 방법이다. &lt;strong&gt;Coroutine&lt;/strong&gt; 객체는 단지 코루틴을 실행했을 때, 실행한 코루틴을 제어하기 위해 사용하는 객체다. 이 &lt;strong&gt;Coroutine&lt;/strong&gt; 객체를 이용해 코루틴을 멈추는게 가장 좋은 듯 하다. &lt;strong&gt;IEnumerator&lt;/strong&gt; 객체를 통하여 멈추는 방식은 중간에 &lt;em&gt;yield return&lt;/em&gt; 으로 반환한 객체를 확인 가능하고 직접 제어가 가능하기 때문에 꼭 참조해야할 일이 아니면 &lt;strong&gt;Coroutine&lt;/strong&gt; 객체를 사용하는게 안전할 것이다.&lt;/p&gt;

&lt;p&gt;또한 &lt;strong&gt;Coroutine&lt;/strong&gt; 객체는 멈추는 역할 말고도 다른 역할 한가지를 더 수행할 수 있다. 바로 코루틴을 중첩하는 경우에 사용가능한데, 위 예제에 아래 코드를 보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Coroutine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;justWait&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;justWait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드는 맨 처음 &lt;em&gt;Wait&lt;/em&gt; 메소드를 &lt;strong&gt;StartCoroutine&lt;/strong&gt; 을 사용하여 실행한 후, 반환한 &lt;strong&gt;Coroutine&lt;/strong&gt; 객체를 &lt;em&gt;yield return&lt;/em&gt; 으로 반환해주면 해당 코루틴이 끝날 때까지 기다려준다. 그리고 기다리는 코루틴이 끝나면 크기를 1.1배 늘려주는 루틴을 계속 반복한다. 위와 같이 &lt;strong&gt;WaitForSeconds&lt;/strong&gt; 나, 실행된 코루틴 객체를 넣어주면 해당 루틴이 끝날 때까지 기다려 주기 때문에, 프레임별로 코딩을 하는 방식에서 시간과 여러 타이밍을 생각하는 비동기적 방식의 코딩이 가능하다. 이는 Unity 의 C# 스크립팅에 혁신적인 변화를 주었다. 그리고 Update 의 사용을 적게 해주기 때문에 Update 콜을 적게해주어 아주 조금의 퍼포먼스 향상도 기대할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 코루틴은 숙달되지 않은 프로그래머가 쓰게되면 그다지 좋은 코딩 방식은 아니다. 코루틴을 처음 접하게 되는 프로그래머는 기존의 프레임별로 실행하던 코드에서 Unity 에서만 쓰이는 코루틴의 개념을 생각하면서 코딩을 해야하기 때문에 상당히 혼란스러울 것이다. 또한 코루틴은 비동기 시스템이기 때문에 Multi Threading 이라 착각하는 경우가 있는데, 단지 Multi tasking 일 뿐이고, 같은 쓰레드에서 실행된다. 아래 그림을 보면 알 수 있을것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity-callback-order.png&quot; alt=&quot;Unity callback order&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결국 단일 쓰레드에서 실행되는 시스템이면 코루틴을 쓴다고해서 혁신적인 성능향상을 기대하기는 힘들다. 단지 다른 Update 방식이라 생각하면 될듯하다.&lt;/p&gt;

&lt;h2&gt;Unity 에서 지원하는 코루틴 대기 제어 기능들&lt;/h2&gt;

&lt;p&gt;코루틴을 사용할 때 기다려야 할 때 여러 기능들을 제공한다.&lt;/p&gt;

&lt;p&gt;대표적인 예는 시간을 기다리는 기능들이다. &lt;strong&gt;WaitForSeconds&lt;/strong&gt; 와 &lt;strong&gt;WaitForSecondsRealtime&lt;/strong&gt; 가 있는데 게임 어플리케이션의 시간과 실제 시간을 기다리는 기능이다. 위에서 &lt;strong&gt;WaitForSeconds&lt;/strong&gt; 를 사용했다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait Start: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait Mid: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ~ &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait End: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ~ &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, number: &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 콜백이 실행되는 그림을 살펴보면 Game Logic 레이어에서 대부분 멈춰준다. 이 타이밍은 &lt;em&gt;Update&lt;/em&gt; 가 호출된 후, &lt;em&gt;LateUpdate&lt;/em&gt; 가 호출되기 전인데 누군가는 이 시점 말고 다른 시점에 코루틴을 멈추고 싶을 수도 있다. 그래서 Unity 에서는 다른 두 타이밍에 기다림을 멈추는 기능이 있다. &lt;strong&gt;WaitForFixedUpdate&lt;/strong&gt; 과 &lt;strong&gt;WaitForEndOfFrame&lt;/strong&gt; 인데,  &lt;strong&gt;WaitForFixedUpdate&lt;/strong&gt; 는 &lt;em&gt;FixedUpdate&lt;/em&gt; 들이 호출된 후 타이밍에 멈춰주는 기능으로써 물리 기반 기능과 같은 타이밍을 공유하고 싶을 때 사용하면 된다. &lt;strong&gt;WaitForEndOfFrame&lt;/strong&gt; 은 한 프레임의 모든 처리가 끝난 후까지 기다려주는 기능으로써 무언가 후처리를 할 때 사용해주면 된다.&lt;/p&gt;

&lt;p&gt;또한 사용자가 멈추고 싶은 타이밍에 멈추는 경우도 필요할 것이다. 그래서 두가지 논리적인 조건이 충족할 때 멈춰주는 기능도 있다. &lt;strong&gt;WaitUntil&lt;/strong&gt; 과 &lt;strong&gt;WaitWhile&lt;/strong&gt; 인데, 단순하게 &lt;em&gt;Func&amp;lt;bool&amp;gt;&lt;/em&gt; 델리게이트만 받아 참이냐, 거짓이냐에 따라서 기다림을 제어한다. &lt;strong&gt;WaitUntil&lt;/strong&gt; 은 델리게이트가 반환하는 값이 &lt;em&gt;false&lt;/em&gt; 일 때 다음으로 넘어가고, &lt;strong&gt;WaitWhile&lt;/strong&gt; 델리게이트가 반환하는 값이 &lt;em&gt;true&lt;/em&gt; 일 때 다음으로 넘어가기 된다.&lt;/p&gt;

&lt;p&gt;마지막으로 프로토콜로 통신하는 기능을 사용할 때 사용하는 &lt;strong&gt;WWW&lt;/strong&gt; 라는 특수한 제어 객체가 있다. 이는 보통 &lt;em&gt;http&lt;/em&gt; 통신을 해서 무언가 받아올 때 사용한다. 아래 예제가 대표적인 예시다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getGoogle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;WWW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;google&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WWW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://www.google.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;보통은 위 예제처럼 &lt;em&gt;http&lt;/em&gt; 통신을 해서 데이터를 가져올 때 사용한다. 로컬 파일 시스템이나 ftp 프로토콜도 가능하다. 자세한 사항은 &lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/WWW.html&quot;&gt;Unity WWW&lt;/a&gt; 여기서 확인하라.&lt;/p&gt;

&lt;p&gt;이렇게 Unity 에서 기다림을 제어하는 기능에 대해서 알아보았다. 하지만 이 기능들 가지고는 약간 부족한 부분이 있을 것이다. 이를 위해 Unity 에서는 &lt;strong&gt;CustomYieldInstruction&lt;/strong&gt; 이라는 기능을 제공한다.&lt;/p&gt;

&lt;h2&gt;CustomYieldInstruction 를 사용해서 커스터마이징하기&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CustomYieldInstruction&lt;/strong&gt; 을 통해 기다리는 기능을 상당히 간단하게 구현이 가능하다. &lt;strong&gt;CustomYieldInstruction&lt;/strong&gt; 는 &lt;em&gt;keepWaiting&lt;/em&gt; 이라는 abstract 프로퍼티를 통해 값이 &lt;em&gt;false&lt;/em&gt; 일 때는 기다리고, &lt;em&gt;true&lt;/em&gt; 일 때는 넘어가는 간단한 &lt;strong&gt;IEnumerator&lt;/strong&gt; 구현체다. 즉 &lt;strong&gt;CustomYieldInstruction&lt;/strong&gt; 을 상속받아 &lt;em&gt;keepWaiting&lt;/em&gt; 프로퍼티만 구현하면 끝이다. 아래 transform 의 scale 을 검사해서 일정 값을 초과하게 되면 다음으로 넘어가는 기능을 아래 예제에 첨부했다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ScaleOverYieldInstruction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CustomYieldInstruction&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ScaleOverYieldInstruction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepWaiting&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;구현 자체는 상당히 간단하다. 일반적인 클래스 인스턴스 처럼 생성자에서 초기화를 해주고, &lt;em&gt;keepWaiting&lt;/em&gt; 구현을 한 것이 보인다. 다만 조금 의문이 드는점은 &lt;em&gt;keepWaiting&lt;/em&gt; 은 도대체 언제 호출이 되냐는 것이다.&lt;/p&gt;

&lt;p&gt;사실 위의 소개한 기능중에 CustomYieldInstruction 이용해 구현한 기능이 있다. &lt;strong&gt;WaitUntil&lt;/strong&gt; 과 &lt;strong&gt;WaitWhile&lt;/strong&gt; 이다.
&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html&quot;&gt;Unity CustomYieldInstruction&lt;/a&gt; 을 보면 Update 가 호출된 후, LateUpdate 를 호출하기 전 즉 타이밍이 적혀있는 그림에서 보았을 떄 GameLogic 레이어에서 체크가 된다는 것을 알 수 있다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/Coroutines.html&quot;&gt;Unity 코루틴 메뉴얼&lt;/a&gt;
&amp;lt;!–&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/system.collections.ienumerator.aspx&quot;&gt;MSDN : IEnumerator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/65zzykke.aspx&quot;&gt;MSDN : 반복기 사용&lt;/a&gt;
–&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Coroutine.html&quot;&gt;Unity Coroutine ref&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html&quot;&gt;Unity CustomYieldInstruction ref&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/YieldInstruction.html&quot;&gt;Unity YieldInstruction ref&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://unityindepth.tistory.com/21&quot;&gt;Unity In Depth 코루틴 글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/WWW.html&quot;&gt;Unity WWW ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
ok  유니티의 기본적인 코루틴 사용법? StopCoroutine:Coroutine
ok  장단점?
ok  구현 클래스 예시 WaitUntil, WaitWhile
~~  CustomYieldInstruction : keepwaiting 을 씀, Update 다 된 이후, LateUpdate 하기 전에 체크함
xx  C# 에서의 코드 블록 지원, 코드에서 사용되는 IEnumerator 의 구조
--&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      
        <category term="c#" />
      

      

      
        <summary type="html">Unity 는 코루틴이라는 괴상한(?) 코딩 방식을 지원한다. 맨 처음에 발견했을 때는 Synchronize 한 코딩 방식에 익숙해져 있어 상당히 낯설고 적응이 안됐다. 하지만 응용 범위를 늘려가다보니 상당히 편한 코딩 방식이라는 것을 깨닳았다. 한번 코루틴에 대해 알아보자.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Custom Property Drawer Tooltip</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/19/custom-property-drawer-tooltip/" rel="alternate" type="text/html" title="Custom Property Drawer Tooltip" />
      <published>2017-04-19T00:00:00+00:00</published>
      <updated>2017-04-19T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/19/custom-property-drawer-tooltip</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/19/custom-property-drawer-tooltip/">&lt;p&gt;CustomPropertyDrawer 를 사용할 때 필드에 설정한 &lt;strong&gt;Tooltip&lt;/strong&gt; 정보가 전달이 안될 때가 있다. 이때는 아래와 같이 하면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;BeginProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// label 대신 content 를 에디터 코드에 넣어줌.
&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;EndProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;OnGUI 를 통해 넘어오는 &lt;strong&gt;label&lt;/strong&gt; 파라미터에는 단지 텍스트만 들어가있어 조금 더 살펴보니 위의 방법처럼 해당 프로퍼티의 &lt;strong&gt;GUIContent&lt;/strong&gt; 를 가져오는 방법이 있었다. 저 반환된 &lt;strong&gt;GUIContent&lt;/strong&gt; 는 어디에서도 사용가능하니 유용하게 쓰일듯하다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      

      

      
        <summary type="html">CustomPropertyDrawer 를 사용할 때 필드에 설정한 Tooltip 정보가 전달이 안될 때가 있다. 이때는 아래와 같이 하면 된다. public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { GUIContent content = EditorGUI.BeginProperty(position, label, property); // label 대신 content 를 에디터 코드에 넣어줌. EditorGUI.EndProperty(); } OnGUI 를 통해 넘어오는 label 파라미터에는 단지 텍스트만 들어가있어 조금 더 살펴보니 위의 방법처럼 해당 프로퍼티의 GUIContent 를 가져오는 방법이 있었다. 저 반환된 GUIContent 는 어디에서도 사용가능하니 유용하게 쓰일듯하다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Usage Of Attributes In Unity</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/12/usage-of-attributes-in-unity/" rel="alternate" type="text/html" title="Usage Of Attributes In Unity" />
      <published>2017-04-12T00:00:00+00:00</published>
      <updated>2017-04-12T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/12/usage-of-attributes-in-unity</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/12/usage-of-attributes-in-unity/">&lt;p&gt;C# 문법은 클래스, 구조체, 열거형, 멤버 변수, 메소드등 여러 타입에 표시를 하는 기능을 제공한다. 이 표시들을 C# 문법에서는 &lt;strong&gt;Attribute&lt;/strong&gt;(속성) 라고 칭한다. 그리고 이 속성을 사용하여 Unity 에서는 많은 기능들을 제공한다. 아래 우리가 가장 많이 볼만한 속성을 사용한 예제가 있다.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2&gt;Property 직렬화 제어&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Unity 시스템에 데이터를 직렬화해 멤버변수 초기값을 지정한다.
&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[UnityEngine.SerializeField]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limitCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 직렬화를 못하게 한다.
&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[System.NonSerialized]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gameCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unity 스크립팅 시스템은 따로 멤버 직렬화에 대한 속성을 지정하지 않으면 접근 제한자(public, protected, private) 에 따라 직렬화를 할지 말지 결정한다. 하지만 접근 제한자로만 사용하기에는 부족한 부분이 있다 그래서 Unity 에서는 멤버 변수 직렬화를 &lt;strong&gt;Attribute&lt;/strong&gt; 문법을 사용해 Unity 전용 속성을 만들어 제어를 할 수 있도록 해두었다.&lt;/p&gt;

&lt;p&gt;클래스 멤버 변수 직렬화를 제어하는 속성은 세개가 있다. &lt;strong&gt;UnityEngine.SerializeField&lt;/strong&gt; 와 &lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt; 와 &lt;strong&gt;System.NonSerialized&lt;/strong&gt; 이 세개다. &lt;strong&gt;UnityEngine.SerializeField&lt;/strong&gt; 는 클래스 멤버 변수의 데이터를 직렬화 해주어 인스턴스가 생성되었을 떄 Unity 시스템에서 직렬화한 데이터로 초기화 시켜주는 속성이고, &lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt; 는 이전에 직렬화된 데이터와의 링크를 끊어 일시적으로 직렬화를 사용한 초기화를 막고 Inspector 에서도 안보이게 해준다. &lt;strong&gt;System.NonSerialized&lt;/strong&gt; 는 해당 멤버 변수의 직렬화를 아예 막는 속성이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;SerializeField&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;HideInInspector&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;NonSerialized&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수 직렬화를 해주는 &lt;strong&gt;Attribute&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;직렬화된 데이터를 숨기는 &lt;strong&gt;Attribute&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수 직렬화를 막는 &lt;strong&gt;Attribute&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 세개의 속성들로 Unity 직렬화 시스템을 제어할 수 있다. &lt;strong&gt;UnityEngine.SerializeField&lt;/strong&gt; 는 직렬화된 데이터가 필요할 때, &lt;strong&gt;System.NonSerialized&lt;/strong&gt; 는 직렬화된 데이터가 전혀 필요 없을 때, &lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt; 는 개발 도중에 잠시 직렬화된 데이터와 연결을 끊을 때 사용한다.&lt;/p&gt;

&lt;p&gt;필자는 확실한 것을 지향하기 때문에 &lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/HideInInspector.html&quot;&gt;&lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt;&lt;/a&gt; 를 잘 사용하진 않는다. 링크를 타고 들어가면 나오지만 정확한 행동의 정의되지 않았다. 단지 숨기기만 하는건지, 직렬화된 데이터를 없에는건지 설명이 명확하게 되어있지 않다. 또한 현재쓰는 Unity 5.5.2 버젼으로 테스트를 해보면 &lt;strong&gt;UnityEngine.HideInInspector&lt;/strong&gt; 가 붙은 직렬화 데이터가 초기화 되는 경우가 있다.&lt;/p&gt;

&lt;h2&gt;사용자 정의 자료형 직렬화&lt;/h2&gt;

&lt;p&gt;Unity 는 위 예제에서 보다시피 C# 의 기본 자료형과 Unity 에서 지원하는 자료형들의 변수를 Inspector 에서 에디팅할 수 있게 지원한다. 아래 스크립트와 그림을 보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeScript&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someVector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnimationCurve&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someCurve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;SomeScript 가 붙은 GameObject 의 Inspector 창에 아래와 같은 모습이 보일것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_1.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이 Unity 에서는 기본 자료형과 Unity 에서 지원하는 자료형을 Inspector 에서 에디팅하는 것을 지원한다. 하지만 클래스, 구조체 같은 사용자 정의 자료형은 경우가 조금 다르다. 무작정 &lt;strong&gt;SerializeField&lt;/strong&gt; 속성을 붙인다고 되지는 않는다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeDataObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someYRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeScript&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeDataObject&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 코드를 직접 실행시켜보면 알겠지만 이렇게 해봤자 Inspector 에서는 별 변화가 없다. &lt;strong&gt;SomeDataObject&lt;/strong&gt; 같이 &lt;strong&gt;MonoBehaviour&lt;/strong&gt; 를 상속받지 않은 사용자 정의 자료형들은 Inspector 에서 에디팅을 가능하게 하고, 저장을 하려면 클래스에 직렬화(&lt;strong&gt;Serializable&lt;/strong&gt;) 하다는 속성을 붙여주어야 한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;na&quot;&gt;[System.Serializable]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeDataObject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위와 같이 속성 하나만 붙여주면 Inspector 에서 에디팅이 가능하고 직렬화가 되어 자동으로 초기화가 가능해진다. 아래 그림과 같이 보일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_2.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;CustomPropertyDrawer 를 이용하여 변수의 Inspector 바꾸기&lt;/h2&gt;

&lt;h4&gt;클래스를 사용하여 커스터마이징하기&lt;/h4&gt;

&lt;p&gt;보통 클래스나 구조체를 사용해 자료를 저장하는 경우는 꽤 많다. 그리고 데이터가 많아지면 많아질 수록 넣어야할 변수는 많아지고 Inspector 창은 혼란의 도가니에 빠지게 된다. 아래와 같이 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_3.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 예시는 조금 극단적이긴 하지만 변수가 6개씩만 넘어도 한눈에 보기에도 힘들고 편집하는데도 살짝 헷갈린다. 그리고 간단한 시스템이 아니면 대부분 꽤 많은 변수를 가지게 된다. 그래서 Unity 에서는 타입별로 Inpector 에서 보이는 에디팅 환경을 바꾸는 것을 지원한다. 위의 선언한 &lt;strong&gt;SomeDataObject&lt;/strong&gt; 를 이용하여 바꾸어보기로 하자.&lt;/p&gt;

&lt;p&gt;우선 에디터 전용 스크립트를 만들어 주어야 한다. Unity 의 Project 창에서 아무 위치에나 &lt;em&gt;“Editor”&lt;/em&gt; 라는 이름으로 폴더를 만들어주고, 그안에 스크립트를 만들어주자. 아래 그림과 같이 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/editor_code_location.png&quot; alt=&quot;Project-editor&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SomeDataObject&lt;/strong&gt; 를 그리는 에디터이니 &lt;strong&gt;SomeDataObjectDrawer&lt;/strong&gt; 로 이름을 지어주었다. 그리고 그 안의 내용을 아래와 같이 적어주자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEditor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;[CustomPropertyDrawer(typeof(SomeDataObject))]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeDataObjectDrawer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PropertyDrawer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetPropertyHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetPropertyHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 예제는 원래 나오는 방식과 똑같이 구현을 해놓은 예제다. 여기서 주목해야할 점은 두개다. &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 클래스와 &lt;strong&gt;CustomPropertyDrawer&lt;/strong&gt; 속성이다. &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 클래스는 Inspector 내에서 직접 그리는 클래스의 모체로써, Inspector 에서 보이는 변수의 모습을 바꾸려면 이 클래스를 상속받아 구현을 해놓아야 한다. &lt;strong&gt;CustomPropertyDrawer&lt;/strong&gt; 속성은 클래스나 속성 타입을 명시적으로 넣어주어 해당 타입의 변수들이 Inspector 에서 보이는 모습을 바꾸겠다는 속성이다. 위 예제를 보면 &lt;strong&gt;CustomPropertyDrawer&lt;/strong&gt; 속성에는 &lt;strong&gt;SomeDataObject&lt;/strong&gt; 를 넣어주어 &lt;strong&gt;SomeDataObject&lt;/strong&gt; 클래스의 모든 변수들을 &lt;strong&gt;SomeDataObjectDrawer&lt;/strong&gt; 안의 코드를 이용해 보여준다는 의미다. 그리고 &lt;strong&gt;SomeDataObjectDrawer&lt;/strong&gt; 클래스는 &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 를 상속해 &lt;em&gt;GetPropertyHeight&lt;/em&gt; 메소드를 이용하여 높이값을 가져오고, &lt;em&gt;OnGUI&lt;/em&gt; 메소드를 사용하여 실제로 Inspector 창안에서 보이는 것을 구현한다. 위 코드에서는 기본적으로 제공하는 높이와, Unity 에서 사용하는 에디터 구현 코드를 사용해서 기존 에디터와 같은 방식으로 보일 것이다.&lt;/p&gt;

&lt;p&gt;기본적인 구현 방법에 대해 알아보았으니 아래 그림처럼 구현해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_4.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래에 구현 코드가 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 왼쪽에 이름으로 나오는 라벨, 여기서는 변수 이름이 들어감.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PrefixLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherWidth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 각 위치별로 설정해줌.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameRect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;numberRect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rotateRect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherWidth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 각 변수별로 Unity 에서 기본으로 지원하는 형식을 사용함.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 끝에 GUIContent.none 를 안넣어주면 이름이 표시되어 에디터에서 밀리게 나옴.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nameRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;FindPropertyRelative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;someName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;FindPropertyRelative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;someNumber&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rotateRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;FindPropertyRelative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;someYRotation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드는 한 변수당 한줄이였던 방식에서 데이터를 한줄에 넣어주는 코드다. &lt;strong&gt;EditorGUI.PrefixLabel&lt;/strong&gt; 메소드를 통해 앞에 표시되는 이름을 보여주고, 숫자를 넣어주는 부분의 넓이를 확보하고 나머지 넓이를 문자열을 보여주는데 사용한다.&lt;/p&gt;

&lt;p&gt;여기까지 클래스 변수가 Inspector 창에서 보이는 부분을 직접 커스터마이징 하는 방법에 대해서 알아보았다. 이 &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 기능을 이용하여 타입별로 고정하는게 아닌 &lt;strong&gt;Attribute&lt;/strong&gt; 를 이용하여 필요한 부분만 바꾸는 방법도 있다.&lt;/p&gt;

&lt;h4&gt;속성을 사용하여 커스터마이징하기&lt;/h4&gt;

&lt;p&gt;C# 문법은 &lt;strong&gt;Enum&lt;/strong&gt; 을 비트플래그로 사용하는 방법이 있다. 아래와 같이 말이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;na&quot;&gt;[System.Flags]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeEnumFlag&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Some&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Other&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Enum&lt;/strong&gt; 의 정의에다가 &lt;strong&gt;System.Flags&lt;/strong&gt; 를 붙여 사용하면 된다. 그런데 Unity 에서는 이 &lt;strong&gt;Enum&lt;/strong&gt; 을 황용하여 비트마스크를 보여주는 기능을 지원하지 않는다. 단지 한개의 아이템만 선택하는 기능만 지원한다. 그래서 Inspector 에서 비트 플래그를 사용하여 값을 설정하려면 직접 &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 를 사용하여 에디터를 바꿔주어야 한다. 그래서 아래처럼 코드를 짜보았다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;na&quot;&gt;[CustomPropertyDrawer(typeof(SomeEnumFlag))]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeEnumFlagDrawer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PropertyDrawer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;]&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumTypeNameDict&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;]&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializedProperty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUIContent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;EnumFlagAttribute&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EnumFlagAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumTypeNameDict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;TryGetValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Enum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;enumTypeNameDict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MaskField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;EditorGUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PropertyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;직접 실행시켜보면 알겠지만 저 코드는 잘 동작하지 않는다. 왜냐하면 &lt;strong&gt;CustomPropertyDrawer&lt;/strong&gt; 를 사용해서 바꿀 타입은 클래스들만 가능하기 때문이다. &lt;strong&gt;SomeEnumFlag&lt;/strong&gt; 는 &lt;strong&gt;Enum&lt;/strong&gt; 자료형이기 때문에 저 방식은 통하지 않는다. 이럴 때 &lt;strong&gt;Attribute&lt;/strong&gt; 를 직접 만들어 설정이 가능하다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EnumFlagAttribute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PropertyAttribute&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EnumFlagAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드는 속성을 직접 선언한 코드다. 중요한 점은 Unity 에서 지원하는 &lt;strong&gt;PropertyAttribute&lt;/strong&gt; 를 상속받아서 정의하였다는 점이다. &lt;strong&gt;PropertyAttribute&lt;/strong&gt; 를 사용해야만 Inspector 창에서 보이는 방식을 바꿀 수 있다. 위에서 만들어준 &lt;strong&gt;Enum&lt;/strong&gt; 비트 플래그 에디터 코드에 아래와 같이 연결시켜준다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;na&quot;&gt;[CustomPropertyDrawer(typeof(EnumFlagAttribute))]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeEnumFlagDrawer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PropertyDrawer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그 다음 해당 속성을 변수에 붙여주면 Inspector 에서 아래 그림과 같이 보일것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unity_support_inspector_5.png&quot; alt=&quot;Inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클래스 또는 속성별로 변수별 Inspector 에디터를 바꿔보는 &lt;strong&gt;PropertyDrawer&lt;/strong&gt; 설정 방법에 대해서 알아보았다.&lt;/p&gt;

&lt;p&gt;여태까지 설명했던 기능들은 전부 &lt;strong&gt;Attribute&lt;/strong&gt; 를 사용하여 지원한다. 그리고 설명하지 않은 &lt;strong&gt;Attribute&lt;/strong&gt; 문법을 사용하는 기능들도 엄~~청 많다. &lt;strong&gt;Attribute&lt;/strong&gt; 에 대해 이해를 하고 있으면 앞으로의 추가적인 기능들을 사용하는데 많은 도움이 될것이다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/mt653982.aspx&quot;&gt;C# Attribute Usage&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/PropertyDrawer.html&quot;&gt;Unity Custom Attribute&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.naver.com/PostView.nhn?blogId=hammerimpact&amp;amp;logNo=220775187161&amp;amp;redirect=Dlog&amp;amp;widgetTypeCall=true&quot;&gt;PropertyDrawer 번역 네이버 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tallior.com/unity-attributes/&quot;&gt;Set of Unity Attribute&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      

      

      
        <summary type="html">C# 문법은 클래스, 구조체, 열거형, 멤버 변수, 메소드등 여러 타입에 표시를 하는 기능을 제공한다. 이 표시들을 C# 문법에서는 Attribute(속성) 라고 칭한다. 그리고 이 속성을 사용하여 Unity 에서는 많은 기능들을 제공한다. 아래 우리가 가장 많이 볼만한 속성을 사용한 예제가 있다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Using Scriptable Object</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/09/using-scriptable-object/" rel="alternate" type="text/html" title="Using Scriptable Object" />
      <published>2017-04-09T00:00:00+00:00</published>
      <updated>2017-04-09T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/09/using-scriptable-object</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/09/using-scriptable-object/">&lt;p&gt;2년전 Unity 로 모바일 게임 개발을 시작했었다. 학생 시절 간단하게 게임을 만든적은 있었지만 Unity 로 게임을 만들어본 적은 한번도 없었기에 매우 어려운 도전이였다. 그래서 Unity 시스템에 대해 간단히 알고 개발을 시작했었는데 당시에는 ScriptableObject 의 기능을 모르고 있던터라 단순히 Prefab 만으로 데이터를 저장하고 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/subwaysurfer.png&quot; alt=&quot;Subway suffer&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;당시 만든 게임은 3D 러닝 게임이였는데, 서브웨이 서퍼과 비슷한 방식의 게임이였다. 핵심은 어떻게 맵을 계속 나타나게 하느냐 였는데, 나는 단순하게 플레이어의 위치에 따라 맵을 계속 이어붙였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/map_example_0.png&quot; alt=&quot;runtime map&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Map 은 Prefab 단위로 구성되어 있었는데, Map Prefab 에는 플레이어가 지나갈 길의 정보, 3D 메쉬 정보가 있었다. 그리고 맵 종류별로 풀링을 하여 활용했었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/map_example_1.png&quot; alt=&quot;map pooling&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 한가지 아쉬운게 있다면 Map Prefab 별로 모두 길 정보를 가지고 있는게 아쉬웠다. 프리팹은 보이는 정보만 가지고 길 정보는 따로 존재해  참조하는 방식이 조금 더 나았을 것이다. 종류 별로 반복되는 길 정보가 많았기 때문에 더욱 아쉬웠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/map_example_2.png&quot; alt=&quot;map refer to road data&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 길 정보는 따로 존재하고 맵이 길 정보를 참조하는 방식으로 말이다. 하지만 위와 같은 방식을 고안하더라도 실제로 구현할 방법을 몰랐기 때문에 방치했었다. 하지만 지금은 독립적으로 존재하는 데이터 에셋을 만드는 방법을 알고 있다. 그건 바로 ScriptableObject 라는 에셋 타입이다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;정적인 에셋 타입 : ScriptableObject&lt;/h2&gt;

&lt;p&gt;ScriptableObject 는 Inspector 에 존재하는 데이터 에셋의 종류 중 하나다. Prefab 처럼 그 자체를 복사할 수 없고, 단지 독립적으로 존재한다. 그래서 ScriptableObject 를 참조해서 데이터에 접근할 수 있다. 이름처럼 스크립트에서 ScriptableObject 라는 클래스를 상속받아 활용하며 데이터 직렬화를 지원하기 때문에 컴포넌트 스크립팅 처럼 데이터를 저장하여 사용가능하다. 시작할 때 언급한 길 정보를 ScriptableObject 로 직접 만들어 보았다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;[CreateAssetMenu(fileName = &quot;RoadData&quot;, menuName = &quot;Examples/RoadData&quot;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RoadDataOjbect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScriptableObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SerializeField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roadPositionArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roadPositionArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetPositionAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roadPositionArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 구현을 보면 필요한 데이터(위에서는 위치정보)를 저장하기만 한다. 스크립팅 방식은 저장할 데이터를 선언만 해주고, 그 데이터를 관리하는 코드만 짜주면 된다. 컴포넌트 스크립팅과 조금 다른점은 직접 행동하는 개체가 아니기 때문에 실제 게임 로직은 제외해서 코딩을 하게 된다.&lt;/p&gt;

&lt;p&gt;하지만 ScriptableObject 의 의의는 스크립팅 방식이 아니라, 독립적으로 존재하는 것에 의미를 더 부여한다. 정확히 정의하자면 “독립적으로 존재하는 데이터의 집합 에셋” 이라고 할 수 있다. 그래서 독립적으로 존재하기 위해 파일로 직접 만들어주는 코드가 필요하다.&lt;/p&gt;

&lt;p&gt;그 코드가 클래스 선언위의 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/CreateAssetMenuAttribute.html&quot;&gt;CreateAssetMenu&lt;/a&gt; 라는 속성이다. MonoBehaviour 를 활용한 스크립트는 컴포넌트로 취급되기 때문에 GameObject 에 붙이기만 하면 자연스럽게 사용할 수 있다. 하지만 ScriptableObject 는 독립적으로 존재하기 때문에 생성하는 코드를 만들어 주어야 한다. 저 속성을 붙이면 아래 그림처럼 메뉴에 만드는 코드가 추가된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/make_scriptableobject.png&quot; alt=&quot;make scriptableObject&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림처럼 메뉴를 선택하면 아래 그림과 같이 스크립트를 만들때와 동일하게 이름을 설정하고 파일을 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/make_scriptableobject_inspector.png&quot; alt=&quot;make scriptableObject inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 예제에서는 ScriptableObject 를 단순히 데이터 자체만 저장하는 용도로 쓰는 예시를 보여주었다. 단순 데이터 저장 방식으로도 많이 쓰이지만 이를 프로젝트 내의 에셋을 연결시켜주는 용도로도 사용할 수 있다. 아래 그림처럼 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/set_scriptableobject.png&quot; alt=&quot;set of asset or data&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ScriptableObject 에 단순 데이터, 관련된 애셋들을 묶어 관리하면 조금더 효율적으로 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/hrmrzizon/UnityExample&quot;&gt;UnityExample&lt;/a&gt; 에 위에서 나온 예들을 적용시킨 예제가 있으니 살펴보길 바란다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/script-Serialization.html&quot;&gt;Untiy Serialize&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/class-ScriptableObject.html&quot;&gt;Unity ScriptableObject&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.naver.com/PostView.nhn?blogId=hammerimpact&amp;amp;logNo=220770261760&quot;&gt;네이버 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://unity3d.com/kr/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects&quot;&gt;Unity ScriptableObject Guideline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      

      

      
        <summary type="html">2년전 Unity 로 모바일 게임 개발을 시작했었다. 학생 시절 간단하게 게임을 만든적은 있었지만 Unity 로 게임을 만들어본 적은 한번도 없었기에 매우 어려운 도전이였다. 그래서 Unity 시스템에 대해 간단히 알고 개발을 시작했었는데 당시에는 ScriptableObject 의 기능을 모르고 있던터라 단순히 Prefab 만으로 데이터를 저장하고 있었다. 당시 만든 게임은 3D 러닝 게임이였는데, 서브웨이 서퍼과 비슷한 방식의 게임이였다. 핵심은 어떻게 맵을 계속 나타나게 하느냐 였는데, 나는 단순하게 플레이어의 위치에 따라 맵을 계속 이어붙였다. Map 은 Prefab 단위로 구성되어 있었는데, Map Prefab 에는 플레이어가 지나갈 길의 정보, 3D 메쉬 정보가 있었다. 그리고 맵 종류별로 풀링을 하여 활용했었다. 여기서 한가지 아쉬운게 있다면 Map Prefab 별로 모두 길 정보를 가지고 있는게 아쉬웠다. 프리팹은 보이는 정보만 가지고 길 정보는 따로 존재해 참조하는 방식이 조금 더 나았을 것이다. 종류 별로 반복되는 길 정보가 많았기 때문에 더욱 아쉬웠다. 위와 같이 길 정보는 따로 존재하고 맵이 길 정보를 참조하는 방식으로 말이다. 하지만 위와 같은 방식을 고안하더라도 실제로 구현할 방법을 몰랐기 때문에 방치했었다. 하지만 지금은 독립적으로 존재하는 데이터 에셋을 만드는 방법을 알고 있다. 그건 바로 ScriptableObject 라는 에셋 타입이다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Message System</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/07/unity-message-system/" rel="alternate" type="text/html" title="Unity Message System" />
      <published>2017-04-07T00:00:00+00:00</published>
      <updated>2017-04-07T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/07/unity-message-system</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/07/unity-message-system/">&lt;h2&gt;이름으로 메소드를 호출하다. SendMessage&lt;/h2&gt;

&lt;p&gt;Unity 런타임 시스템에서는 Unity 자체의 캐시 시스템을 이용하여 컴포넌트의 메소드를 문자열로 찾아 호출해주는 기능을 가지고 있다. 그중 하나는 &lt;strong&gt;GameObject&lt;/strong&gt; 와 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Component.html&quot;&gt;&lt;strong&gt;Component&lt;/strong&gt;&lt;/a&gt; 클래스에 존재하는 &lt;a href=&quot;https://docs.unity3d.com/kr/current/ScriptReference/GameObject.SendMessage.html&quot;&gt;&lt;strong&gt;SendMessage&lt;/strong&gt;&lt;/a&gt; 라는 메소드다. 아래와 같이 사용을 할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnEnable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;SendMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DoSomething&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Do something!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;OnEnable 에서 해당 컴포넌트의 DoSomething 이라는 메소드를 찾아 호출하는 SendMessage 메소드를 호출하고, 아마 DoSomething 메소드가 호출되면서 로그가 출력될 것이다.&lt;/p&gt;

&lt;p&gt;Unity 에서 메세징 방식의 대표적인 사용사례는 컴포넌트 스크립팅을 할 때 항상 볼 수 있는 Start, Update 등 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MonoBehaviour.html&quot;&gt;MonoBehaviour&lt;/a&gt; 의 여러 메시지 콜백들이다. 저 메시지 콜백들을 통해 스크립트 컴포넌트는 여러 상태를 알 수 있다.
&lt;!-- more --&gt;
또한 &lt;strong&gt;AnimationClip&lt;/strong&gt; 을 사용할때 메세지 이벤트를 넣어서 사용할 수 있다. 애니메이션의 특정 프레임에 메시지 이벤트를 만들어 같은 게임오브젝트에 붙어있는 스크립트들에게 메시지를 던져준다. &lt;a href=&quot;https://github.com/hrmrzizon/UnityExample&quot;&gt;UnityExample&lt;/a&gt; 프로젝트의 MessageScene 의 ShakeCube 를 확인하라.&lt;/p&gt;

&lt;h2&gt;메시지 방식의 사실, 장단점&lt;/h2&gt;

&lt;p&gt;지금도 많은 사람들이 SendMessage 는 &lt;strong&gt;“매우 느리다”&lt;/strong&gt; 라는 생각을 하며 사용한다. 하지만 &lt;strong&gt;“매우 느리다”&lt;/strong&gt; 의 근거가 될만한 이유는 C# Reflection 기능을 &lt;strong&gt;“실시간”&lt;/strong&gt; 으로 사용하는 것에 있다. 이를 반박하자면&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GameObject 가 생성될 시에 각 컴포넌트별로 C# 리플렉션 기능을 사용해 메소드들의 위치와 이름을 함께 저장하여 가지고 있는다. 그리고 오브젝트가 파괴될 때까지 이 캐시 데이터를 저장해놓고 쓴다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 문단의 내용이 사실이라면 &lt;strong&gt;“매우 느리다”&lt;/strong&gt; 의 근거는 없다. Unity 시스템에서 사용하는 기능이 그렇게 느릴리는 없다. (&lt;a href=&quot;https://www.slideshare.net/MrDustinLee/ss-27739454&quot;&gt;유니티가 당신에게 알려주지 않는 것들&lt;/a&gt; : 43 ~ 47쪽)&lt;/p&gt;

&lt;p&gt;언제나 장점이 있으면 단점도 있다. 이 메시징 방식은 타입에 상관없이 문자열 하나로 메소드 호출이 가능하다는(Typeless call) 강력한 장점을 가지고 있다. 하지만 단점도 고려하고 사용해야 한다.&lt;/p&gt;

&lt;h4&gt;1. 빈번한 호출은 피한다.&lt;/h4&gt;

&lt;p&gt;문자열 탐색에 대한 비용이 있으니 매 프레임마다 호출해주거나 빈번히 사용이 일어날 때는 사용을 지양해야 한다.&lt;/p&gt;

&lt;h4&gt;2. 생성시에 부하가 발생한다.&lt;/h4&gt;

&lt;p&gt;컴포넌트 성성 타이밍에 C# Reflection 기능을 사용해 메소드 데이터를 생성한다. 이 때 부하가 발생한다. 퍼포먼스가 필요한 게임에서는 &lt;strong&gt;GameObject&lt;/strong&gt; 의 생성은 되도록 피하고, 모든 오브젝트를 가장 처음에 로드 후 재활용해서 사용한다.&lt;/p&gt;

&lt;h4&gt;3. OOP 를 망친다.&lt;/h4&gt;

&lt;p&gt;접근 제한자에 상관없이 호출해주기 때문에 객체 캡슐화에 안좋은 영향을 미친다. OOP(객체지향프로그래밍) 에서는 접근 제한자를 통해 외부에 노출시킬 메소드, 안에서 숨겨야할 메소드를 설정한다. 하지만 Unity 메시징 방식은 접근 제한자를 무시하기 때문에 프로그래머에게 모호한 선택을 요구한다.&lt;/p&gt;

&lt;h4&gt;4. 방치될 가능성?&lt;/h4&gt;

&lt;p&gt;레거시 시스템이 될 가능성이 있다. &lt;a href=&quot;https://bitbucket.org/Unity-Technologies/ui&quot;&gt;UGUI&lt;/a&gt; 가 4.6 버젼에서 추가되면서 Unity 에서는 UnityEngine.Events 라는 기능도 추가되었다. 이 네임스페이스 안에는 UnityEvent 에 대한 구현도 있고, 현재 메시지 방식을 대체할 수 있는 EventSystem 이라는 시스템의 구현도 되어 있다. UGUI 에서는 UnityEngine.Events 안의 기능들을 적극 사용해 구현을 했다.&lt;/p&gt;

&lt;p&gt;이를 통해 알 수 있는 점은 현재 기능에 대한 최적화는 가능성이 있으나, 더 이상의 기능 추가는 기대하기 어렵다. 즉 Animation 컴포넌트와 같이 기능 확장이 멈추어 새로 생기는 시스템과는 점점 멀어질 가능성이 높다.&lt;/p&gt;

&lt;p&gt;메시징 방식을 사용할 때는 위 항목들을 명심하고 사용하길 바란다.&lt;/p&gt;

&lt;h2&gt;그래서 언제 사용하면 되나요?&lt;/h2&gt;

&lt;p&gt;간단하다. 생성 및 초기화 같이 시작과 끝에서 호출되거나 정말 쓸 수 밖에 없는 경우(애니메이션 이벤트) 에 사용한다. 혹은 성능이 필요 없는 UI에 쓰기도 한다. 매 프레임마다 호출되는 곳이 아닌이상 써도 무관한 경우가 많다.&lt;/p&gt;

&lt;p&gt;위와 같은 조건이 갖추어지면 UnityEvent 와 용도가 겹치는 부분이 있다. 둘다 직접 메소드 호출을 하는게 아닌 원격으로 해주는 기능이라 쓰임새가 겹친다. 하지만 둘은 성질 자체가 달라서 용도도 다르게 사용할 수 있다. UnityEvent 는 에디터에서 직접 컴포넌트를 지정해주어야 하고, 런타임에서는 변경이 불가능하기 때문에 고정된 컴포넌트에서만 사용한다. 하지만 그외의 경우 스크립트 내에서 프리팹을 복사할 때는 UnityEvent 를 사용할 수 없다. 결국 C# Delegate 문법을 사용하거나 SendMessage 기능을 사용해야 하는데 이 경우에는 상황에 따라 적절하게 쓰면 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;분류&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Unity Messaging&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C# Delegate&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;속도&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비교적 느림&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비교적 빠름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;코딩&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;한번에 메소드 호출이 가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;직접 메소드를 이어주고 호출해주어야함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;매 프레임마다 호출되거나 자주 호출이 되는 경우에는 C# Delegate 문법을, 성능이 필요없는 부분(생성,파괴)에서 호출할 때는 SendMessage 를 사용하면 된다.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/MessagingSystem.html&quot;&gt;Unity 메시지 시스템&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gamedev.stackexchange.com/questions/120327/how-to-send-an-interface-message&quot;&gt;GameDev HowToMessage&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/MrDustinLee/ss-27739454&quot;&gt;유니티가 당신에게 알려주지 않는 것들&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="mono" />
      
        <category term="c#" />
      
        <category term="try" />
      

      

      
        <summary type="html">이름으로 메소드를 호출하다. SendMessage Unity 런타임 시스템에서는 Unity 자체의 캐시 시스템을 이용하여 컴포넌트의 메소드를 문자열로 찾아 호출해주는 기능을 가지고 있다. 그중 하나는 GameObject 와 Component 클래스에 존재하는 SendMessage 라는 메소드다. 아래와 같이 사용을 할 수 있다. void OnEnable() { SendMessage(&quot;DoSomething&quot;); } void DoSomething() { Debug.Log(&quot;Do something!&quot;); } OnEnable 에서 해당 컴포넌트의 DoSomething 이라는 메소드를 찾아 호출하는 SendMessage 메소드를 호출하고, 아마 DoSomething 메소드가 호출되면서 로그가 출력될 것이다. Unity 에서 메세징 방식의 대표적인 사용사례는 컴포넌트 스크립팅을 할 때 항상 볼 수 있는 Start, Update 등 MonoBehaviour 의 여러 메시지 콜백들이다. 저 메시지 콜백들을 통해 스크립트 컴포넌트는 여러 상태를 알 수 있다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Event Handling</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/05/unity-event-handling/" rel="alternate" type="text/html" title="Unity Event Handling" />
      <published>2017-04-05T00:00:00+00:00</published>
      <updated>2017-04-05T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/05/unity-event-handling</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/05/unity-event-handling/">&lt;p&gt;Unity 에서 객체간의 이벤트를 처리하는 방법들을 써본다. c# 에서 지원하는 delegate, event 와 UnityEvent 를 알아볼 것이다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;C# Delegate, Event&lt;/h2&gt;

&lt;h4&gt;행동을 대신하다. Delegate&lt;/h4&gt;

&lt;p&gt;대리자(Delgate) 의 개념이 고안된지는 꽤 많은 시간이 흘렀다. 시작으로 거슬러 올라가면, 가장 사람들이 많이 접한 형태는 Windows API 의 메세지 처리 콜백 함수가 있겠다. 긴말 필요없이 간단한 예제를 살펴보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//
// delegate 를 이용한 간단한 Unity 예제다.  
//
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delegate&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CheckForAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CheckForAwake&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 단순히 함수를 대입한다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LogAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 람다식을 += 를 사용해 onAwake 델리게이트에 추가한다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;CheckForAwake&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Awake!! Twice!!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 람다식을 -= 를 사용해 onAwake 델리게이트에서 지운다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// null 을 넣어 빈 델리게이트를 표현한다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LogAwake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Awake!!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 예제는 대리자(Delgate)의 사용방법을 보여준다. 대리자(Delgate)는 단순히 대입을 통해 한개의 함수만 넣을 수도 있고, ‘+’, ‘-‘ 연산자들을 통해 여러개의 함수를 가질수도 있다. 다만 같은 인자, 같은 반환형을 가져야 위와 같이 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;위 예제를 살펴보았을 때 대리자(Delgate)는 함수들을 여러개 가질 수도 있고, null 값을 가질수 있는 자료형이라고 칭할 수 있겠다.&lt;/p&gt;

&lt;p&gt;그리고 일일히 타입을 지정하지 않고도 미리 지정된 대리자들을 사용가능하다. (참고 : &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/018hxwa8.aspx&quot;&gt;Action&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/bb549151.aspx&quot;&gt;Func&lt;/a&gt; 등 많은 타입이 있다.)&lt;/p&gt;

&lt;h4&gt;특정 정보를 전달해준다. Event&lt;/h4&gt;

&lt;p&gt;C# 에서 event 키워드는 대리자(Delgate) 선언에 같이 쓸 수 있는 키워드로, 선언된 대리자(Delgate)의 접근을 제한하는 역할을 한다. 근데 “접근을 제한할려면 접근 키워드를 쓰지 왜 event 라는 다른 키워드를 쓰는 것인가?” 라는 생각이 들 수도 있다. 역시 아래 예제를 보면서 설명하겠다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine.Events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine.SceneManagement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//
// 씬 로드 event 를 이용한 예제다.
//
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 대리자 이벤트 변수
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnityAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoadSceneMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 자기 자신의 대리자 이벤트 변수는 어떤 접근도 가능함.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OnSceneLoaded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OnSceneLoaded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러! 외부의 event 변수는 assign 이 안됨.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// SceneManager.sceneLoaded = onLoad;
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// += 접근은 가능함.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;SceneManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sceneLoaded&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러! 외부의 event 변수는 assign 이 안됨.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// SceneManager.sceneLoaded = null;
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// -= 접근은 가능함.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;SceneManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sceneLoaded&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnSceneLoaded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scene&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoadSceneMode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{0}, {1}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 코드는 event 의 접근 제한이 어디에 걸려있는지 알 수 있다. 자기 자신의 이벤트 대리자는 얼마든지 접근이 가능하지만, 외부에서 이벤트 대리자를 접근할 때는 대입 연산자는 불가능하고, 등록(+=) 하거나 취소(-=) 하는 연산자만 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;즉 이벤트 키워드는 인스턴스 외부에서 대리자를 보호하는 역할을 하며, 외부에서 이벤트 키워드가 붙은 대리자 자체를 이벤트를 전달받는 용도로만 쓰도록 한다.&lt;/p&gt;

&lt;h2&gt;Serializable 한 이벤트 : UnityEvent&lt;/h2&gt;

&lt;p&gt;위에서 C# 에서 지원하는 Event, Delegate 문법을 알아보았다. 저 문법들만 잘 활용해도 깔끔하게 스크립팅이 가능하지만, Unity 시스템에서는 조금은 모자란 부분이 있다. 그래서 Unity 에서는 C# 의 Event, Delegate 기능을 따로 구현을 해서 지원한다. 구현을 클래스로 제공하는데 이름은 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html&quot;&gt;UnityEvent&lt;/a&gt; 다.&lt;/p&gt;

&lt;p&gt;스크립트에서 이벤트 사용은 거의 비슷하다. 런타임 내에서는 이벤트를 등록하거나, 제거할 수 있고 Invoke 메소드를 통해 이벤트를 알려주면 된다. 하지만 UnityEvent 는 스크립팅보다는 Hierarchy 시스템 내에서 빛을 발한다. UGUI 의 Button 컴포넌트를 아래 그림이 있다. 한번 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eventhandling-inspector.png&quot; alt=&quot;inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 버튼은 “눌렸을 때, 무언가 동작을 한다.” 라고 생각을 할것이다. 그래서 동작을 이어주는 부분이 &lt;em&gt;OnClick()&lt;/em&gt; 이라고 쓰여있는 부분이다. &lt;em&gt;OnClick()&lt;/em&gt; 에 두개의 블록이 있다. 블록은 아래 +, - 버튼을 통해 없에거나 만들 수 있다. 그리고 각 블록의 역할은 게임 오브젝트의 컴포넌트의 메소드 하나를 연결하는 역할을 한다. 블록은 연결할 메소드의 갯수만큼 늘리고 줄이면 된다.&lt;/p&gt;

&lt;p&gt;설정하는 방법은 간단하다. Hierarchy 내에서 하나의 게임오브젝트를 선택하고, 게임 오브젝트가 가지고 있는 컴포넌트 중의 메소드를 하나 선택한다. 그리고 파라미터가 있으면 간단하게 설정해주면 된다. 아래 그림과 같이 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eventhandling-inspector-select-method.png&quot; alt=&quot;inspector&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 메소드를 등록하면된다. 그런데 UnityEvent 에 등록할 수 있는 메소드의 제한이 있다. 타겟 게임 오브젝트와 자신의 게임 오브젝트의 관계가 고정되어야 하고, static 함수가 아니여야 하며, 무조건 public 으로 접근제한자가 설정되어 있어야 한다. static 함수가 아니여야 하는건 실제 컴포넌트의 메소드를 호출한다는 컨셉인것 같고, 접근제한자가 public 이여야 하는건 스크립트의 유연함을 위해 그런듯 하다.&lt;/p&gt;

&lt;p&gt;그런데 사용하다보면 조금 의문이 드는점이 있다. &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html&quot;&gt;UnityEvent&lt;/a&gt; 에서 정의된 &lt;em&gt;AddListener/RemoveListener&lt;/em&gt; 와 인스펙터에서 설정해준 정보들이 다르게 취급되는 것처럼 보인다.&lt;/p&gt;

&lt;p&gt;사실 UnityEvent 에서는 메소드 등록 정보를 두개로 나누어서 관리한다.&lt;/p&gt;

&lt;p&gt;하나는 인스펙터에서 설정해준 persistant listner(지속성 리스너), 하나는 non-persistant listener(비지속성 리스너) 로 구분을 한다. 인스펙터에서 설정해준 값들은 지속성 리스너로 취급하며 런타임에서는 수정이 불가능하다. Unity 프로젝트안에 저장된(직렬화된) 데이터들이라서 런타임에서는 수정이 불가능 하기 때문이다.(에디터에서는 가능하다)&lt;/p&gt;

&lt;p&gt;그리고 UnityEvent 클래스에 직접 정의된 &lt;em&gt;AddListener/RemoveListener&lt;/em&gt; 은 비지속성 리스너를 취급하는 메소드다. 이들은 런타임에서 등록, 제거가 가능하다. 하지만 지속되지 않는(저장되지 않는) 리스너로 위에서 설명한 C# event, delgate 문법과 같은 기능을 한다.&lt;/p&gt;

&lt;p&gt;파라미터 설정도 사용자 마음대로 설정할수 있다. 자세한 설정 방법은 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Events.UnityEvent_1.html&quot;&gt;UnityEvent&lt;/a&gt; 를 참조하면 된다.&lt;/p&gt;

&lt;h2&gt;실제 사용 사례 및 장단점&lt;/h2&gt;

&lt;p&gt;C# Delegate 문법은 정말 무궁무진하게 쓰인다. 특히 일시적인 루틴이 아닌 비동기 처리가 필요할 때 유용하게 쓸 수 있다. 아래 예시를 보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetObjectCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 무조건 한번에 값을 반환해주어야 함.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetObjectCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 실행시에 대리자를 호출할 수도 있고, 일정 시간이 흐른뒤에 대리자를 호출할 수도 있다.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Action 은 C# 라이브러리에서 미리 정해놓은 대리자 형식이다.(&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/018hxwa8.aspx&quot;&gt;Action 링크&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;가장 흔하게 대리자를 볼 수 있는 소스는 로그인 플랫폼 API 에 가장 많이 붙어있다. 대부분 네트워크 통신을 하기 때문에 당연히 비동기 처리에 대한 답이 필요하고, 가장 편한 수단으로 대리자를 뽑은 것이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Login&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Login&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;nf&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;getGoogle&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getGoogle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;WWW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;googleConnection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WWW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://www.google.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;googleConnection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;getGoogle&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loginSuccess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loginSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;IsNullOrEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;googleConnection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 Login 메소드가 대표적인 예시다.&lt;/p&gt;

&lt;p&gt;UnityEvent 빨리 게임 로직을 작업해야 할때나, UI 로직을 구성할 때 가장 많이 쓰인다. UGUI 의 많은 위젯들도 UnityEvent 를 사용하고 심지어 UI 전용 이벤트를 처리해주는 EventTrigger 라는 컴포넌트도 있을 정도로 UnityEvent 를 많이 활용한다.&lt;/p&gt;

&lt;p&gt;게임 로직도 UnityEvent 로 구성하면 만들때는 쉽지만 UnityEvent 는 가독성이 상당히 안좋기 때문에 복잡한 게임 로직을 구성하면 나중에는 손댈수 없는 스파게티 코드도 아닌 덩어리가 만들어질 것이다. 하지만 간단한 게임 로직이나, 프로토타이핑에는 매우 적합하다. 그리고 개인적으로 제일 좋은 것은 이벤트를 연결하는 코드를 관리하지 않아서 좋다.&lt;/p&gt;

&lt;p&gt;런타임 퍼포먼스에 대해에서는 이 글을 참고하라 : &lt;a href=&quot;http://jacksondunstan.com/articles/3335&quot;&gt;Event Performance: C# vs UnityEvent(영문)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위에서 말한 내용을 예제에서 확인하면 편리할 것이다. 아래 Github 링크를 올려놓았으니 확인해보길 바란다.&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://github.com/hrmrzizon/Extended-Roll-a-Ball&quot;&gt;Extended-Roll-a-Ball&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/ms173176.aspx&quot;&gt;MSDN 방법: 대리자 선언, 인스턴스화 및 사용&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/ms173172.aspx&quot;&gt;MSDN C# Delegate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/awbftdfh.aspx&quot;&gt;MSDN C# Event&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jacksondunstan.com/articles/3335&quot;&gt;Event Performance&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/UnityEvents.html&quot;&gt;UnityEvent Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="c#" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">Unity 에서 객체간의 이벤트를 처리하는 방법들을 써본다. c# 에서 지원하는 delegate, event 와 UnityEvent 를 알아볼 것이다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Project Directory Structue</title>
      
      <link href="https://hrmrzizon.github.io/2017/04/02/unity-project-directory-structue/" rel="alternate" type="text/html" title="Unity Project Directory Structue" />
      <published>2017-04-02T00:00:00+00:00</published>
      <updated>2017-04-02T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/04/02/unity-project-directory-structue</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/04/02/unity-project-directory-structue/">&lt;p&gt;Unity 프로젝트는 여러 종류의 데이터를 디렉토리로 판단해 컴파일 한다. 반대로 이 디렉토리 구조를 통해 Unity 의 컴파일 시스템을 알아볼 수도 있다. 디렉토리 구조 자체는 간단하나 숨겨진 뜻은 조금 복잡하다. 그러니 한번 알아보기로 하자.&lt;/p&gt;

&lt;p&gt;* 이글은  &lt;em&gt;Unity Personal 5.5.2f&lt;/em&gt; 기준으로 쓰여져 있습니다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;Unity 프로젝트 구조&lt;/h2&gt;

&lt;p&gt;일반적인 Unity 프로젝트 디렉토리 구조는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;em&gt;Assets&lt;/em&gt;&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;library&lt;/em&gt;&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;ProjectSetting&lt;/em&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Assets 디렉토리는 스크립트, 리소스, 플러그인 등 프로젝트에서 쓰이는 대부분의 데이터를 모아놓은 디렉토리다. 개발은 거의 Assets 폴더안에서 이루어진다. 또한 이 디렉토리 안에서도 여러 종류의 특별한 디렉토리 이름이 있다.&lt;/p&gt;

&lt;p&gt;ProjectSetting 디렉토리는 프로젝트의 여러 옵션들을 관리하는 파일을 가지고 있다. 안을 들여다보면 &lt;em&gt;Edit -&amp;gt; Project Settings&lt;/em&gt; 에서 볼 수 있는 이름들과 같은 파일들이 있다.&lt;/p&gt;

&lt;p&gt;Library 디렉토리는 위에서 말한 Assets 디렉토리와 ProjectSetting 디렉토리의 모든 데이터를 Unity 가 바로 가져다 쓸 수 있도록 Unity 만의 데이터로 변형한 결과물이다. Unity 에서는 이 결과물들로 대부분의 컴파일을 처리한다.&lt;/p&gt;

&lt;p&gt;이 디렉토리의 데이터는 실제 데이터가 아닌 메타 데이터다. 즉 프로젝트에서 당장 없어도 되는 파일이다. 파일을 옮길 때 디스크 크기를 신경써야 한다면 이 디렉토리는 지워도 된다. 그리고 VCS 에 프로젝트를 등록할 때는 Libary 디렉토리는 올리면 안된다. 혼자서 쓸때는 상관없지만 여러명이서 사용할 때는 Asset, ProjectSetting 디렉토리의 데이터와 Library 의 데이터가 달라질 수 있다. 만약 다르다면 실행 시에 오류가 나거나, 다시 컴파일할 수도 있다.&lt;/p&gt;

&lt;h2&gt;Assets 안의 특별한 이름들&lt;/h2&gt;

&lt;p&gt;위에서도 언급했지만 Assets 디렉토리는 게임의 실질적인 데이터들이 들어가 있는 디렉토리다. 그래서 Unity 에서는 에셋들을 관리하기 위해 Assets 디렉토리 안에서도 데이터를 구분하도록 몇개의 디렉토리 이름을 예약해 놓았다. 예약된 이름들은 무조건 정해진 동작을 하니 정해진 동작과 같은 목적이 아니라면 디렉토리 이름을 다르게 설정해주어야 한다.&lt;/p&gt;

&lt;h4&gt;“Standard Assets”&lt;/h4&gt;

&lt;p&gt;Unity 의 예제 프로젝트들을 실행하면 대부분의 프로젝트들은 Standard Assets 디렉토리가 존재한다. 예제마다 항상 보이는 이 디렉토리는 일반적인 에셋과 다른 분류를 위해 만들어진 이름이다. &lt;a href=&quot;https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html&quot;&gt;Unity Compile Order&lt;/a&gt; 를 보면 알겠지만 맨 처음 컴파일이 되는 디렉토리는 Standard Assets 다.&lt;/p&gt;

&lt;p&gt;그래서 먼저 컴파일이 되면 사용자 입장에서는 무엇이 중요한 것인가? 중요한 한가지만 뽑자면, Assets 폴더안의 다른 언어로 쓰여진 스크립트에서 Standard Assets 스크립트를 참조할 수 있다. 이 말은, C# 으로 유니티 프로젝트를 개발하는 사람이 js 로 쓰여진 스크립트를 변환없이 사용이 가능하단 소리다.&lt;/p&gt;

&lt;h4&gt;“Streaming Assets”&lt;/h4&gt;

&lt;p&gt;Unity 에서 사용되는 모든 파일들은 변환을 거치거나, 메타 파일을 생성해 Unity 시스템에서 접근을 용이하게 한다. 하지만 몇몇의 경우 Unity 에서 변환을 하면 안되는 경우가 몇몇 있다. Unity 문서에서, iOS 에서는 영상을 재생하려면 원본 파일이 필요하다는 예시가 있었다.&lt;/p&gt;

&lt;p&gt;그래서 필요한 디렉토리가 Streaming Assets 다. 이름 자체도 스트리밍을 염두해두고 만든 듯 싶다. 이 디렉토리의 파일을 접근하는 방법은 언어에서 제공하는 API를 사용하거나, &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/WWW.html&quot;&gt;WWW&lt;/a&gt; 를 통해 접근할 수도 있다. 플랫폼 별로 경로가 다르니 유의하길 바란다.&lt;/p&gt;

&lt;h4&gt;“Resources”&lt;/h4&gt;

&lt;p&gt;Unity 에서는 빌드를 컴파일 할때, 각 씬의 게임오브젝트 마다 연결된 에셋(&lt;em&gt;Assets 안의 데이터를 칭한다.&lt;/em&gt;)들을 찾아서 컴파일 한다. 그리고 런타임에서 Hierarchy 안에 게임 오브젝트가 만들어졌을 때, 게임 오브젝트에 연결된 에셋들을 로드한다.(중복되면 한번만 로드한다.)&lt;/p&gt;

&lt;p&gt;그런데 로드하는 과정에서 약간의 문제가 생길 소지가 있다. 크기가 아주 큰 에셋을 로드하면 많은 메모리 공간을 차지해 문제가 생길 우려가 있다.(튕긴다거나..) 특히 메모리가 부족한 모바일 플랫폼에서는 신경써서 관리를 해주어야 한다.&lt;/p&gt;

&lt;p&gt;그래서 원본 에셋을 동적으로 로드하고, 해제하는 기능을 제공한다. 그 기능을 사용하게 해주는 디렉토리가 Resources 다. 이 디렉토리 안의 데이터들은 런타임에서 경로를 입력해 로드, 언로드가 가능하다.&lt;/p&gt;

&lt;h4&gt;“Editor”&lt;/h4&gt;

&lt;p&gt;Unity 에서는 Unity 에디터 안에서 일정한 범위의 에디터 커스터마이징을 제공한다. 그런 에디터에서 쓰이는 코드들 또한 Assets 안에 존재한다. 그리고 그 코드들을 모아놓는 디렉토리가 Editor 디렉토리다. 또한 이 폴더안에 모두 분류하는 직접적인 이유가 있다.&lt;/p&gt;

&lt;p&gt;Unity 는 런타임 내에서는 에디터 코드와 전혀 상관없이 돌아가게 모듈화를 강제한다. 빌드를 컴파일하게 되면, Editor 디렉토리는 모두 제외하고 컴파일을 한다. 또한 Unity 에서 에디터 바이너리를 제공하는 UnityEditor.dll 또한 빌드에 포함되지 않는다. 런타임 코드에서 UnityEngine 네임스페이스를 참조하고 컴파일하면 직접 에러를 볼 수 있을것이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html&quot;&gt;Unity Compile Order&lt;/a&gt; 에서도 Editor 컴파일은 가장 나중에 한다. 에디터 컴파일과 빌드 컴파일을 쉽게 분리하기 위해 이렇게 순서를 정한듯 하다.&lt;/p&gt;

&lt;h4&gt;“Plugins”&lt;/h4&gt;

&lt;p&gt;Unity 는 Android, PC, macOS 등 왠만한 플랫폼을 지원하는 크로스 플랫폼 게임 엔진이다. 하지만 엔진에서는 자체적으로 지원하는 기능들만 크로스 플랫폼을 지원하고, Third-party 라이브러리는 지원할 수가 없다. 그래서 Unity 에서는 플랫폼 별로 Plugins 디렉토리에 넣을 수 있는 기능을 제공한다. 또한 정적, 동적 라이브러리 들을 포함하는 용도로도 쓰인다. 자세한 사항은 &lt;a href=&quot;https://docs.unity3d.com/Manual/PluginInspector.html&quot;&gt;Unity Plugins&lt;/a&gt; 를 참조하라.&lt;/p&gt;

&lt;h2&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/SpecialFolders.html&quot;&gt;Unity Special Folder&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html&quot;&gt;Unity Compile Order&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://yongil.net/unity/2015/04/23/Unity-Special-Folder-Names-in-your-Assets-Folder.html&quot;&gt;용일이의 개발,번역 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/PluginInspector.html&quot;&gt;Unity Plugins&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="try" />
      

      

      
        <summary type="html">Unity 프로젝트는 여러 종류의 데이터를 디렉토리로 판단해 컴파일 한다. 반대로 이 디렉토리 구조를 통해 Unity 의 컴파일 시스템을 알아볼 수도 있다. 디렉토리 구조 자체는 간단하나 숨겨진 뜻은 조금 복잡하다. 그러니 한번 알아보기로 하자. * 이글은 Unity Personal 5.5.2f 기준으로 쓰여져 있습니다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Csharp Class Method Extension</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/13/csharp-class-method-extension/" rel="alternate" type="text/html" title="Csharp Class Method Extension" />
      <published>2017-03-13T00:00:00+00:00</published>
      <updated>2017-03-13T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/13/csharp-class-method-extension</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/13/csharp-class-method-extension/">&lt;p&gt;unirx 를 살펴보다 모르는 문법이 나와서 기록해둔다. &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/bb383977.aspx&quot;&gt;MSDN 확장 메서드 문서&lt;/a&gt; 를 참고했다.&lt;/p&gt;

&lt;h2&gt;C# 클래스 확장 메서드&lt;/h2&gt;

&lt;p&gt;C# 3.0 문법부터 사용자가 기존에 정의된 클래스에 메소드를 확장 가능하게 되었다. obj-c 의 카테고리와 조금 비슷한것 같다. 자세한 사항은 코드와 함께 보자.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Linq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CustomExtensions&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Extension methods must be defined in a static class
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringExtension&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// This is the extension method.
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// The first parameter takes the &quot;this&quot; modifier
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// and specifies the type for which the method is defined.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WordCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'?'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringSplitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RemoveEmptyEntries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;선언 방식은 위와 같다. 반드시 static class 에 static method 로 선언해주어야 하며, 첫번째 파라미터는 확장할 타겟 클래스의 인스턴스와 함께 앞에 this 키워드를 사용해주면 된다. 필요한 파라미터가 있다면 그 뒤에다 쭉 써주면 된다. 다만 외부에서 호출해주는 것이기 때문에 한정자의 제한을 받는다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Extension_Methods_Simple&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Import the extension method namespace.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CustomExtensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Program&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;The quick brown fox jumped over the lazy dog.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//  Call the method as if it were an
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//  instance method on the type. Note that the first
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//  parameter is not specified by the calling code.
&lt;/span&gt;            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WordCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Word count of s is {0}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;사용 방법은 간단하다. 구현한 네임스페이스를 임포트 해주고, 확장한 메서드를 (인스턴스).(메서드) 형식으로 호출해주면 된다. 첫번째 타겟 클래스 인스턴스는 생략하고 파라미터를 넣어주면 된다. 다만 자기 자신의 함수를 호출해줄 때도 this 를 활용해 (인스턴스).(메서드) 형식으로 호출해주어야 한다.&lt;/p&gt;

&lt;h2&gt;주의점&lt;/h2&gt;

&lt;p&gt;이 기능은 참 편하다. 쉽게 클래스의 기능을 확장하기 때문이다. 근데 잘못 남용하다가는 아주 개판이 날 가능성이 높다. MSDN 에서는 반드시 필요한 곳에서만 사용하라고 권장하고 있다. 그리고 내 생각도 별반 다를바 없다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="c#" />
      

      

      
        <summary type="html">unirx 를 살펴보다 모르는 문법이 나와서 기록해둔다. MSDN 확장 메서드 문서 를 참고했다. C# 클래스 확장 메서드 C# 3.0 문법부터 사용자가 기존에 정의된 클래스에 메소드를 확장 가능하게 되었다. obj-c 의 카테고리와 조금 비슷한것 같다. 자세한 사항은 코드와 함께 보자.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 3 Erricson Texture Compression 2</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-3-erricson-texture-compression-2/" rel="alternate" type="text/html" title="Unity Texture Compression 3 Erricson Texture Compression 2" />
      <published>2017-03-12T00:00:00+00:00</published>
      <updated>2017-03-12T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-3-erricson-texture-compression-2</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-3-erricson-texture-compression-2/">&lt;p&gt;모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(&lt;a href=&quot;http://www.jacobstrom.com/output.html&quot;&gt;http://www.jacobstrom.com/output.html&lt;/a&gt;)&lt;/p&gt;

&lt;h2&gt;3. ETC2&lt;/h2&gt;

&lt;p&gt;ETC2 는 ETC 에서 블록의 모드를 더 추가해 다양한 방식으로 표현할 수 있는 텍스쳐 압축 방식이다. 다른 압축 방식들에서는 잉여 공간을 활용해 다른 데이터의 표현 수단으로 사용한 것을 보고, 고안해낸 사람은 ETC 에서도 같은 방식으로 잉여 공간을 찾아 활용할 계획을 한것 같다. 남는 공간은 없었지만 유효하지 않은(invalid) 비트 공간을 활용해 노말 모드, 동차(difference) 모드 외에도 세가지의 표현 방식을 추가했다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h4&gt;(1) 유효하지 않은 비트 공간이란?&lt;/h4&gt;

&lt;p&gt;ETC 에서 동차(difference) 모드는 서브블록의 색 공간을 합쳐서 활용하여 RGB555+dRGB333 으로 색을 표현했다. 여기서 유효하지 않은 비트 공간을 일부로 만들 수 있다. 바로 각자 색 성분이 합쳐져 0미만으로 언더 플로우가 나게하거나, 32 이상으로 만들어 오버플로우를(RGB555) 줘서 신호를 주는 것이다. 그렇게 RGB 세 성분을 유효하지 않게 만들어 3가지의 모드를 확보한다. ETC2 는 이 3가지 모드를 보조(auxiliary) 모드라고 칭한다. 아래 그림은 모드를 선택하는 다이어그램이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc2_invalid_bit_diagram.png&quot; alt=&quot;diagram&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ETC2 의 모드 선택 다이어그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 그림에서 오버플로우, 언더플로우가 생길 떄 보조 모드에서 55bit 가 남는다고 쓰여있다. diffbit 을 사용하는 1bit, 색상의 빨간색 컴포넌트 R0, dR 두개를 합치면 8bit 로 63bit 에서 값을 빼서 구한 값이다. 사실 55bit 가 아닌 59bit 를 사용가능하다.&lt;/p&gt;

&lt;p&gt;오버플로우, 언더플로우가 생기는 모든 케이스가 아래 표에 표현되어 있다. 데이터를 이진수로 보면 R0, dR 컴포넌트의 맨 마지막&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc2_overflow_bit_table.png&quot; alt=&quot;diagram&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ETC2 의 invalid 한 색상 테이블&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;RGB555+dRGB333 색 조합 오버,언더플로우 방식으로 특이점을 주어 59, 58, 57 의 페이로드를 확보함.
근데 왜 아직도 1bit 씩 공간이 필요한지 모르겠음. 그리고 디스크에 기록할때 4bit 로 줄여서 기록하면 그 줄어든 데이터는 어케 알아봄??;&lt;/p&gt;

&lt;p&gt;이렇게 새로운 모드를 구별 가능한데, 이전의 ETC 텍스쳐 데이터를 ETC2 디코더가 읽어도 오버,언더플로우가 나지 않기 때문에 이전 버젼의 텍스쳐를 읽어도 정상적으로 표현이 가능하다. 즉 ETC2는 ETC 의 하위 호환을 지원한다는 말이다.&lt;/p&gt;

&lt;h4&gt;(2) 추가된 세가지 모드&lt;/h4&gt;

&lt;h6&gt;(1) T 모드&lt;/h6&gt;
&lt;h6&gt;(2) H 모드&lt;/h6&gt;
&lt;h6&gt;(3) planar 모드&lt;/h6&gt;

&lt;h4&gt;(3) 특징&lt;/h4&gt;

&lt;p&gt;ETC2 는 OpenGL ES 3.0 이상에서만 사용가능하기 때문에 ES 3.0 을 지원하지 않으면 아예 쓸 수가 없다. 요즈음 모바일 기기들은 꽤 발전하긴 하지만 아직 많이 남아있는 기기들이 OpenGL ES 2.X 버젼까지만 지원한다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(http://www.jacobstrom.com/output.html) 3. ETC2 ETC2 는 ETC 에서 블록의 모드를 더 추가해 다양한 방식으로 표현할 수 있는 텍스쳐 압축 방식이다. 다른 압축 방식들에서는 잉여 공간을 활용해 다른 데이터의 표현 수단으로 사용한 것을 보고, 고안해낸 사람은 ETC 에서도 같은 방식으로 잉여 공간을 찾아 활용할 계획을 한것 같다. 남는 공간은 없었지만 유효하지 않은(invalid) 비트 공간을 활용해 노말 모드, 동차(difference) 모드 외에도 세가지의 표현 방식을 추가했다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 2 Erricsson Texture Compression</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression/" rel="alternate" type="text/html" title="Unity Texture Compression 2 Erricsson Texture Compression" />
      <published>2017-03-12T00:00:00+00:00</published>
      <updated>2017-03-12T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/12/unity-texture-compression-2-erricsson-texture-compression/">&lt;p&gt;모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(&lt;a href=&quot;http://www.jacobstrom.com/output.html&quot;&gt;http://www.jacobstrom.com/output.html&lt;/a&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. ETC(Erricsson Texture Compression)&lt;/h2&gt;

&lt;p&gt;처음 알아볼 압축 방식은 ETC(Erricsson Texture Comperssion) 이다. Jacob Ström&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, Tomas Akenine-Möller 두 사람이 학부 실저에 고안해낸 PACKMAN(2004) 을 더 발전시켜 iPACKMAN(2005) 이라는 학명으로 SIGGRAPH 라는 유명한 컨퍼런스에 등장했다. 이 후 iPACKMAN 의 공식 명칭이 Errcisson Texture Compression(ETC1) 으로 되어 쓰이게 된다. ETC 를 알아보기 전, 먼저 고안된 PACKMAN 을 알아보기로 하자.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h4&gt;(1) PACKMAN?&lt;/h4&gt;

&lt;p&gt;PACKMAN 은 블록 방식의 텍스쳐 압축 기법으로, 직사각형 픽셀 그룹을 만들어 압축한다. RGB 채널이 각각 8bit인 픽셀 8개를(2*4=8) 총 32bit로 압축시킨다. 압축을 안할 시 192bit 이니 1/6 의 공간을 차지하게 압축한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc1_12bit_general_color.png&quot; alt=&quot;12bit_general_color&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;+&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc1_per-pixel_luminance.png&quot; alt=&quot;per-pixel_luminance&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;+&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc1_packman-compressed.png&quot; alt=&quot;packman-compressed&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12bit general color&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;per-pixel_luminance&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;packman-compressed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;PACKMAN 의 정보는 블록에서 평균색(첫번째 그림:general color)과 색 편차가 들어가 있는 테이블의 인덱스를 픽셀별로 기록해(두번째 그림:per-pixel luminance) 평균 색 + 색 편차로 각 픽셀의 색을 결정해 텍스쳐를 구성한다.(세번째 그림:packman-compressed)&lt;/p&gt;

&lt;p&gt;평균색은 말 그대로 픽셀들간의 평균 색이고, 색 편차는 픽셀별로 다른 색들을 평균 색과 비교해서 가장 가까운 편차를 선정한다. 위 문단에서 테이블의 인덱스를 기록한다고 했는데 더 자세하게 알아보기 위해 테이블을 가져왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/etc1_luminance_table.png&quot; alt=&quot;luminancetable&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 표는 자주 사용될만한 색 편차들을 정해놓은 표다. 원래는 4개의 숫자가 한개의 세트로 16세트로 구성되어 있으나, 위 표에는 앞의 8개만 나와있다.&lt;/p&gt;

&lt;p&gt;색 편차 데이터가 구성되는 방식은 8개의 픽셀들간에 가장 오차가 적을만한 table codeword 를 선정한 후 4개의 데이터 중 하나를 골라 인덱스를 저장한다. 색편차를 저장하는 데이터의 종류는 table codeword 와 그 세트안의 인덱스 정보 두개다. 또한 픽셀 인덱스는 픽셀별로 필요하기 때문에 8개가 필요하다.&lt;/p&gt;

&lt;p&gt;색 편차 데이터의 구성 방식을 알아보았으니 전체 색 구성 방식을 알아보자. 필요한 정보와 데이터의 크기는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;픽셀간의 평균색 : RGB444(12bit)&lt;/li&gt;
    &lt;li&gt;테이블 코드워드 : 0~15(4bit)&lt;/li&gt;
    &lt;li&gt;픽셀별 인덱스 : 0~3(2bit)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;평균색은 RGB444 방식으로 12bit로 표현되며, table codeword 는 총 16개가 있으니 4bit 가 필요하다, 그리고 픽셀별 인덱스는 4가지의 숫자만 표현하면 되니 2bit 면 충분하다. 그래서 8개의 픽셀색을 표현하는데 필요한 비트는 12+4+2*8= 32bit 가 필요하다.&lt;/p&gt;

&lt;h4&gt;(2) iPACKMAN?&lt;/h4&gt;

&lt;p&gt;PACKMAN 압축 방식은 문제가 있었다. PACKMAN 방식으로 압축된 이미지와 각 픽셀당 RGB444 로 압축된 이미지를 비교했을 때 휘도(luminance)만 보면 더 좋은 결과를 보여주었지만 색차(chrominance) 면에서 보면 더 안좋은 결과를 보였다. 특히 그라데이션 같이 색이 천천히 바뀌는 이미지에서 색차 밴딩(chrominance banding)이 심했다고 한다. RGB444 방식을 사용해서 작은 차이를 표현하기 어렵고, 한 블록(8개의 픽셀)당 한개의 RGB444 색만 사용하기 때문이다.&lt;/p&gt;

&lt;p&gt;그래서 iPACKMAN 에서는 색차 밴딩을 해결하기 위해 PACKMAN 의 방식에서 변형된 모드를 하나 추가했다. 그 모드 때문에 꽤 많은 부분이 바뀌었다. 모드를 제외한 변경사항은 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;table codeword 가 3bit 로 줄었다.&lt;/li&gt;
    &lt;li&gt;블록의 개념이 2&lt;em&gt;4 픽셀 그룹 하나에서 2&lt;/em&gt;4 픽셀 그룹 두개를 합친 4*4 픽셀 그룹으로 확장됬다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위에서 색차 밴딩이 심하다고 언급했다. 그리고 원인은 RGB444 에 있다고도 말했다. 그래서 데이터의 정밀도를 높이기 위해, 두 2*4 픽셀 그룹의 공간을 합쳐 기존에 독립적으로 2개의 RGB444 색상이 구성되던 방식과 달리 약간의 변화를 주어 RGB555+dRGB333 으로 데이터를 구성하는 방식을 고안해냈다.&lt;/p&gt;

&lt;p&gt;RGB444의 한계를 느끼고 RGB555 로 평균 색을 확장해서 색차의 범위를 확인했다. 20개의 서로 다른 이미지들의 색 편차(deviation)의 통계 데이터를 확인해보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/etc1_histogram_difference_average_color.png&quot; alt=&quot;histogram_difference&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RGB555로 양자화된 평균 색상의 편차 그래프&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;데이터를 보면 대부분 가운데에 몰려있다. 그래서 88%의 데이터를 포함가능한 -4 ~ 3 간격을 타겟으로 RGB555 를 사용후, RGB333 을 편차값으로 사용해 두 블록을 사용하는 방법을 사용했다.&lt;/p&gt;

&lt;p&gt;table codeword 가 3bit 로 줄은 이유는 이미지를 표현할 공간을 만들어야 했기 때문에 다른 것들을 살피다가 table codeword 를 줄인것으로 예측된다. table codeword 는 고정된 색상 편차 테이블의 인덱스인데, 20개의 이미지 테스트에서 3bit 로 줄이는 테스트를 해 보았을 때, 놀랍게도 평균 0.2db 차이가 안나 바꾸었다고 한다.&lt;/p&gt;

&lt;p&gt;table codeword 의 사이즈를 1bit 씩 줄여 2*4 픽셀 그룹이 2개니 2bit 여유 공간이 남았다. 이 공간들은 데이터의 구성을 표현하는 데이터가 된다. 1bit 는 새롭게 추가된 difference mode 냐, normal mode 냐를 표현하는 비트 플래그로, 1bit 는 수직으로 데이터가 구성되는지, 수평으로 데이터가 구성되는지에 대한 비트 플래그로 표현했다.&lt;/p&gt;

&lt;p&gt;직관적으로 데이터 구성을 이해하기 위해 논문에 있던 이미지를 첨부하겠다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://hrmrzizon.github.io/images/etc1_table_diff_vs_normal.png&quot; alt=&quot;histogram_difference&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;데이터 구성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4&gt;(3) 특징&lt;/h4&gt;

&lt;p&gt;ETC 의 특징은 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;모바일 디바이스를 기준으로 한 손실 압축 기법이다.&lt;/li&gt;
    &lt;li&gt;투명하지 않은(Non-Alpha) 텍스쳐(RGB24)를 지원한다. &lt;/li&gt;
    &lt;li&gt;OpenGL ES 2.0 이상 부터 표준 포맷이 되었으며, 안드로이드 프로요(2.2) 부터 공식 지원하기 시작했다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;ETC 는 기본적으로 모바일 디바이스를 타겟으로 만들어진 텍스쳐 압축 알고리즘이다. 그렇기에 구현 방식 또한 상당히 간단하고 명료하다. 보통 ETC 는 OpenGL ES 3.0 아래 버젼을 지원하는 GPU 를 탑재한 디바이스를 지원할 때 주로 사용되는 방식이다. 또한 알파를 설정할 수 없어 상당히 불편한 경우가 많다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;이 사람은 추후 ETC2 연구에도 참여하였다.&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">모든 내용은 전부 Jacob Ström 홈페이지의 자료등을 참고했습니다.(http://www.jacobstrom.com/output.html) 2. ETC(Erricsson Texture Compression) 처음 알아볼 압축 방식은 ETC(Erricsson Texture Comperssion) 이다. Jacob Ström1, Tomas Akenine-Möller 두 사람이 학부 실저에 고안해낸 PACKMAN(2004) 을 더 발전시켜 iPACKMAN(2005) 이라는 학명으로 SIGGRAPH 라는 유명한 컨퍼런스에 등장했다. 이 후 iPACKMAN 의 공식 명칭이 Errcisson Texture Compression(ETC1) 으로 되어 쓰이게 된다. ETC 를 알아보기 전, 먼저 고안된 PACKMAN 을 알아보기로 하자. 이 사람은 추후 ETC2 연구에도 참여하였다.&amp;nbsp;&amp;#8617;</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Unity Texture Compression 1 Start</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start/" rel="alternate" type="text/html" title="Unity Texture Compression 1 Start" />
      <published>2017-03-11T00:00:00+00:00</published>
      <updated>2017-03-11T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/11/unity-texture-compression-1-start/">&lt;p&gt;Unity 로 게임을 개발하던 도중 텍스쳐 압축에 호기심이 생겨 공부하기 + 호기심을 풀기 위해 텍스쳐 압축에 대해 알아보기로 하였다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;1. 텍스쳐 압축(Texture Compression)이란?&lt;/h2&gt;

&lt;h4&gt;1) 뜻&lt;/h4&gt;

&lt;p&gt;일반적으로 압축(Compression) 이란 원본 데이터를 조금 없에거나, 보존해서 파일의 크기를 줄이는 방법을 칭한다. 대표적인 예로 우리가 큰 파일을 전송할 때 압축을 해서 전송하는 경우가 있겠다.(zip, 7z) 이러한 파일 압축 기법들은 모든 데이터를 보존해야 하기 때문에 비손실 압축으로 되어 있다. 하지만 미디어 파일(오디오, 영상, 이미지) 들은 모든 데이터를 저장하지 않고 사람이 인식할 정도만 데이터를 저장하는 비손실 압축 기법이 대부분을 차지한다. (mp3, mp4, jpg) 비 손실 압축방법 중 잘 알려진 포맷은 PNG 포맷이 있다. JPEG, PNG 방식들은 통칭 이미지 압축(Image Compression) 이라 부른다. 하지만 텍스쳐 압축과 이미지 압축의 의미는 조금 다르다.&lt;/p&gt;

&lt;p&gt;텍스쳐 압축(Texture Compression) 위키피디아를 참조해보면 &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Texture compression is a specialized form of designed for storing in rendering systems. Unlike conventional image compression algorithms, texture compression algorithms are optimized for random access.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;문장들을 해석해보면 “텍스쳐 압축은 3D 컴퓨터 그래픽스 렌더링 시스템에서 텍스쳐 맵들을 저장하기위해 고안된 특별한 방식의 이미지 압축이다. 텍스쳐 압축 알고리즘은 전통적인 이미지 압축 알고리즘과 다르게 무작위 접근에 최적화 되어있다.” 라고 한다.&lt;/p&gt;

&lt;p&gt;텍스쳐 압축 알고리즘 자체는 이미지 압축 알고리즘이라 할 수 있다. 하지만 텍스쳐 압축 알고리즘이 이미지 압축과 다른 점은 3D 렌더링 시스템에서 빠르게 접근하기 위해 이미지의 픽셀별로 빠르게 접근이 가능하다는 것이다. 빠르게 접근 한다는 뜻은, &lt;strong&gt;압축된 텍스쳐 데이터 그대로에서 픽셀별로 데이터를 가져올 수 있어야 한다는 뜻이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;대부분의 미디어 압축 포맷에 응용되어 상당히 많이 쓰이는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%9F%B0_%EB%A0%9D%EC%8A%A4_%EB%B6%80%ED%98%B8%ED%99%94&quot;&gt;Run-Length Encoding&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%97%88%ED%94%84%EB%A7%8C_%EB%B6%80%ED%98%B8%ED%99%94&quot;&gt;Huffman Encoding&lt;/a&gt; 방식들은 Encode 된 상태에서 원하는 픽셀의 정보만 가져올려면 모든 데이터를 Decoding 한 후에 가져와야 한다.  즉 저 방식들이 들어간 압축 방식들은 빠른 무작위 접근이 힘들기 때문에 텍스쳐 압축 알고리즘에 응용될 수 없다.&lt;/p&gt;

&lt;h4&gt;2) 쓰임새 &lt;/h4&gt;

&lt;p&gt;실제로 텍스쳐 압축을 사용하려면 요구조건이 몇가지 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;그래픽 시스템(OpenGL, DirectX)에서 텍스쳐 압축을 지원해야 한다.&lt;/li&gt;
    &lt;li&gt;해당 컴퓨터의 GPU 에서 텍스쳐 압축을 지원해야 한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;자주 사용되는 텍스쳐 압축 방식은 그래픽 시스템에서 지원한다. 그래픽 시스템에 대한 걱정은 안해도 된다. 하지만 GPU 에서 지원하는 텍스쳐 압축 방식들은 알아야 한다. GPU 에서 지원하는 압축 포맷의 경우 압축된 데이터를 알아서 디코딩하지만, 지원 안하는 포맷의 경우 SW 디코딩을 하거나, 다른 포맷으로 바꿔주어야 한다.&lt;/p&gt;

&lt;p&gt;스마트폰을 예로 들면, 모바일 플랫폼은 GPU 의 종류가 4가지가 넘고, GPU 별, GPU 제조사 별로 지원하는 텍스쳐 압축 방식이 다 다르다.&lt;/p&gt;

&lt;p&gt;대표적으로 Apple 의 모바일 기기에서 쓰이는 Apple A~ 칩셋들은 모두 PowerVR GPU를 탑재했고, PowerVR GPU 는 PVRTC(PowerVR Texture Compression) 만 지원한다. Apple 제품군에서는 PVRTC 만 쓰면 된다.&lt;/p&gt;

&lt;p&gt;이에 반해 다양한 Android 기기들은 다양한 GPU 를 탑재해서 (QualComn Adreno, ARM Mali 등..) 더욱더 다양한 종류의 텍스쳐 압축 기법이 존재한다. Android 기반의 디바이스들은 거의 다 ETC1 을 지원하기 때문에 대표적으로 사용이 가능하긴 하다. 하지만 몇몇 기기가 PowerVR GPU 를 탑재하기 때문에&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; ETC1 만 사용할 수는 없다.&lt;/p&gt;

&lt;p&gt;즉 하나의 모바일 어플리케이션에서 모든 방식을 선택하기는 힘들다. 모든 방식을 지원하려면 다양한 방식의 리소스가 필요한데, 그러면 응용 프로그램의 용량이 엄청나게 될 것이다. 그래서 몇 가지 디바이스를 포기하거나, Unity 에서는 &lt;a href=&quot;https://docs.unity3d.com/kr/current/Manual/AssetBundlesIntro.html&quot;&gt;AssetBundle&lt;/a&gt;의 힘을 빌려 &lt;a href=&quot;http://dragonjoon.blogspot.kr/2015/08/blog-post.html&quot;&gt;&lt;strong&gt;이런 방법&lt;/strong&gt;&lt;/a&gt;을 쓸 수도있다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;대표적으로 삼성 Exynos 3110, 5410 이 있다. 쓰인 기기는 갤럭시 S, 갤럭시 탭 7.0, 갤럭시 S4&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="unity" />
      
        <category term="texture_compression" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">Unity 로 게임을 개발하던 도중 텍스쳐 압축에 호기심이 생겨 공부하기 + 호기심을 풀기 위해 텍스쳐 압축에 대해 알아보기로 하였다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Make Jekyll+github Blog 1</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1/" rel="alternate" type="text/html" title="Make Jekyll+github Blog 1" />
      <published>2017-03-08T00:00:00+00:00</published>
      <updated>2017-03-08T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/08/make-jekyll+github-blog-1/">&lt;p&gt;아는 지인이 좋다고 추천해서 jekyll+github 으로 블로그를 만들게 되었다.
한글로 된 자료가 그리 많지 않아 직접 기록해보려 한다.&lt;/p&gt;

&lt;h2&gt;개요&lt;/h2&gt;

&lt;p&gt;원리는 간단하다. GitHub 에서 jekyll 로 만들어진 블로그 백엔드 서비스(BaaS)를 지원하고, 사용자는 일정한 형식으로 레포지토리를 구성하면 블로그가 짠! 하고 나타난다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;GitHub 에서 작업할 것들&lt;/h2&gt;

&lt;p&gt;순서는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;GitHub 계정이 없을 시 가입하기&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;GitHub 에 블로그 레포지토리 만들기&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3&gt;GitHub 가입하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/github_homepage_signup.png&quot; alt=&quot;Github.com&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com&quot;&gt;Github.com&lt;/a&gt;에서 가입하면 된다. 가입 절차는 간단하니 직접 해보라.&lt;/p&gt;

&lt;h3&gt;GitHub 에 블로그 레포지토리 만들기&lt;/h3&gt;

&lt;p&gt;하나의 저장소를 만든다. 이때 중요한 것은 레포지토리 이름을 반드시 “&lt;strong&gt;(닉네임)&lt;/strong&gt;.githum.com” 으로 적어주여야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/github_make_repo.png&quot; alt=&quot;make_repo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 말이다. 우리는 원격 블로그 저장소를 만들었다. 이제 저장할 블로그 내용물을 만들 차례다.&lt;/p&gt;

&lt;h2&gt;블로그 만들기&lt;/h2&gt;

&lt;p&gt;Github 에서는 Ruby 로 만들어진 Jekyll 프레임워크 기반의 블로그를 지원한다. 즉 Jekyll 로 블로그를 만들어 GitHub 레포지토리에 올리면 잘 보인다. 만들어진 GitHub 레포지토리를 들어가보면 기본적으로 만들어진 블로그가 있다. 포스팅이 가능하고 기본적인 정보를 올릴 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 이 블로그는 만들어진 테마를 가져와서 세팅하는 것이기 때문에 내 멋대로 커스터마이징이 힘들다. 그렇다고 직접 스킨을 만들기에는.. 아무것도 모르는 사람이 처음부터 직접 만들기는 힘들다. 그러면 다른 사람이 만들어진걸 가져다 쓰는게 가장 빠르고 간편한 방법이다.&lt;/p&gt;

&lt;h3&gt;만들어진 테마 가져오기&lt;/h3&gt;

&lt;p&gt;우선 &lt;a href=&quot;https://jekyllthemes.org&quot;&gt;jekyll 테마 홈페이지&lt;/a&gt;이나 github에서 민들어진 jekyll 테마들을 찾아볼 수 있다. github 에서 가져오거나, &lt;a href=&quot;https://jekyllthemes.org&quot;&gt;jekyll 테마 홈페이지&lt;/a&gt;에서 직접 파일을 받아 쓸 수 있다.&lt;/p&gt;

&lt;h4&gt;1. GitHub 에서 테마 가져오기&lt;/h4&gt;

&lt;p&gt;여러 방법이 있지만 필자는&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;clone 해서 로컬 저장소를 만든다.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;연결된 remote repository 를 블로그 repository 로 바꾼다.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 방식으로 진행했다.&lt;/p&gt;

&lt;p&gt;GitHub 에서 원하는 jekyll 테마를 clone 해준다. 이 글을 쓸 무렵 필자는 &lt;a href=&quot;https://github.com/yous/whiteglass&quot;&gt;whiteglass&lt;/a&gt; 테마를 사용했었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/github_jekyll_whiteglass_theme.png&quot; alt=&quot;whiteglass_theme&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git clone {other’s url}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 그림의 위치에서 url 을 복사해 세팅할 디렉토리에 위와 같이 입력해주면 된다.&lt;/p&gt;

&lt;p&gt;clone 을 한 후에는 가져온 remote repository 가 연결되어 있을 것이다. 일단 확인부터 해보자. 우선 프로젝트 루트 디렉토리로 이동해 shell 을 키고 아래 커맨드를 입력한다&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote -v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그럼 아마도 아래와 같이 나올것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;origin (other’s-url) (fetch)&lt;/p&gt;

  &lt;p&gt;origin (other’s-url) (push)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;잘 살펴보면 알겠지만 중간에 들어간 url 은 가져온 프로젝트의 url 이다. 변경하려면 다음과 같이 하면된다&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote remove origin // 등록된 origin을 지운다.
git remote add origin &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;repository-url&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; // 본인 블로그 레포지토리 url 을 등록시켜 준다.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그 다음 다시 등록된 remote repository 를 확인해보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote -v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;등록한 url 로 나오면 성공이다. 이제 연결을 해주었으니 원할 때 remote repository 로 보내면 된다.&lt;/p&gt;

&lt;p&gt;정석인 방법은 원본 프로젝트를 fork 해서 나의 레포지토리로 바꾼 후 수정을 거쳐 하는것이지만, 언제 스킨을 바꿀지 모르기에 위 방식대로 진행했다.&lt;/p&gt;

&lt;h4&gt;2. jekyll 테마 프로젝트를 구해서 설정하기&lt;/h4&gt;

&lt;p&gt;이 방법도 크게 다르지 않다. 단지 local repository의 설정이 다를뿐이다. 아래와 같이 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;jekyll 테마 프로젝트의 루트 디렉토리에서 git 저장소로 설정한다.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;블로그 repository 를 remote repository 로 등록시켜 준다.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 방식으로 진행했다.&lt;/p&gt;

&lt;p&gt;프로젝트의 루트 디렉토리로 shell 을 이동해 아래와 같이 명령을 입력해준다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git init&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;맨 처음 local repository로 설정해주는 명령어다. 인자가 따로 필요없이 그냥 저렇게만 쳐주면 된다.&lt;/p&gt;

&lt;p&gt;기존에 연결된 remote repository 가 없으니 바로 remote repository 를 설정해주면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;git remote add origin &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;repository-url&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; // 본인 블로그 레포지토리 url 을 등록시켜 준다.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;여기까지 하면 local repository 를 설정하는건 끝이다.&lt;/p&gt;

&lt;h3&gt;jekyll 개발환경 설정하기&lt;/h3&gt;

&lt;p&gt;테마까지 로컬 저장소에 설정을 해놓았으니 컴퓨터에서 가상의 서버를 돌려가면서 본인의 포스팅을 확인할 환경을 만들어 주어야 한다. 물론 세팅을 하지않고 포스팅을 할수는 있다. 변경하고 push 하고, 확인하고, 변경후 push하고 확인하는 루틴이 계속될 것이다.&lt;/p&gt;

&lt;p&gt;하지만 위에서 말한 방법은 &lt;em&gt;매우&lt;/em&gt; 귀찮다. 쓰는대로 바로바로 진행이 되어야 편할 것이라 생각했기에 직접 jekyll 개발환경을 세팅하는 방향을 선택했다.&lt;/p&gt;

&lt;p&gt;리눅스 계열 OS 를 사용하는 개발자들은 대부분 구버젼의 Ruby 가 깔려 있겠지만 Windows 환경에서는 전혀 그런게 없다. 그래서 필자는 직접 설치 해주었다. &lt;a href=&quot;https://rubyinstaller.org&quot;&gt;Ruby installer&lt;/a&gt; 사이트에 들어가면 간단하게 isntaller 만 받아 설치를 해줄 수 있다. 설치 과정 중 환경변수(Path) 설정하는 옵션을 설정하면 간단하게 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;bundler&lt;/em&gt; 라는 툴을 깔아주어야 한다. 쉘에서 많이 사용하며 Ruby 의 불편한 의존성 관리를 도와주는 툴이라고 한다. jekyll 에서는 기본적으로 &lt;em&gt;bundler&lt;/em&gt; 를 사용하기 때문에 꼭 설치해주어야 한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;gem install bundler&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 jekyll 만 깔아주면 개발 환경 구축은 끝이다. 아래 명령어를 입력하자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;gem install jekyll&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3&gt;로컬 환경에서 블로그 확인하기&lt;/h3&gt;

&lt;p&gt;모든 세팅이 다 끝났다면 이제 블로그를 직접 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;jekyll serve&lt;/p&gt;

&lt;p&gt;위 명령어를 입력 후, 루프백 IP(127.0.0.1)나, localhost 도메인을 통해 블로그 서버를 직접 확인할 수 있다. 참고로 jekyll 은 4000 포트를 쓰니 참고 바란다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="jekyll" />
      
        <category term="makeblog" />
      
        <category term="try" />
      

      

      
        <summary type="html">아는 지인이 좋다고 추천해서 jekyll+github 으로 블로그를 만들게 되었다. 한글로 된 자료가 그리 많지 않아 직접 기록해보려 한다. 개요 원리는 간단하다. GitHub 에서 jekyll 로 만들어진 블로그 백엔드 서비스(BaaS)를 지원하고, 사용자는 일정한 형식으로 레포지토리를 구성하면 블로그가 짠! 하고 나타난다.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Ue4 Vs Unity5</title>
      
      <link href="https://hrmrzizon.github.io/2017/03/05/ue4-vs-unity5/" rel="alternate" type="text/html" title="Ue4 Vs Unity5" />
      <published>2017-03-05T00:00:00+00:00</published>
      <updated>2017-03-05T00:00:00+00:00</updated>
      <id>https://hrmrzizon.github.io/2017/03/05/ue4-vs-unity5</id>
      <content type="html" xml:base="https://hrmrzizon.github.io/2017/03/05/ue4-vs-unity5/">&lt;h3&gt;&lt;em&gt;이 글은 강의를 듣는 분들을 위해 작성된 심심풀이 땅콩같은 글임을 알립니다. &lt;strong&gt;절대&lt;/strong&gt; 논란의 여지가 되고 싶지 않습니다.&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Unity 로 게임 개발을 시작한지 약 2년이 넘었습니다. 이제 언리얼 엔진 4에 발을 들여놓으려고 합니다. 막 파악하면서 느낀 점을 적어보려고 합니다. 기존 개발을 해오던 분들과 의견이 다를수도 있으니 너그러운 마음으로 읽어주시길 바랍니다.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h2&gt;Overview 의 차이&lt;/h2&gt;

&lt;p&gt;문서를 읽으면서, 예제를 실험해보면서 느낀 점은, 둘의 스케일이 다르다는 것 입니다. Unity 는 비교적 간단하고 심플한 구조를 가진 반면, Unreal Engine 4 는 복잡하나 엔진 차원에서 많은 것을 지원하려 하는 것이 보입니다.&lt;/p&gt;

&lt;h3&gt;게임 시스템&lt;/h3&gt;

&lt;p&gt;게임 시스템을 보면, Unity 는 Scene 이란 GameObject 들의 계층 구조의 집합을 정의해놓고 모든 로직이 그 안에서 돌아가게 합니다. GameObject 들은 여러 Component 들을 붙이거나 뗄 수 있습니다. CBD 기반이지요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unity_HierarchyWindowCallout.png&quot; alt=&quot;Unity Hierarchy 뷰어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Unrealengine 에서는 레벨이란 단위안에 지형, 액터등 많은 것들을 가지고 사용자가 직접 로드하게 하거나 자동으로 로드해줍니다. 또한 여러 오브젝트들에 하위 컴포넌트나, Blueprint 스크립트를 붙일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/unityandue4.jpg&quot; alt=&quot;Unity 와 UE4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unrealengine.com/latest/INT/GettingStarted/FromUnity/index.html&quot;&gt;Unrea Engine 4 For Unity Developers&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;개발 언어 환경&lt;/h3&gt;

&lt;p&gt;Unity 는 C#, JavaScript, Boo 이 세 가지 언어로 개발을 할 수 있습니다. 특히 가장 유명한 것은 C# 이겠지요. Mono 프로젝트의 공이 크다고 생각됩니다. 현 세대의 아주 강력한 Miscrosoft 에서 주도하는 언어 C# 을 모든 플랫폼에서 개발을 가능하게 만들고, Unity 에서는 이를 채택해 거의 모든 플랫폼의 개발이 가능해졌지요. 게다가 Mono 프로젝트를 이끌던 Xamarin 회사는 작년에 Miscrosoft 에서 인수했다는 소식이 있었습니다. 하여튼 Unity 는 C# 과 함께 성장할것 같이 보입니다.&lt;/p&gt;

&lt;p&gt;Unreal Engine 4 은 C++, Blueprint 로 개발이 가능합니다. C++ 은 OOP 언어의 대부분이 가지고 있는 리플렉션의 개념이 없습니다. 쓰더라도 전처리 과정에서만 가능하지요. 하지만 Unreal Engine 4 에서는 시스템을 덧붙여 가능하게 만들었습니다. 또한 코드 타이핑을 하지 않고 GUI 로 프로그래밍이 가능한 BluePrint 라는 강력한 방법도 지원합니다. 가장 놀라운 점은 이 기능들을 자체적으로 만든 것입니다.&lt;/p&gt;

&lt;h2&gt;Unreal Engine 4 의 장점?&lt;/h2&gt;

&lt;p&gt;Unreal Engine 4 의 장점 몇가지를 뽑아보겠습니다.&lt;/p&gt;

&lt;p&gt;첫 항목에 규모가 크다는 말을 했었습니다. 전문화된 툴이 정말 많습니다. 시네마틱을 제작하는 시퀀서, 3D 모델, 애니메이션 정보들을 편집 가능한 스켈레톤 시스템, AI 를 위한 비헤이비어 트리 시스템 등 많은 기능들을 지원합니다.&lt;/p&gt;

&lt;p&gt;두번째로는 엔진 자체가 오픈 소스이고, 엔진 구현에 관한 문서들이 자세하게 잘 설명되어 있습니다. 오픈 소스인 만큼 엔진 자체에 문제가 생겼을 시 직접 소스코드를 수정해 사용이 가능하고, GitHub 페이지를 사용해 문제를 제기할 수 있어 “공생” 이라는 슬로건에 알맞는 정책입니다. 상세한 문서화는 Unreal Engine 4 를 처음 접하는 개발자도, 개발에 쓰고있는 개발자들에게도 많은 도움을 줍니다.&lt;/p&gt;

&lt;p&gt;마지막은 언리얼 데브 그랜트 라는 정책이 있습니다. 이는 Unreal Engine 으로 개발된 가능성 있는 게임들을 신청받아 한화로 약 5백만원에서 5천만원 사이의 지원금을 보조하는 정책입니다. 지원금의 사용은 자유로우며 지적재산권도 개발사가 소유합니다. 아무런 권리도 가져가지 않고 지원하는 것이지요.&lt;/p&gt;

&lt;h2&gt;마지막으로&lt;/h2&gt;

&lt;p&gt;Unreal Engine 4 는 특별한 움직임은 보이지 않습니다. 하지만 여태까지 했던 것들만 해도 정말 대단합니다. 약 2,3달 간격의 버젼업은 무릎을 탁 치다 못해 탈골될 지경이지요. 자체적으로 보유한 기술을 따지면.. 엄청난 가치들이 있습니다.&lt;/p&gt;

&lt;p&gt;Unity 는 2017 버젼과 Unity5 마지막 버젼을 앞에 두고 있습니다. 이전에 릴리즈된 Unity 5.5 버젼에서는 꽤 발전된 모습을 보여주었습니다. 가장 돋보이는 점은 Mono C# 컴파일러 버젼을 Mono 4.4 버젼으로 업그레이드 한 것입니다. 드디어 4버젼부터 가져오던 Mono 프레임워크 문제를 해결하려 하는게 보입니다.&lt;/p&gt;

&lt;p&gt;둘다 장단점이 있지만 여태까지 행보를 보면 Unreal Engine 4 가 우세하다고 봅니다. 표면적으로 드러난 기술력, 자본만 보아도 엔진 자체만 보더라도 말이지요. 하지만 앞일은 모르니 조금 더 지켜봐야할 필요는 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Su-Hyeok Kim</name>
          
          
        </author>
      

      
        <category term="edu" />
      
        <category term="ue4" />
      
        <category term="analysis" />
      

      

      
        <summary type="html">이 글은 강의를 듣는 분들을 위해 작성된 심심풀이 땅콩같은 글임을 알립니다. 절대 논란의 여지가 되고 싶지 않습니다. Unity 로 게임 개발을 시작한지 약 2년이 넘었습니다. 이제 언리얼 엔진 4에 발을 들여놓으려고 합니다. 막 파악하면서 느낀 점을 적어보려고 합니다. 기존 개발을 해오던 분들과 의견이 다를수도 있으니 너그러운 마음으로 읽어주시길 바랍니다.</summary>
      

      
      
    </entry>
  
  
</feed>
