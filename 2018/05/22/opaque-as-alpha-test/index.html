<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Opaque As Alpha Test</title>
  <meta name="description" content="Shader 에서 샘플링하는 Texutre 에서 Alpha 값을 가지고 있어, Alpha 을 참조해서 실제 픽셀에 출력을 하는지 안하는지를 결정하는 것을 Alpha Test 라고 한다. 이런 Material 이나 Texture 를 Cutout 이라고 통칭하는 경우가 많다. 보통 게임에서의 Alpha Test 를 사용하는 것들은 나무, 풀 같은 식생들(Vegetation)이 있고, 중간에 구멍이 뚫린 펜스같은 것들도 존재한다. 자연을 배경으로하는 게임의 경우에는 식생들이 굉장히 많기 때문에 Alpha Test 를 사용하는 Shader 가 굉장히 많이 사용될 것이다. 출처 : Anti-aliased Alpha Test: The Esoteric Alpha To Coverage 하지만 Alpha Test 는 굉장히 큰 단점이 있다. 고정된 화면 해상도에서 물체가 작게 표현되면 물체를 표현할 수 있는 픽셀의 숫자가 많이 작아진다. 물체를 표현하는 픽셀의 수가 작아지게 되면 일반적으로 해당 넓이에 맞게 생성된 Texture 의 Mip-level 에 접근한다. 중간의 Alpha Test 그림을 보면된다. 출처 : Anti-aliased Alpha Test: The Esoteric Alpha To Coverage 실제로는 양 옆의 물체들처럼 자연스럽게 표현이 되야하지만 일반적인 Alpha Test 를 사용하게 되면 위와 같은 현상에 마주치게 된다. 이는 굉장히 끔찍한 현상이다. 실제 게임을 해보거나, 만들어본 사람이라면 안다. 대부분의 픽셀에 나무가 표현되고, 잎사귀들이 저런식으로 자글자글 거린다면 약간의 불쾌함이 느껴진다. VR 이라면 더욱.. 그래서 급하게 대처방안으로 나온 것이 위 그림의 오른쪽에 나오는 Alpha to Coverage 라는 방법이다. 이는 하드웨어 MSAA 를 픽셀 쉐이더의 결과를 통해 자동으로 해주는것으로, MSAA 의 퍼포먼스와 비례한다. MSAA 는 성능이 영 좋지않아 안쓰는 경우가 꽤 많이 존재하기 때문에 Alpha to Coverage 는 절대적으로 사용할 수 있는 방법은 아니다. 게다가 엄청나게 많은 나무를 Alpha to Coverage 를 쓴다면.. 성능은 안봐도 뻔하다. 앞서 말한 Alpha Test 은 Material, Shader 별로 고정된 Alpha 값을 설정해 그 이하가 되면 Pixel Shader 에서 결과를 내놓지 않게 하는(Discard) 방법이였다. Alpha Test 의 문제는 샘플링한 Alpha 값이 가끔 극단적으로 낮아서 Discard 되는 것인데, 이를 간단하게 해결하기 위해 요상한 방법이 등장했다. 바로 Stochastic test 라는 방법이다. 출처 : NVidia developer : Hashed Alpha Testing 위 그림에서 위쪽에 있는 것이 일반적인 Alpha Test 인데, color.a 는 텍스쳐에서 샘플링한 Alpha 값, ατ 는 Alpha Test 를 위한 고정된 Alpha Threshold(알파한계)다. 밑의 코드에서 drand48 이 나타내는 것은 단순한 0 ~ 1 사이의 랜덤값이다. 즉 랜덤하게 Alpha Threshold 를 설정해주어 물체가 멀어져서 평균 Alpha 값이 낮아질 때도 픽셀이 Discard 되지 않도록 하는 것이다. 하지만 이는 굉장한 눈아픔? 반짝거림? 을 유발한다. 범위를 지정해주지 않았기 때문에 이전 프레임에서 출력된 픽셀이 다음 프레임에서는 출력되지 않을 수도 있다. 이렇게 각 프레임마다 상황이 달라서 생기는 현상앞에 Temporal 을 붙인다. Stochastic Alpha Test 의 문제는 Temporal Flickering 이라고 할 수 있겠다. Temporal Stability(임시적 안정성) 을 확보하기 위해서는 Alpha Threshold 를 이러저리 튀지 않게해야 했고, 이를 위해 특정 값에 따라서 Hash 값을 생성하는 방법이 고안되었다. 이 방법은 Hashed Alpha Test 라는 이름으로 작년에 공개되었다. 참조 Anti-aliased Alpha Test: The Esoteric Alpha To Coverage NVidia developer : Hashed Alpha Testing">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/2018/05/22/opaque-as-alpha-test/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Opaque As Alpha Test">
  <meta name="twitter:description" content="Shader 에서 샘플링하는 Texutre 에서 Alpha 값을 가지고 있어, Alpha 을 참조해서 실제 픽셀에 출력을 하는지 안하는지를 결정하는 것을 Alpha Test 라고 한다. 이런 Material 이나 Texture 를 Cutout 이라고 통칭하는 경우가 많다. 보통 게임에서의 Alpha Test 를 사용하는 것들은 나무, 풀 같은 식생들(...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Opaque As Alpha Test</h1>
    
    <p class="post-meta"><time datetime="2018-05-22T00:00:00+00:00" itemprop="datePublished">May 22, 2018</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/alphatest/">alphatest</a>,
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>Shader</em> 에서 샘플링하는 <em>Texutre</em> 에서 <em>Alpha</em> 값을 가지고 있어, <em>Alpha</em> 을 참조해서 실제 픽셀에 출력을 하는지 안하는지를 결정하는 것을 <em>Alpha Test</em> 라고 한다. 이런 <em>Material</em> 이나 <em>Texture</em> 를  <em>Cutout</em> 이라고 통칭하는 경우가 많다.</p>

<p>보통 게임에서의 <em>Alpha Test</em> 를 사용하는 것들은 나무, 풀 같은 식생들(<em>Vegetation</em>)이 있고, 중간에 구멍이 뚫린 펜스같은 것들도 존재한다. 자연을 배경으로하는 게임의 경우에는 식생들이 굉장히 많기 때문에 <em>Alpha Test</em> 를 사용하는 <em>Shader</em> 가 굉장히 많이 사용될 것이다.</p>

<p><br />
<img src="/images/1_8EKqWSOOPXaTrDHVFTACJg.png" alt="Wikipedia : Single-precision floating-point format" class="center-image" /></p>
<center>출처 : <a href="https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">Anti-aliased Alpha Test: The Esoteric Alpha To Coverage</a>
</center>
<p><br /></p>

<p>하지만 <em>Alpha Test</em> 는 굉장히 큰 단점이 있다. 고정된 화면 해상도에서 물체가 작게 표현되면 물체를 표현할 수 있는 픽셀의 숫자가 많이 작아진다. 물체를 표현하는 픽셀의 수가 작아지게 되면 일반적으로 해당 넓이에 맞게 생성된 <em>Texture</em> 의 <em>Mip-level</em> 에 접근한다. 중간의 <em>Alpha Test</em> 그림을 보면된다.</p>

<p><br />
<img src="/images/1_zNbZFiJXjcqqyTkM9eEt7w.gif" alt="Wikipedia : Single-precision floating-point format" class="center-image" /></p>
<center>출처 : <a href="https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">Anti-aliased Alpha Test: The Esoteric Alpha To Coverage</a>
</center>
<p><br /></p>

<p>실제로는 양 옆의 물체들처럼 자연스럽게 표현이 되야하지만 일반적인 <em>Alpha Test</em> 를 사용하게 되면 위와 같은 현상에 마주치게 된다. 이는 굉장히 끔찍한 현상이다. 실제 게임을 해보거나, 만들어본 사람이라면 안다. 대부분의 픽셀에 나무가 표현되고, 잎사귀들이 저런식으로 자글자글 거린다면 약간의 불쾌함이 느껴진다. VR 이라면 더욱..</p>

<p>그래서 급하게 대처방안으로 나온 것이 위 그림의 오른쪽에 나오는 <em>Alpha to Coverage</em> 라는 방법이다. 이는 하드웨어 <em>MSAA</em> 를 픽셀 쉐이더의 결과를 통해 자동으로 해주는것으로, <em>MSAA</em> 의 퍼포먼스와 비례한다. <em>MSAA</em> 는 성능이 영 좋지않아 안쓰는 경우가 꽤 많이 존재하기 때문에 <em>Alpha to Coverage</em> 는 절대적으로 사용할 수 있는 방법은 아니다. 게다가 엄청나게 많은 나무를 <em>Alpha to Coverage</em> 를 쓴다면.. 성능은 안봐도 뻔하다.</p>

<p>앞서 말한 <em>Alpha Test</em> 은 <em>Material</em>, <em>Shader</em> 별로 고정된 <em>Alpha</em> 값을 설정해 그 이하가 되면 <em>Pixel Shader</em> 에서 결과를 내놓지 않게 하는(<em>Discard</em>) 방법이였다. <em>Alpha Test</em> 의 문제는 샘플링한 <em>Alpha</em> 값이 가끔 극단적으로 낮아서 <em>Discard</em> 되는 것인데, 이를 간단하게 해결하기 위해 요상한 방법이 등장했다.</p>

<p>바로 <em>Stochastic test</em> 라는 방법이다.</p>

<p><br />
<img src="/images/stochastic_sampling.png" alt="NVidia deverloper : Hashed Alpha Testing" class="center-image" /></p>
<center>출처 : <a href="https://developer.download.nvidia.com/assets/gameworks/downloads/regular/GDC17/RealTimeRenderingAdvances_HashedAlphaTesting_GDC2017_FINAL.pdf?pUIX8DXxfad7mL4zB3GOthX3r5IgGao9UWxYuYb3q9h10RXrQeYko-dEuJXJxt1hhsI9J_9KJDcCYGeWWksxlaHTrXSE825D_3izja7LUFOtzhaeBUqpn7qbwXaaGlLdbipjE3PeI3e2IMn45mQAA3OV2PD-kG2y9cecTaWE2uum2uwdHgyn0nhYiLOvlOsrUzewbK5REH7vAm3-lNWzxehw_5Tphg">NVidia developer : Hashed Alpha Testing</a>
</center>
<p><br /></p>

<p>위 그림에서 위쪽에 있는 것이 일반적인 <em>Alpha Test</em> 인데, <em>color.a</em> 는 텍스쳐에서 샘플링한 <em>Alpha</em> 값, <em>ατ</em> 는 <em>Alpha Test</em> 를 위한 고정된 <em>Alpha Threshold</em>(<em>알파한계</em>)다. 밑의 코드에서 <em>drand48</em> 이 나타내는 것은 단순한 0 ~ 1 사이의 랜덤값이다. 즉 랜덤하게 <em>Alpha Threshold</em> 를 설정해주어 물체가 멀어져서 평균 <em>Alpha</em> 값이 낮아질 때도 픽셀이 <em>Discard</em> 되지 않도록 하는 것이다.</p>

<p>하지만 이는 굉장한 눈아픔? 반짝거림? 을 유발한다. 범위를 지정해주지 않았기 때문에 이전 프레임에서 출력된 픽셀이 다음 프레임에서는 출력되지 않을 수도 있다. 이렇게 각 프레임마다 상황이 달라서 생기는 현상앞에 <em>Temporal</em> 을 붙인다. <em>Stochastic Alpha Test</em> 의 문제는 <em>Temporal Flickering</em> 이라고 할 수 있겠다.</p>

<p><em>Temporal Stability</em>(임시적 안정성) 을 확보하기 위해서는 <em>Alpha Threshold</em> 를 이러저리 튀지 않게해야 했고, 이를 위해 특정 값에 따라서 <em>Hash</em> 값을 생성하는 방법이 고안되었다. 이 방법은 <em>Hashed Alpha Test</em> 라는 이름으로 작년에 공개되었다.</p>

<!--
  Hashed Alpha Test
  Alpha Distribution
-->

<h2>참조</h2>

<ul>
  <li><a href="https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">Anti-aliased Alpha Test: The Esoteric Alpha To Coverage</a></li>
  <li><a href="https://developer.download.nvidia.com/assets/gameworks/downloads/regular/GDC17/RealTimeRenderingAdvances_HashedAlphaTesting_GDC2017_FINAL.pdf?pUIX8DXxfad7mL4zB3GOthX3r5IgGao9UWxYuYb3q9h10RXrQeYko-dEuJXJxt1hhsI9J_9KJDcCYGeWWksxlaHTrXSE825D_3izja7LUFOtzhaeBUqpn7qbwXaaGlLdbipjE3PeI3e2IMn45mQAA3OV2PD-kG2y9cecTaWE2uum2uwdHgyn0nhYiLOvlOsrUzewbK5REH7vAm3-lNWzxehw_5Tphg">NVidia developer : Hashed Alpha Testing</a></li>
</ul>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://zizon.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Su-Hyeok Kim - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
