<!DOCTYPE html>
<html lang="ko">

  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Appocrypha</title>
  <meta name="description" content="store limitless knowledges">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Appocrypha">
  <meta name="twitter:description" content="store limitless knowledges">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2019/07/11/what-is-color-spaces-and-gamuts/">What Is Color Spaces And Gamuts</a>
          </h1>

          <p class="post-meta">Jul 11, 2019 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/color/">color</a>,
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/colorimetry/">colorimetry</a>
    
  

</p>
        </header>

        <div class="post-content">
          <p>HDR 에 대한 내용들을 찾다보면 <em>color space</em> 에 대한 개념을 기본적으로 알고 있어야 수학적인 내용을 배울 때 단계적으로 학습해야 하는 것처럼 대부분의 내용들을 쉽게 이해할 수 있다. 필자의 경우 이에 대한 학습이 전혀 없었고, 직접 자료를 찾아보기 전까지 무슨 소리인지 전혀 몰랐던 상태였다. 다행히 여러 분야에 걸쳐 꽤 많이 알려진 지식들이고 받아들이기에 어려운 개념은 아니라서 이에 대해 글을 쓰면서 정리해보려 한다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2019/07/11/what-is-color-spaces-and-gamuts/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2019/07/02/what-is-srp-batcher-in-unity/">What Is Srp Batcher In Unity</a>
          </h1>

          <p class="post-meta">Jul 2, 2019 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/srp-batcher/">srp_batcher</a>
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity의 SRP 의 개발과 같이 여러 기능들이 생겨나는 것 같다. 아마도 기존의 Unity 의 렌더링 모듈들을 최대한 개선하려는 시도로 보인다. 이번 년초에 공개된 <em>SRP Batcher</em> 또한 효율을 개선하기 위한 것으로 보인다.</p>

<p>종종 보이는 용어 <em>batch</em> 라는 용어는 “한꺼번에 처리한다.” 라는 뜻으로 보통 쓰인다. 일반적인 렌더링 시스템에서의 <em>batch</em> 는 최소한의 drawcall-driver overhead- 을 위해 렌더링할 것들의 데이터들을 최대한 묶어주는 시스템의 기능을 말하기 위해 사용되는 것 같다. 그리고 Unity 또한 기존의 <em>built-in batcher</em> 시스템이 존재한다. 근데 이에 성능을 향상시키기 위해 <em>SRP batcher</em> 라는게 만들어 졌다고 한다. 이는 곧 기존의 <em>built-in batcher</em> 시스템에 비효율적인 부분이 존재한다는 것을 알 수 있다.</p>

<p>Unity를 사용을 하다보면 알 수 있지만, MeshRenderer 컴포넌트의 같은 쉐이더에 다른 파라미터를 가진 Material 을 추가하거나 바꾸게 되면 DrawCall 이 바꾼 Material 의 갯수에 비례해서 올라가는 것을 알 수 있다. 문제는 이게 <em>static batch</em> 든 <em>dynamic batch</em> 든 무조건 일어난다는 것에 문제가 있다. directX 에 직접 맞닿아본 적은 없지만 Unity로 Shader Model 5.0 부터 접한 필자로써는 이해가 잘 되지 않는 상황이였다.</p>

<p>문제는 Unity Blog의 해당 포스팅을 보면 알 수 있지만(<a href="https://blogs.unity3d.com/2019/02/28/srp-batcher-speed-up-your-rendering/">링크</a>), Unity 자체가 dx9 레벨을 지원하면서 만들어졌으며, 여러 API(dx11)를 지원하려 하다보니 해당 API의 특징을 잘 사용하지 못한채 <em>built-in batcher</em> 가 만들어진 듯 했다. 아래에는 <em>built-in batcher</em> 시스템을 나타낸 그림이다.</p>

<p><br />
<img src="https://blogs.unity3d.com/wp-content/uploads/2019/02/SRP-Batcher-OFF.png" alt="built-in batcher" class="center-image" /></p>
<center>출처 : <a href="https://solitaryroad.com/c1003.html">Unity Blog : SRP Batcher: Speed up your rendering!
</a>
<br />
</center>
<p><br /></p>

<p>위와 같은 시스템이라면, 무조건 메터리얼이 바뀌면 이들의 정보를 갱신하기 위해 전체를 다 처리하는 코드로 되어있는 듯 하다. 하지만 여기서 조금 더 생각해보면, <em>Material</em> 과 각 오브젝트들의 <em>Transformation</em> 정보들은 다른 정보라고 할 수 있다. 그렇다면 이들을 한꺼번에 처리하는게 아니라, <em>Material</em>, <em>Transformation</em> 정보를 나누어서 갱신하면 <em>Material</em> 을 바꿀 때, 쉐이더 코드가 바뀌지 않는다면, <em>DrawCall</em> 이 늘어나지 않도록 할 수 있겠다. 문서에는 다른 <em>Material</em> 이지만 <em>Shader</em> 의 갯수가 많지 않은 경우를 타겟으로 했다고 쓰여져 있다. 아래 그림은 <em>SRP Batcher</em> 시스템을 나타내었다.</p>

<p><br />
<img src="https://blogs.unity3d.com/wp-content/uploads/2019/02/image5-3.png" alt="SRP batcher" class="center-image" /></p>
<center>출처 : <a href="https://solitaryroad.com/c1003.html">Unity Blog : SRP Batcher: Speed up your rendering!
</a>
<br />
</center>
<p><br /></p>

<p>위에서 언급한 데이터를 나눈 것과 동시에 중요한 것이 하나 더 있는데, 기존의 <em>Material</em> 데이터를 계속 갱신해 주어야 했는데, <em>SRP Batcher</em> 시스템은 데이터의 영속성을 보장한다고 한다. <em>Material</em> 의 데이터를 나누어서 관리하기 때문에 각 오브젝트 당으로 <em>cbuffer</em> 를 데이터를 가질 수 있다고 한다. <em>built-in batcher</em> 시스템에서는 이와 같은 처리를 하기위해 쉐이더 레벨에서 인스턴싱이라는 것을 지원했었는데 SRP 에서는 몇 안되는 Uber 쉐이더를 사용한다고 가정하고, 이를 자동으로 처리해주는 듯 싶다.</p>

<p><br />
<img src="https://blogs.unity3d.com/wp-content/uploads/2019/02/image3-5.png" alt="SRP batcher" class="center-image" /></p>
<center>출처 : <a href="https://solitaryroad.com/c1003.html">Unity Blog : SRP Batcher: Speed up your rendering!
</a>
<br />
</center>
<p><br /></p>

<p>위 그림은 <em>batch</em> 처리시 어떤 기준에 따라서 한꺼번에 처리하는지에 대해 알 수 있는 다이어그램이다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://blogs.unity3d.com/2019/02/28/srp-batcher-speed-up-your-rendering/">Unity Blog : SRP Batcher: Speed up your rendering!</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2019/03/08/steradian-and-solid-angle/">Steradian And Solid Angle</a>
          </h1>

          <p class="post-meta">Mar 8, 2019 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/terminology/">terminology</a>
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>solid angle 은 우리가 일반적으로 알고있는 angle 과는 다르게 생소할 가능성이 높다. 이의 단위는 steradian(sr) 으로 교과과정에서 많이 보이는 radian 과 이름이 비슷하다.</p>

<p>먼저 이름이 비슷한 radian 의 정의를 잘 보여주는 아래 이미지를 보자.</p>

<p><br />
<img src="/images/300px-Circle_radians.gif" alt="radian_animation" class="center-image" /></p>
<center>출처 : <a href="https://en.wikipedia.org/wiki/Radian">Wikipedia : Radian</a>
<br />
</center>
<p><br /></p>

<p>주목할 것은 초반에 나오는 1rad 의 호의 길이가 반지름과 같은 것이라 정의한 부분이다. steradian 의 정의도 언급한 radian 의 정의와 비슷하다.</p>

<p><br />
<img src="/images/Steradian.svg" alt="steradian" class="center-image" /></p>
<center>출처 : <a href="https://en.wikipedia.org/wiki/Steradian">Wikipedia : Steradian</a>
<br />
</center>
<p><br /></p>

<p>solid angle 은 해당 표면의 면적이 반지름의 제곱인 값과 같으면 1 sr 으로 정의된다. 모든 구의 면적을 다 차지할 경우 4π sr 이라고 할 수 있겠다. 또한 아래 그림처럼 표면의 크기에 상관있기 때문에 표면의 모양이 어찌 되었든 상관없다.</p>

<p><br />
<img src="/images/ole.gif" alt="steradian" class="center-image" /></p>
<center>출처 : <a href="https://solitaryroad.com/c1003.html">SolitaryRoad.com : Photometry, Steradian, Intensity of a light source, Candlepower, Lumen, Illumination, Photometer</a>
<br />
</center>
<p><br /></p>

<p>그리고 면적이 넓은것에 solid angle 이 비례하는 것이 아니라 전체 면적의 비율을 얼마나 차지하느냐에 따라서 solid angle 이 결정된다. 즉 반지름의 크기와는 상관이 없다. 그래서 solid angle 은 다음과 같이 나타낼 수 있다.</p>

<p><br /></p>

<script type="math/tex; mode=display">\Omega = A / r^2</script>

<p align="center">definition of steradian</p>
<p><br /></p>

<!--
  spherical cone 에 대한것도 써야함
-->

<h2>참조</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Steradian">Wikipedia : Steradian</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Solid_angle">Wikipediad : Solid angle</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2019/02/10/unit-of-light-radiation/">Unit Of Light Radiation</a>
          </h1>

          <p class="post-meta">Feb 10, 2019 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/terminology/">terminology</a>
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>real-time rendering 분야에서 PBR 이 정착하게 되면서, 빛에 대한 측정 기준을 알아야 되게 되었다. 단순하지만 확실하게 정의해놓지 않으면 헷갈리는 개념이기 때문에 정리 해보려 한다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2019/02/10/unit-of-light-radiation/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/05/27/how-to-represent-transparency-object/">How To Represent Transparency Object</a>
          </h1>

          <p class="post-meta">May 27, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/transparency/">transparency</a>
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>오래전부터 게임같은 실시간으로 안정적인 성능을 뽑아내야하는 컴퓨터 그래픽에서의 투명한 물체는 항상 골칫거리였다. “투명” 하다보니 일반적으로 사용되는 최적화 방법도 사용할 수 없기 때문에 퍼포먼스의 문제가 있으며, 일반적으로 지원하는 <em>Alpha Blending</em> 을 사용할시에는 물체의 순서를 직접 소팅해주어야 했다. 투명한 물체를 그리는 일반적인 방법의 문제에 대해서 알아보고, 문제를 부분적으로 해결할 수 있는 몇가지 방법들을 적어보겠다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2018/05/27/how-to-represent-transparency-object/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/05/22/opaque-as-alpha-test/">Opaque As Alpha Test</a>
          </h1>

          <p class="post-meta">May 22, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/alphatest/">alphatest</a>,
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>Shader</em> 에서 샘플링하는 <em>Texutre</em> 에서 <em>Alpha</em> 값을 가지고 있어, <em>Alpha</em> 을 참조해서 실제 픽셀에 출력을 하는지 안하는지를 결정하는 것을 <em>Alpha Test</em> 라고 한다. 이런 <em>Material</em> 이나 <em>Texture</em> 를  <em>Cutout</em> 이라고 통칭하는 경우가 많다.</p>

<p>보통 게임에서의 <em>Alpha Test</em> 를 사용하는 것들은 나무, 풀 같은 식생들(<em>Vegetation</em>)이 있고, 중간에 구멍이 뚫린 펜스같은 것들도 존재한다. 자연을 배경으로하는 게임의 경우에는 식생들이 굉장히 많기 때문에 <em>Alpha Test</em> 를 사용하는 <em>Shader</em> 가 굉장히 많이 사용될 것이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2018/05/22/opaque-as-alpha-test/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/05/18/IEEE-754-floaing-number/">Ieee 754 Floaing Number</a>
          </h1>

          <p class="post-meta">May 18, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/math/">math</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/floating-point/">floating_point</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>코딩을 하던 도중, 비트로 나타내어진 2 byte floating number(half-precision) 데이터를 일반적인 4byte floating number(single-precision) 으로 나타내야 할 일이 있었다. 그래서 귀찮아서 알아보지 않았던 컴퓨터의 소수를 표현하는 방법에 대해서 알아보았다. 이 글에서는 간략하게 어떤식으로 표현되는지에 대해서만 적어보기로 하겠다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2018/05/18/IEEE-754-floaing-number/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/05/13/anisotropic-filtering/">Anisotropic Filtering</a>
          </h1>

          <p class="post-meta">May 13, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/anisotropic/">anisotropic</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/filtering/">filtering</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>보통 사용되는 <em>Texture Fltering</em> 들은 <em>Axis Align</em> 된 방향을 기준으로 추가적인 샘플링을 하는 방법들이 대부분이다.(bilinear, bicubic, etc..) 하지만 특이한 것이 하나 있다. 바로 <em>Anisotropic Filtering</em> 이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2018/05/13/anisotropic-filtering/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/03/13/recommandation-of-gpu-skinning-in-github/">Recommandation Of Gpu Skinning In Github</a>
          </h1>

          <p class="post-meta">Mar 13, 2018 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/gpu-skinning/">gpu-skinning</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>최근 급하게 어떤 프로젝트에 투입되서 작업을 하고 있다. 다른 회사와 같이 일을 하고 있는데, 다른 회사에서 해놓은 것들이 너무 느려서 최적화를 해야했다. 결국 일반적인 잔머리로는 도저히 해결할 수 없는 상황에 봉착했다. 1년 전의 필자였다면 포기하고 안된다고 했었겠지만 다행히 약간의 노하우를 통해 해결할 수 있었다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2018/03/13/recommandation-of-gpu-skinning-in-github/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/03/06/dualized-asset-management-of-unity/">Dualized Asset Management Of Unity</a>
          </h1>

          <p class="post-meta">Mar 6, 2018 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>Unity</em> 에서는 모든 사용자의 작업물을 <em>Assets</em> 폴더에 저장한다. 그리고 <em>Assets</em> 폴더안의 파일의 변경이 발생할 시 안의 파일들을 재가공하여 다시 로드한다. 보통 파일의 변경은 <em>assetDatabaseX</em> 바이너리 파일로 들어가게 되며, 스크립트, 바이너리의 변경은 다시 컴파일을 함으로써 현재 변경사항을 프로젝트에 적용시킨다.</p>

<p>이러한 시스템을 위해 <em>Unity</em> 에서는 모든 파일, 디렉토리에 <em>meta</em> 파일을 생성한다. 파일별 <em>meta</em> 파일에는 해당 파일의 순수한 정보가 아닌 메타 정보가 들어간다. 중요한 정보는 두개로 나뉜다.</p>

<p>하나는 <em>Unity</em> 프로젝트상에서 파일을 처음 감지했을 때, 파일의 <em>GUID</em> 를 생성한다. <em>GUID</em> 란 고유의 16진수 32글자로 이루어지는 총 512비트로 이루어지는 <em>ID</em> 로써 자동으로 생성되는 알고리즘을 가지고 있으며 겹칠 염려는 거의 없는 <em>ID</em> 알고리즘이다. 그래서 생성된 <em>GUID</em> 는 다른 곳에서 해당 파일을 참조할떄 쓰인다. 즉 파일이 삭제되서 같은 것으로 다시 생성한다고 해도 <em>GUID</em> 가 랜덤으로 결정되기 때문에 다시 연결을 해주어야 한다. 이는 <em>Unity</em> 내부에서 파일 링크를 <em>GUID</em> 로 한다는 추측을 할 수 있게 해준다. 또한 <em>Edit -&gt; Project Setting -&gt; Editor</em> 에서 <em>Asset Serialization</em> 모드가 <em>Force Text</em> 로 되어있을 시에는 <em>meta</em> 파일들을 직접 텍스트 에디터로 확인이 가능하다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fileFormatVersion: 2
guid: 5d44a238286f6904198ab78e914c229d
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData:
  assetBundleName:
</code></pre></div></div>

<p>어떤 스크립트에 딸린 <em>meta</em> 파일의 내용이다. 두번째 줄에 생성된 <em>guid</em> 가 존재한다. 이는 <em>Library/metadata</em> 디렉토리에 쓰여진 이름들과 매칭된다.</p>

<p>두번째는 바로 해당 파일의 <em>Importer</em> 정보가 들어있다. 위의 <em>meta</em> 파일은 스크립트이기 때문에 3번째 줄에 <em>MonoImporter</em> 라고 쓰여져 있으며, 파일의 성질에 따라서 <em>built-in importer</em> 가 달라진다. 바이너리 파일들은 <em>NativeImporter</em>, 텍스쳐 파일들은 <em>TextureImporter</em>, 3D 모델 파일들은 <em>ModelImporter</em> 로 자동으로 매칭된다.</p>

<p>이러한 <em>Importer</em> 정보들은 보통 해당 <em>Asset</em> 의 옵션을 세팅할 떄 쓰인다. 또한 <em>2017</em> 버젼에서는 파일의 확장자를 사용자가 직접 지정해 <em>Importer</em> 를 사용할 수도 있게 해두었다.(<a href="/2018/01/11/unity-scripted-importer/">링크</a>)</p>

<p>즉 <em>Unity</em> 에서는 새로운 파일을 감지했을 때, <em>GUID</em> 를 생성하고 파일의 확장자에 따라 <em>Importer</em> 정보를 갱신한 후, 정보를 <em>Library/metadata</em> 에 갱신하는 것으로 볼 수 있다. <em>Library/metadata</em> 에서는 <em>GUID</em> 로 된 파일과 (해당 <em>GUID</em>).info 로 파일이 구성되어 있다. 각각의 파일은 파일의 유형별로 다른 것으로 보인다.</p>

        </div>

        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>
    
    <script>
      $("script[type='math/tex']").replaceWith(function() {
          var tex = $(this).text();
          return katex.renderToString(tex, {displayMode: false});
      });

      $("script[type='math/tex; mode=display']").replaceWith(function() {
          var tex = $(this).html();
          return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
      });
    </script>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2019 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
