<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Appocrypha</title>
  <meta name="description" content="store limitless knowledges">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Appocrypha">
  <meta name="twitter:description" content="store limitless knowledges">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/26/loop-attributes-for-dynamic-branching/">Loop Attributes For Dynamic Branching</a>
          </h1>

          <p class="post-meta">Oct 26, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>Programmable Shader</em> 를 작성할 때에는 한가지 유의해야 할 점이 있다. 이는 <em>Dynamic Branching</em> 이라는 개념이다. <em>Dynamic Branching</em> 은 조건 분기문이 <em>Programmable Shader</em> 에서 사용될 때 나타나는 현상을 말한다. <em>Programmable Shader</em> 는 직렬이 아닌 병렬로 실행되기 때문에 나타나는 특성이다. 반복문에서도 조건 분기를 사용한다. 간단한 아래 코드를 보자.</p>

<pre><code class="language-hlsl">int i = 0;
while(i &lt; 5)
{
  i++;
}
</code></pre>

<p>위 코드는 프로그래밍을 입문할때 볼 수 있는 코드다. 중요한 것은 <em>while</em> 단어가 있는 줄에 있는 조건 식이다. <em>(i &lt; 5)</em> 조건식 때문에 <em>Dynamic Branching</em> 이 발생한다. 이 <em>Dynamic Branching</em> 을 명시적으로 없에거나 만들기 위해 <em>hlsl</em> 에서 <em>attribute</em> 를 지원한다. 아래를 보자.</p>

<pre><code class="language-hlsl">[Attribute] for ( Initializer; Conditional; Iterator )
{
  Statement Block;
}
</code></pre>

<p>해당 구문은 <a href="https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb509602.aspx">MSDN : for Statement</a> 에서 가져왔다. 일반적으로 프로그래머이 정말 많이본 <em>for</em> 반복문이다. 우리가 봐야할 것은 <em>for</em> 구문 왼쪽의 <em>[Attribute]</em> 라는 구문이다. 이 부분에는 총 4가지의 옵션을 넣을 수 있는데, 이 글에서 언급할 <em>[Attribute]</em> 는 두가지다. <em>unroll</em> 과 <em>loop</em> 이 두가지이다.</p>

<p><em>hlsl</em> 로 정상적인 반복문 실행을 하게되면, 매번 반복을 할때 마다 조건식을 검사하게 되고, 해당 반복문의 범위를 마음대로 조정하여 코딩을 할 수 있다. 다만 조건식의 범위가 매번 달라진다면 <em>Dynamic Branching</em> 이 발생하게 된다. 그리고 반복문이 매번 <em>Programmable Shader</em> 가 실행될 때 상수로 반복을 한다면 쉐이더 컴파일러는 최적화를 위해 특정한 행동을 하게 된다. 아래 코드를 보자.</p>

<pre><code class="language-hlsl">for(int i = 0; i &lt; 5; i++)
{
}
</code></pre>

<p>위의 코드는 루프를 다섯번 실행시키는 코드다. 따로 안에 인덱스 <em>i</em> 를 건드리지 않는다면 쉐이더 컴파일러는 컴파일 시점에 최적화를 한다. 이를 <em>unroll</em> 이라고 부를 수 있는데, 실행할 반복문을 반복문으로 해석하는게 아닌 5번 연속해서 같은 행동을 하게 하는 것이다. 조건 자체도 없어지고 그저 인덱스를 풀어쓰게 된다. 이는 상수(constant)로 반복문을 제어하면 쉐이더 컴파일러가 알아서 해주기 때문에 신경써주지 않아도 된다. 다만 <em>unroll</em> 이라는 키워드를 써서 바뀔 때는 변수를 사용해 반복문을 제어할 때다. 변수를 사용하면 컴파일 시점에서는 추측할 수 없기 때문에 암시적으로 <em>unroll</em> 을 할 수 없다. 이 때 <em>unroll</em> 키워드를 사용하여 제어할 수 있다.</p>

<pre><code class="language-hlsl">int count = ...;
[unroll(5)]
for(int i = 0; i &lt; count; i++)
{
}
</code></pre>

<p>또한 암시적으로 <em>unroll</em> 된 반복문을 명시적으로 반복문으로 실행되게 할 수도 있다.</p>

<pre><code class="language-hlsl">[loop]
for(int i = 0; i &lt; 5; i++)
{
}
</code></pre>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb509602.aspx">MSDN : for Statement</a></li>
  <li><a href="https://www.gamedev.net/forums/topic/649408-can-someone-explain-loop-and-unroll-to-me/">GameDev : Can someone explain [loop] and [unroll] to me?</a></li>
  <li><a href="https://www.gamedev.net/forums/topic/543541-hlsl-warning-gradient-based-operations-must-be-moved-out-of-flow-control-to-prevent/">GameDev : HLSL warning: Gradient-based operations must be moved out of flow control to prevent
 </a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/16/introduce-of-wave-programming/">Introduce Of Wave Programming</a>
          </h1>

          <p class="post-meta">Oct 16, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Windows 10 Fall Creators Update 가 나오면서 <em>Shader Model 6.0</em> 이 추가되었다. 여태까지의 <em>Shader Model</em> 업데이트는 대부분 DirectX 버젼이 올라가면서 같이 업데이트 된 경우가 많으나 이번의 <em>Shader Model 6.0</em> 은 따로 업데이트 되었다. <em>Shader Model 6.0</em> 에서의 가장 큰 기능 추가는 당연히 <em>Wave Intrisic</em> 이라고 할 수 있겠다. <em>Wave Intrisic</em> 을 제외하면 <em>Shader Model 6.0</em> 은 바뀐게 없다.</p>

<p>여태까지의 HLSL 을 사용한 쉐이더 작성은 거의 대부분 <em>Single-Threading</em> 으로 작동되었다. <em>Pixel Shader</em> 에서 ddx, ddy instrisic 을 사용하여 Gradient 데이터를 가져올 수 있긴 했지만 이 것을 제외하면 거의 없었다고 보면 되겠다. 그래서 <em>Shader Model 6.0</em> 에서는 다른 <em>Thread</em> 와 인터렉션 할 수 있는 <em>Wave Intrisic</em> 을 지원한다. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt733232.aspx">MSDN : HLSL Shader Model 6.0</a> 을 살펴보면 알겠지만 단순한 API 들을 제공하는 것이다. 하지만 내부에서 동작하는 것은 조금 다르다.</p>

<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt733232.aspx">MSDN : HLSL Shader Model 6.0</a> 에서 나온 용어에 대한 설명이 필요하다. <em>Lane</em> 은 일반적으로 생각되는 한개의 <em>Thread</em> 가 실행되는 것이다. <em>Shader Model 6.0</em> 이전의 쉐이더 모델은 단순히 <em>Lane</em> 개념 안에서 코딩을 해야 했다. <em>Lane</em> 은 상황에 따라 실행되고 있는 상태일 수도 있고, 쉬고 있는 상태일 수도 있다. <em>Wave Intrisic</em> 을 사용해 이를 각각의 <em>Lane</em> 에서도 알 수 있다. <em>Wave</em> 는 GPU 에서 실행되는 <em>Lane</em> 의 묶음을 뜻한다. 즉 여러개의 <em>Lane</em> 이라고 할 수 있겠다. 같은 <em>Wave</em> 안의 <em>Lane</em> 들은 <em>Barrier</em> 라는게 없다. 필자가 알고 있는 <em>Barrier</em> 는 <em>Memory Barrier</em> 인데, 이는 <em>Thread</em>(<em>Lane</em>)끼리의 같은 메모리에 접근하는 것에 대한 동기화를 위해 있는 개념이다. 동기화를 위한 <em>Barrier</em> 는 속도를 늦출 수 밖에 없다. 하지만 <em>Wave</em> 로 묶여진 <em>Lane</em> 들은 서로 <em>Barrier</em> 가 명시적으로 존재하지 않기 때문에 <em>Wave</em> 별로 빠른 메모리 접근이 가능하다는 것이다. <em>Wave</em> 는 <em>Warp</em>, <em>WaveFront</em> 라고도 불리울 수 있다고 한다.</p>

<p>그리고 이 API 들을 통해 약간의 드라이버 내부를 엿볼 수 있다. <em>Pixel Shader</em> 에서 <em>Render Lane</em> 과 <em>Helper Lane</em> 이 구분되어져 있는데, 이는 ddx,ddy 를 통해 픽셀의 Gradient 를 계산하는 것에 대한 보다 디테일한 개념을 생각할 수 있게 해준다. GPU 드라이버 시스템에서는 픽셀을 처리하기 위해 단순히 한개의 픽셀만 처리하는게 아닌 2x2 의 픽셀을 엮어 계산한다. 이를 MSDN 문서에서는 2x2 의 픽셀 뭉치를 <em>Quad</em> 라고 명칭한다. <em>Quad</em> 는 두가지 종류에 스레드가 실행된다. 하나는 우리가 잘 알고 있는 <em>Pixel Shader</em> 를 실행하는 <em>Render Lane</em> 이다. <em>Render Lane</em> 은 화면에 보여주는 색을 결과로 내놓게 된다. 그리고 나머지 한가지는 <em>Helper Lane</em> 인데, 이는 Pixel 별로 Gradient 를 계산하기 위해 실행되는 <em>Lane</em> 으로써 아무런 결과를 내놓지 않고 단순히 계산을 위한 <em>Lane</em> 이다.</p>

<p><em>Shader Model 6.0</em> 은 DirectX12 과 Vulkan 에서 지원한다. DirectX 에서는 <em>Pixel Shader</em> 와 <em>Computer Shader</em> 에서 지원한다. Vulkan 에서는 모든 쉐이더 단계에서 지원한다. 그래픽 카드 벤더별로 조금씩 다른게 있으니 <a href="http://32ipi028l5q82yhj72224m8j.wpengine.netdna-cdn.com/wp-content/uploads/2017/07/GDC2017-Wave-Programming-D3D12-Vulkan.pdf">GDCVault(GDC 2017) : Wave Programming D3D12 Vulkan </a> 에서 참고 바란다.</p>

<p>이 API 는 여러 쓰레드들 끼리 쉽게 협력하여 보다 효율적인 쉐이더 병렬 프로그래밍을 가능하게 해줄듯하다. 다만 <em>Shader Model 5.0</em> 에서 소개된 <em>ComputeShader</em> 만큼의 임팩트는 없다. 패러다임의 아주 큰 변화는 없다는 뜻이다. DirectX12 가 지향하는 드라이버 시스템에서의 부담을 줄이는 것과 <em>Shader Model 6.0</em> 은 서로 방향이 비슷하다고 생각된다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://www.gdcvault.com/play/1024732/Advanced-Graphics-Tech-D3D12-and">GDCVault(GDC 2017) : D3D12 &amp; Vulkan Done Right</a></li>
  <li><a href="http://32ipi028l5q82yhj72224m8j.wpengine.netdna-cdn.com/wp-content/uploads/2017/07/GDC2017-Wave-Programming-D3D12-Vulkan.pdf">GDCVault(GDC 2017) : Wave Programming D3D12 Vulkan </a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt733232.aspx">MSDN : HLSL Shader Model 6.0</a></li>
  <li><a href="http://optocrypto.com/2017/09/20/microsofts-program-shader-model-6-0-completed/">Optocrypto : Microsoft’s first example program for shader model 6.0 was completed</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/30/using-command-buffer/">Using Command Buffer</a>
          </h1>

          <p class="post-meta">Sep 30, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>일반적으로 Graphics Driver API 에서 지원하는 <em>CommandBuffer</em> 는 굉장히 낮은 드라이버 레벨의 렌더링 명령을 저장하여, GPU 에서 이 <em>CommandBuffer</em> 를 참조해 그려주는 <strong>Task Queue</strong> 의 개념이다. 하지만 Unity 에서 지원하는 <em>CommandBuffer</em> 의 개념은 비슷하지만 조금 다르다.</p>

<p>Unity 렌더링 시스템은 재미있는 기능을 많이 제공하지만 그중에서도 가장 활용할 가능성이 높은 기능은 <strong>CommandBuffer</strong> 일 것이다. 이는 일반적으로 알려진 Graphics Driver API 에서의 낮은 레벨의 명령을 저장하는 <em>CommandBuffer</em> 와는 달리 Unity 에서 사용할 수 있는 <strong>CommandBuffer</strong> 는 Unity 의 대부분의 렌더링 기능을 사용할 수 있다. <a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html">Unity Reference : Command Buffer</a> 이 링크를 보면 알겠지만 정말 많은 기능들을 <strong>CommandBuffer</strong> 에 저장할 수 있다. 이는 렌더링 스크립트를 유연하게 짤 수 있게 해주며, 파이프라인의 개념까지 건드릴 수 있게 된다.</p>

<p>그리고 이 명령을 실행하는 방법은 3가지가 있다. 하나는 <em>Camera.AddCommandBuffer</em> 메소드를 사용하는 방법이다. 이는 <strong>Camera</strong> 컴포넌트에 <strong>CommandBuffer</strong> 를 집어넣는 기능인데, 단순히 넣는게 아니라 <strong>Camera</strong> 의 렌더링 단계는 굉장히 많은 단계로 나뉘는데, 이 단계별로 시간을 정해 그릴 수도 있다. 굉장히 과정이 많기 때문에 사용자가 원하는 시점에 넣기만 하면 된다. 그러면 <strong>Camera</strong> 가 렌더링을 하는 과정에서 <strong>CommandBuffer</strong> 의 명령들을 실행할 것이다. 또한 같은 이치로 <em>Light.AddCommandBuffer</em> 메소드가 있다. <em>Camera.AddCommandBuffer</em> 와 같이 원하는 시점에 <strong>CommandBuffer</strong> 를 넘기면 된다.</p>

<p>마지막으로는 <em>Graphics.ExecuteCommandBuffer</em> 이다. 이는 즉각적으로 <strong>CommandBuffer</strong> 안의 명령들을 실행시키는 기능으로 앞에서 언급한 시스템에서 알아서 실행되는 것과는 다르다. 사용자가 실행 시점을 정하고 싶은 경우에는 이 메소드를 쓰면 될것이다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/Manual/GraphicsCommandBuffers.html">Unity Manual : Graphics Command Buffers</a></li>
  <li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html">Unity Reference : Command Buffer</a></li>
  <li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CameraEvent.html">Unity Reference : CameraEvent</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/30/multi-compiled-shader-in-unity/">Multi Compiled Shader In Unity</a>
          </h1>

          <p class="post-meta">Sep 30, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 는 렌더링을 위한 하부 시스템을 꽤나 많이 만들어 놓았다. 그 중에서도 꽤나 오래된 시스템은 <em>multi-compiled shader</em> 시스템일 것이다. 직역하면 여러개로 컴파일된 <em>Shader</em> 란 말이다. 또한 기능또한 별 차이 없다. 하지만 이를 위해 시스템에서 어떤 일을 하는지에 대해서는 알아야 한다.</p>

<p>우선 <em>multi-compiled shader</em> 에 대해서 알아야 겠다. Unity 시스템에서는 단순히 물체를 렌더링하는데 한가지 방법만 쓰이지 않는다. <strong>UnityEngine.MeshRenderer</strong> 같은 지원하는 컴포넌트를 통해 렌더링을 하는게 가장 알려진 방법이다. 또한 컴포넌트가 아닌 코드 레벨에서도 렌더링이 가능하다. <em>Graphics.DrawProcedural</em> 와 비슷한 메서드를 통해서도 렌더링이 가능하다. 또한 Unity 에서 지원하는 시스템을 사용하기 위해 분기 키워드가 아닌 전처리 옵션을 두어 사용하기도 한다.(Unity 에서는 기능 지원을 위해 전처리기 기능을 많이 쓴다.) 여기서 알아야 할 것은 Unity 시스템에서는 굉장히 많은 방법으로 다양한 렌더링을 지원하는데, 다양한 렌더링을 사용하기 위해서는 <em>Shader</em> 또한 각각 다양한 렌더링 방법에 맞추어 컴파일 될 필요가 있다. 그럴때 쓰는 것이 <em>multi-compiled shader</em> 기능이다.</p>

<p>사용자가 직접 <em>multi-compiled shader</em> 기능을 사용하는 것은 꽤나 단순하다.</p>

<pre><code class="language-C">#pragma multi_compile FANCY_STUFF_OFF FANCY_STUFF_ON
</code></pre>

<p>쉐이더 코드에서 위와 같이 사용하게 되면 <em>FANCY_STUFF_OFF</em>, <em>FANCY_STUFF_ON</em> 두가지 옵션을 통해 컴파일 하는 것을 나눌 수 있게 된다. 이 키워드는 쉐이더 바깥에서 제어가 가능하다. 모든 쉐이더의 키워드를 제어하려면 <em>Shader.EnableKeyword</em>, <em>Shader.DisableKeyword</em> 를 사용하면 되고, <strong>Material</strong> 단위로 사용하려면 <em>Material.EnableKeyword</em>, <em>Material.DisableKeyword</em> 을 사용하면 된다. 또한 Unity 시스템 내에서 이 <em>multi-compiled shader</em> 를 사용하니, 기존에 있는 것들은 사용하면 영 좋지 않은 꼴이 일어날듯 하다.</p>

<p>이런 복잡함을 만드는 시스템에는 언제나 문제가 있다. Unity 에서의 기본적인 <em>Shader</em> 컴파일은 따로 설정을 해주지 않는 이상 Runtime 에 일어난다. 정확히 Unity 시스템에서 해당 쉐이더를 사용해 렌더링을 할때 컴파일을 하게 된다. 그리고 컴파일할 <em>Shader</em> 의 양이 많으면 많을수록 이는 영 좋지않은 꼴을 보게된다. <em>multi-compiled shader</em> 는 더욱더 시간을 많이 잡아먹게 한다. 물론 이를 해결하기 위한 방법은 존재한다.</p>

<p>Unity 프로젝트 설정에서 <em>Graphics Setting</em> 에서 가능하다. 잘 찾아보면 <strong><em>Shader Preloading</em></strong> 이라는 항목이 있다. 말그대로 Runtime 에 로딩하는게 아닌 시작하자마자 로딩하는 기능이다. 다만 이 기능을 사용하려면 <em>Shader</em> 를 그대로 넣는게 아닌 다른 것을 만들어야 한다. 이는 <strong>ShaderVariantsCollection</strong> 이라는 에셋인데, Unity 에서 생성가능하다. 이 에셋은 <em>Shader</em> 의 종류를 가지고 <em>multi-compiled shader</em> 의 어떤 쉐이더를 로딩할지 결정하는 에셋이다. 이 에셋을 생성하여 <em>Shader</em> 들을 세팅한 뒤, <strong><em>Shader Preloading</em></strong> 아래에 있는 리스트에 넣어주면 응용 프로그램이 시작될 때, Unity 시스템에서 알아서 로딩한다. 미리 로딩하는게 아닌 사용자가 원할때 로딩하는 것도 가능한 것처럼 보인다. <strong>ShaderVariantsCollection</strong> 를 사용하면 사용자가 원할 떄 단순히 메소드 호출을 통해 로딩이 가능하다. <em>ShaderVariantsCollection.WarmUp</em> 이라는 메소드를 호출하면 전부 로딩을 하기 시작하는데 이때 로딩하는 개념이 조금 재미있다. Unity 시스템에서는 필요할 때 <em>Shader</em> 를 로딩한다. 이는 위에서도 언급했었는데 <em>ShaderVariantsCollection.WarmUp</em> 는 단순히 이 지연 로딩 시스템을 이용한 것 뿐이다. <em>ShaderVariantsCollection.WarmUp</em> 을 호출하면 단순한 폴리곤 한개를 렌더링하는데, <strong>ShaderVariantsCollection</strong> 이 가지고 있는 모든 쉐이더로 한번씩 렌더링을 한다. 이렇게 되면 지연 로딩 시스템이 쉐이더를 로딩하게 되는 것이다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html">Unity Manual : Making multiple shader program variants</a></li>
  <li><a href="https://docs.unity3d.com/kr/current/ScriptReference/ShaderVariantCollection.html">Unity Reference : ShaderVariantsCollection</a></li>
  <li><a href="https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html">Unity Manual : Optimizing Shader Load Time</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/29/using-rendering-to-cubemap/">Using Rendering To Cubemap</a>
          </h1>

          <p class="post-meta">Sep 29, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/09/29/using-relplacement-shader/">using replacement shader</a> 에서 <em>Camera.RenderWithShader</em> 와 같은 렌더링을 코드에서 직접해주면서 기능을 커스터마이징 할 수 있는 것을 살펴보았는데, 이 게시물에서는 비슷한 메서드인 <em>Camera.RenderToCubemap</em> 에 대해서 알아볼 것이다.</p>

<p>Unity 에서는 여러 렌더링 커스터마이징 기능을 제공하는데, 이 게시물에서는 그 중 하나인 <em>Camera.RenderToCubemap</em> 에 대해서 알아볼 것이다. 일반적으로 <em>Cubemap</em> 은 SkyBox 나 주변의 Irradiance 를 나타낼 때 쓴다. 다만 이를 직접 구현할 때의 문제점은 각 모서리별로 <em>Aliasing</em> 이 일어나는 경우다. 매우 매끄러운 표면의 Specular 에서 <em>Aliasing</em> 이 나타난 Irradiance 를 표현하면 굉장히 티가 많이 나기 때문에 이는 굉장히 신경써야할 문제다.</p>

<p>그래서 Unity 에서는 <em>Cubemap</em> 에 렌더링을 하는 기능인 <em>Camera.RenderToCubemap</em> 을 지원한다. 이를 통해 할 수 있는 것은 실시간으로 <em>Cubemap</em> 에 렌더링된 결과를 저장해 <em>Irradiance</em> 의 소스로 쓰거나, 실시간으로 바뀌는 <em>Skybox</em> 렌더링을 할 수도 있다. 사용 방법은 아래와 같다.</p>

<pre><code class="language-C#">RenderTexture cubmapRT = ...;
camera.RenderToCubemap(cubemapRT, 63);
</code></pre>

<p><em>Camera.RenderToCubemap</em> 의 두번째로 들어가는 인자는 어떤 면을 그릴건지에 대한 비트마스크다. <em>Camera.RenderToCubemap</em> 를 쓸때 주의할 점은 일부 하드웨어에서는 동작하지 않는 기능이라고 한다. 다만 특정한 하드웨어를 기술해 놓지않아서 추측하기는 어렵다. 단순히 추측할 수 있는 것은 MRT 를 지원하지 않거나 아니면 다른 <em>ComputeShader</em> 같은 기능을 사용해 일부 하드웨어에서 안된다고 하는 정도 밖에 없다.</p>

<p>위 예제에서는 RenderTexture 를 사용하였는데, 저렇게 코드에서 처리할 수도 있지만 CustomRenderTexture 를 통해 간편하게 처리할 수도 있다. CustomRenderTexture 는 업데이트 주기를 사용자 임의대로 정할 수 있으므로 꽤나 유용하게 쓰일 수 있다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/kr/current/ScriptReference/Camera.RenderToCubemap.html">Unity Reference : Camera.RenderToCubemap</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/29/using-relplacement-shader/">Using Relplacement Shader</a>
          </h1>

          <p class="post-meta">Sep 29, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 는 <em>Replacement Shader</em> 라는 렌더링 기능을 지원한다. 이는 Unity 가 Rendering 기능에서 지원하는 약간 Hack 한 테크닉이며 이 기능을 잘 사용하면 쉐이더를 바꿔치기 해서 재미있는 것들을 할 수 있다. <em>Replacement Shader</em> 는 렌더링할 MeshRenderer 들이 가지고 있는 <strong>Material</strong> 의 Shader 를 사용자가 원하는 것으로 바꾸는 기능이다. 이 기능을 통해 그림자 같은 여러 부가적인 처리를 할 수 있다.</p>

<p>사용하는 방법은 아래와 같다.</p>

<pre><code class="language-C#">Shader shader = Shader.Find("CustomShaderName");
string replacementTag = "replace";

// tag is optional. if dont need tag, insert null.
camera.RenderWithShader(shader, replacementTag);
</code></pre>

<p>위의 간단한 예제는 <em>Replacement Shader</em> 를 사용해 한번 그려주는 예제다. 단순히 <em>Camera.RenderWithShader</em> 를 사용하기 때문에 직접 값을 컨트롤할 때 사용하기 좋다. <em>Replacement Shader</em> 를 영구적으로 세팅하여 자동으로 그려주면 아래와 같이 하면된다.</p>

<pre><code class="language-C#">Shader shader = Shader.Find("CustomShaderName");
string replacementTag = "replace";

// tag is optional. if dont need tag, insert null.
camera.SetReplacementShader(shader, replacementTag);
</code></pre>

<p>사용 방법은 굉장히 단순하다. 다만 이 <em>Replacement Shader</em> 기능에서 중요한 것은 쉐이더를 단순히 치환하는 것만 포인트가 아니다. 치환된 쉐이더들은 기존 <strong>Material</strong> 이 가지고 있던 데이터들과 쉐이더 코드에서 이름만 똑같이 맞추어주면 자동으로 데이터들이 쉐이더로 들어온다. 즉 쉐이더를 갈아치우지 않고도 데이터를 공유할 수 있는 것이다. 이는 Unity 의 렌더링에서 굉장히 강력한 시스템으로 초기에는 이해하기도 힘들고 잔머리가 필요하지만 이를 잘 사용만 한다면 굉장히 유용하게 쓰일 수 있다.</p>

<p>필자는 Github 에서 OIT 예제를 보면서 처음 보았다. <a href="https://github.com/candycat1992/OIT_Lab">Github : OIT_Lab</a> 에서 OIT 를 처리하는 코드에서 구경할 수 있다. 또한 일본 Unity 지사에서 일하는 유명한 keijiro 의 <a href="https://github.com/keijiro/Skinner">Skinner</a> 에서 위치를 처리하는데 쓰이기도 한다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/kr/current/Manual/SL-ShaderReplacement.html">Unity Reference : Replaced Shaders 에서의 렌더링</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/01/using-compute-buffer-in-unity/">Using Compute Buffer In Unity</a>
          </h1>

          <p class="post-meta">Aug 1, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 에서의 확실한 GPU Instancing 은 <strong>ComputeBuffer</strong> 라는 구현체에서 시작될 것이다. 이 구현체는 <strong>UnityEngine.ComputeBuffer</strong> 라는 Unity 의 구현체이며 하는 역할은 GPU 메모리를 사용하게 해주는 역할을 한다. <strong>ComputeBuffer</strong> 는 <strong>ComputeShader</strong> 와 함께 등장했다. <strong>ComputeShader</strong> 에서 데이터를 읽고 쓰는것을 요구하기 때문에 Unity 는 GPU 메모리를 사용하는 컨테이너로서 <strong>ComputeBuffer</strong> 를 구현해 놓았다. 하지만 이 <strong>ComputeBuffer</strong> 는 <strong>ComputeShader</strong> 뿐만아니라 일반 쉐이더에서도 폭넓게 사용가능하다. 이 말의 뜻은 우리가 생각하는 Unity 에서 지원하는 일반적인 메쉬 데이터를 사용하지 않아도 사용자가 직접 메쉬 데이터를 커스터마이징해서 사용할 수 있다는 이야기이다. 지원하는 플랫폼은 일반적으로 말하는 <em>Shader Model 5.0</em> 이상이다. PC 플랫폼에서는 당연히 사용 가능하다.</p>

<p>사용하는 방법 자체는 어렵지 않다. 스크립트에서 <em>size</em> 와 <em>stride</em> 를 설정해주고, 데이터의 배열을 만들어 GPU 메모리 안에 있는 데이터를 읽거나 쓸 수 있다. 메모리 단위에서 하는것처럼 보이기 때문에 크기와 타입은 맞춰주어야 한다. C# 에서는 <strong>System.Array</strong> 형으로 넣어주니 형태에 주의하기 바란다. 방법은 아래와 같다.</p>

<pre><code class="language-C#">int dataLen = ...;  // length of data
int[] dataArray = new int[dataLen];

// record data in dataArray..

ComputeShader computeShader = ...;
ComptueBuffer dataBuffer = new ComputeBuffer(dataLen, sizeof(int));
dataBuffer.SetData(dataArray);

computeShader.SetBuffer("dataBuffer", dataBuffer);
</code></pre>

<p>위 코드는 <strong>ComputeShader</strong> 에서 <strong>ComputeBuffer</strong> 를 사용하기 위해 세팅하는 코드다. 가장 맨처음에는 초기에 세팅할 정수 배열을 만들고, 그 다음 <strong>ComputeBuffer</strong> 인스턴스를 생성한다. 생성자에서 넣어주는 인자는 데이터의 길이(<em>length</em>)와 각 데이터별 크기(<em>stride</em>)이다. 그 다음 같은 크기의 배열의 데이터를 GPU 메모리로 쓴다.(<em>write</em>) 그리고 마지막으로 데이터가 세팅된 <strong>ComputeBuffer</strong> 를 <strong>ComputeShader</strong> 에 연결해준다. 이러면 <strong>ComputeShader</strong> 코드에서 <em>dataBuffer</em> 라는 변수명을 가진 변수에 <strong>ComputeBuffer</strong> 가 연결된다. 아래에 <strong>ComputeShader</strong> 코드가 있다.</p>

<pre><code class="language-HLSL">StructuredBuffer&lt;int&gt; dataBuffer;

[numthreads(8,8,1)]
void Process (uint3 id : SV_DispatchThreadID)
{
  ...
}
</code></pre>

<p>맨 처음에 있는 <em>dataBuffer</em> 에 연결된다. <a href="{ post_url 2017-07-06-structured-buffer-vs-constant-buffer }">StructuredBuffer vs ConstantBuffer</a> 에서본 <em>StructuredBuffer</em> 타입이 가능하다. 또한 <em>RWStructuredBuffer</em>, <em>ConsumeStructuredBuffer</em>, <em>AppendStructuredBuffer</em> 가능하다. 다른 렌더러 쉐이더 코드에서도 사용가능하다. 그래서 일반적으로 고려되는 파이프라인은 아래와 같다.</p>

<p><img src="/images/data-process-pipeline.png" alt="data process" class="center-image" /></p>

<p>앞의 두가지 <strong>ComputeBuffer</strong> 를 세팅하고 <strong>ComputeShader</strong> 를 실행하는 코드는 대충 보았다, 뒷 부분의 <strong>ComputeBuffer</strong> 를 통해 렌더링을 하는 것은 그다지 어렵지 않다. 중요한 것은 참신하게, 효율적으로 렌더링하는 것이다.</p>

<p><a href="https://github.com/hrmrzizon/CustomSkinningExample">Github : CustomSkinningExample</a> 에서 스키닝의 계산을 <strong>ComputeShader</strong> 로 넘겨서 계산한다. 또한 메시 데이터 전체를 <strong>ComputeBuffer</strong> 로 넘겨서 렌더링하기 때문에 꽤나 괜찮은 예가 될것이다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://docs.unity3d.com/ScriptReference/ComputeBuffer.html">Unity Reference : ComptuteBuffer</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/01/darboux-frame/">Darboux Frame</a>
          </h1>

          <p class="post-meta">Aug 1, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/math/">math</a>,
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/study/">study</a>
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>여러 공간 법선 벡터(<em>tangent space normal</em>, <em>object space normal</em>)에 대하여 알아보던 도중 모르는 것이 하나있어 정리해볼겸 포스팅해보려 한다. <em>darboux frame</em> 이라는 놈이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/08/01/darboux-frame/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/07/30/normal-tangent-binormal/">Normal Tangent Binormal</a>
          </h1>

          <p class="post-meta">Jul 30, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/math/">math</a>,
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/study/">study</a>
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Graphics 를 공부하다보면 노말(normal), 탄젠트(tangent), 바이노말(binormal) 를 굉장히 많이보게 된다. 특히 노말이라는 단어는 꽤나 많이 보인다. 보통은 어떤 역할을 하는 벡터앞에 이름을 붙여서 말한다. 아래와 같이 정리된다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/07/30/normal-tangent-binormal/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/07/22/optimized-center-of-rotation/">Optimized Center Of Rotation</a>
          </h1>

          <p class="post-meta">Jul 22, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/skinning/">skinning</a>,
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/vertex-deformation/">vertex deformation</a>,
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/try/">try</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>이전 <a href="/2017/07/20/dual-quaternion-skinning/">dual quaternion skinning</a> 글에서 <em>dual quaternion skinning</em> 에 대해서 설명해 보았다. 이전 글에서는 단순히 <em>dual quaternion skinning</em> 에 대해서 알아보고 장점에 대해서 알아보았다. 단점에 대해서는 언급을 하지않았는데 사실 단점도 존재하긴 한다. 새로 소개할 방법의 논문에서 <em>dual quaternion skinning</em> 의 단점에 대해서 언급했다.</p>

<p><em>joint bulging artifact</em> 라고 하는 것인데, 90도 정도 휜 부분의 바깥쪽이 튀어나오는 현상을 말한다. 아래 그림에서 볼 수 있다.</p>

<p><img src="/images/dqs_ocor_bent.png" alt="both bent" class="center-image" /></p>

<p>왼쪽은 <em>dual quaternion skinning</em> 을 표현한 그림이고, 오른쪽은 곧 소개할 <em>optimized center of rotation</em> 방법이 적용된 스키닝이다. 각 그림의 오른쪽의 90도 휜 부분을 관찰하면 <em>dual quternion skinning</em> 이 약간 아래가 부푼 모습을 볼 수 있다. 이를 <em>joint bulging artifact</em> 라고 한다. 그리고 오른쪽 위의 확대된 그림을 보면 <em>dual quaternion skinning</em> 은 약간 움푹 들어간 것을 볼 수 있다.</p>

<p>그래서 디즈니 리서치라는 연구소에서 새로운 방법을 2016 년 Siggraph 에서 소개했다. 논문의 이름은 <em>Real-time Skeletal Skinning with Optimized Centers of Rotation</em> 이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/07/22/optimized-center-of-rotation/">Read on &rarr;</a>
          </p>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Su-Hyeok Kim - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
