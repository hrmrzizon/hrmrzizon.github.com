<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Appocrypha</title>
  <meta name="description" content="store limitless knowledges">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Appocrypha">
  <meta name="twitter:description" content="store limitless knowledges">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/19/shadow-map-filtering/">Shadow Map Filtering</a>
          </h1>

          <p class="post-meta">Dec 19, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/vsm/">vsm</a>
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="{ post_url 2017-11-30-what-is-shadow-mapping }">What is Shadow Mapping</a> 에서 <em>Shadow Mapping</em> 에 대한 간단한 번역 &amp; 설명을 적어놓았다. 해당 글에서 <em>PCF</em> 를 잠깐 언급했었다. 이 글에서는 <em>PCF</em> 를 포함해서 <em>Shadow Map</em> 을 필터링하는 방법에 대해서 알아보겠다.</p>

<p>첫번째는 <em>PCF</em> 다. 풀어쓰면 <em>Percentage Closer Filtering</em> 이라는 단어가 되며, <em>Shadow Map</em> 을 여러번 샘플링해 <em>Percentage</em> 를 소숫점으로 나타내서 <em>Shadow</em> 가 생긴 정도를 나타내주는 <em>Filtering</em> 기법이다. 쉽게 이해할 수 있도록 아래 그림을 보자.</p>

<p><br />
<img src="/images/PCF_Scheme.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://graphics.pixar.com/library/ShadowMaps/paper.pdf">Pixar : Rendering Antialiased Shadows with Depth Maps</a>
</center>
<p><br /></p>

<p>위의 a) 는 아무것도 필터링 하지 않을 때의 <em>ShadowMap</em> 샘플링하는 것을 보여주고, 아래 b) 는 <em>PCF</em> 를 사용해 샘플링하는 것을 보여준다. 위 그림에서 <em>Surface at z = 49.8</em> 은 그림자를 처리할 표면의 <em>Depth</em> 또는 <em>Z</em> 을 뜻한다. 그리고 <em>Light-Space</em> 를 기준으로 해당 값보다 <em>Depth</em> 값이 멀다고 판단될시에는 처리하지 않고, 가깝다고 판단될 때는 처리하는 걸로 해준다. <em>Shadow Map</em> 에서 한 부분만 샘플링해서 하는 것이 윗 부분의 그림이고, 한 부분이 아닌 근처의 여러 부분을 샘플링해서 값을 구하는 것이 <em>PCF</em> 다.</p>

<p>아래에 <em>PCF</em> 를 사용하는 코드가 있다.</p>

<p><br /></p>

<pre><code class="language-HLSL">float PCF_FILTER( float2 tex, float fragDepth )
{
    //PreShader - This should all be optimized away by the compiler
    //====================================
    float fStartOffset = BoxFilterStart( fFilterWidth );
    float texOffset = 1.0f / fTextureWidth;
    //====================================

    fragDepth -= 0.0001f;
    tex -= fStartOffset * texOffset;

    float lit = 0.0f;
		for( int i = 0; i &lt; fFilterWidth; ++i )
			for( int j = 0; j &lt; fFilterWidth; ++j )
			{
				lit += texShadowMap.SampleCmpLevelZero(
                                FILT_PCF,
                                float2( tex.x + i * texOffset, tex.y + j * texOffset ),
                                fragDepth
                              );
			}
	return lit / ( fFilterWidth * fFilterWidth );
}
</code></pre>

<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a>
</center>
<p><br /></p>

<p>자세한 코드는 위의 출처에서 코드를 구해서 보면 될듯하다. <em>Texture2D::SampleCmpLevelZero</em> 는 <em>MipMap</em> 참조 레벨은 0으로 한채 텍스쳐의 값을 샘플링하여 주어진 인자와 비교하여 <em>Sampler</em> 에 정해준 방식에 적합하면 1, 적합하지 않으면 0을 반환해준다.</p>

<p>해당 그림에서는 평균을 구하는 방법을 표기해놓았으나 다른 <em>NDF</em> 를 써서 구현할 수도 있다.(<em>Gaussian Distribution</em>) 또한 규칙적으로 샘플링하는게 아닌 <em>jitter</em> 를 사용해서 샘플링할 수도 있다고 한다. 일반적으로 <em>Poisson disk Distribution</em> 을 사용한다고 한다.</p>

<p><em>PCF</em> 의 단순한 방법으로 <em>Shadow Map</em> 을 <em>AntiAliasing</em> 할 수 있다. 하지만 <em>Shadow Map</em> 의 샘플링 횟수가 <em>PCF Kernel</em>(3x3, 5x5..) 이 커지면 커질수록 많아지기 때문에 꽤나 큰 <em>PCF Kernel</em> 에서는 샘플링 부하가 걸릴 수 있다. 성능상 단점이 크나 <em>PCF</em> 는 굉장히 많이 사용되는 기법 중에 하나라고 한다.</p>

<p>다음은 <em>Variance Shadow Map</em> 이다. 이는 <a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality"><em>Chebyshev’s Inequality</em></a> 라는 통계학의 개념을 사용해 <em>Filtering</em> 해준다. 먼저 <em>Shadow Map</em> 을 저장할 때 <em>Depth</em> 만 저장하는게 아닌 <em>Depth</em> 의 제곱값 또한 같이 저장한다. <em>Filtering</em> 에 쓰일 공식을 위해 같이 넣는다.</p>

<p>다음은 아래 코드와 같이 공식을 계산해준다.</p>

<p><br /></p>

<pre><code class="language-HLSL">float VSM_FILTER( float2 tex, float fragDepth )
{
    float lit = (float)0.0f;
    float2 moments = texShadowMap.Sample( FILT_LINEAR,    float3( tex, 0.0f ) );

    float E_x2 = moments.y;
    float Ex_2 = moments.x * moments.x;
    float variance = E_x2 - Ex_2;    
    float mD = (moments.x - fragDepth );
    float mD_2 = mD * mD;
    float p = variance / (variance + mD_2 );
    lit = max( p, fragDepth &lt;= moments.x );

    return lit;
}
</code></pre>

<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a>
</center>
<p><br /></p>

<p>눈여겨 볼것은 샘플러를 <em>Linear</em> 하게 설정해놓는 것이다.</p>

<p>하지만 <em>VSM</em> 은 큰 단점이 하나 있다. 바로 <em>Light Leaking</em> 이 일어나는 것이다. 이는 <a href="https://http.download.nvidia.com/developer/presentations/2006/gdc/2006-GDC-Variance-Shadow-Maps.pdf">GDC 2006 : Variance Shadow Map</a> 에서 참조할 수 있다. 이를 해결 하는 근본적인 방법은 없다고 한다.</p>

<p>두가지 기법의 차이는 텍스쳐 샘플링을 더 많이 하느냐, 메모리를 2배로 늘려주느냐의 차이에 있다. 속도를 따지면 <em>VSM</em> 이 빠르다고 한다. 하지만 굳이 퍼포먼스를 낼 필요가 없다면 <em>PCF</em> 를 사용하는 것도 나쁜 선택은 아닐것 같다. 선택에 대한 궁금증은 <a href="https://www.opengl.org/discussion_boards/showthread.php/177219-Shadow-filtering-PCF-better-than-VSM">OpenGL Forum : Shadow filtering: PCF better than VSM? </a> 글을 참조하길 바란다.</p>

<h2>참조</h2>
<ul>
  <li><a href="https://graphics.pixar.com/library/ShadowMaps/paper.pdf">Pixar : Rendering Antialiased Shadows with Depth Maps</a></li>
  <li><a href="https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb509697.aspx">MSDN : SampleCmpLevelZero</a></li>
  <li><a href="http://www.punkuser.net/vsm/">Variance Shadow Maps</a></li>
  <li><a href="https://http.download.nvidia.com/developer/presentations/2006/gdc/2006-GDC-Variance-Shadow-Maps.pdf">GDC 2006 : Variance Shadow Maps</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality">Wikipedia : Chebyshev’s inequality</a></li>
  <li><a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">GPU Gems : Shadow Map Antialiasing</a></li>
  <li><a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a></li>
  <li><a href="https://github.com/TheRealMJP/Shadows">Github : TheRealMJP - Shadows</a></li>
  <li><a href="https://www.opengl.org/discussion_boards/showthread.php/177219-Shadow-filtering-PCF-better-than-VSM">OpenGL Forum : Shadow filtering: PCF better than VSM? </a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/17/cascaded-shadow-mapping/">Cascaded Shadow Mapping</a>
          </h1>

          <p class="post-meta">Dec 17, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/csm/">csm</a>
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="{ post_url 2017-11-30-what-is-shadow-mapping }">What is Shadow Mapping</a> 에서 <em>Shadow Mapping</em> 에 대한 간단한 번역 &amp; 설명을 적어놓았다. 이번 글에서는 <em>Shadow Mapping</em> 을 효과적으로 사용하기 위한 <em>Cascaded Shadow Mapping</em> 에 대하여 적어보겠다.</p>

<p><em>Cascaded Shadow Mapping</em> 을 구글 번역기에 돌려보면 <em>“계단식 그림자 매핑”</em> 이라고 나온다. 조금 직관적이지 않은 말이지만 뜻 자체는 맞다. 간단하게 <em>Cascaded Shadow Mapping</em> 에 대하여 말하자면 넓은 환경의 그림자를 위해 거리에(거의 <em>Depth</em>) 따라서 여러개의 <em>Shadow Map</em> 을 생성하는 방법이다.</p>

<p>넓은 범위의 <em>Directional Light</em> 가 닿는 그림자를 정확하게 표현하려면 꽤나 큰 크기의 <em>Shadow Map</em> 을 사용해야 한다. 하지만 <em>Cascaded Shadow Mapping</em> 을 사용한다면 여러개의 <em>Shadow Map</em> 을 사용하여 보다 조금의 메모리를 사용하여 넓은 범위의 그림자를 표현할 수 있다.</p>

<h2>Shadow-map generation</h2>

<p><em>Cascaded Shadow Mapping</em> 을 위한 <em>Shadow Map</em> 생성은 앞서쓴 <a href="{ post_url 2017-11-30-what-is-shadow-mapping }">글</a>에서 설명한 방법과 거의 유사하다. 앞서 여러개의 <em>Shadow Map</em> 을 생성하여 그림자를 표현한다고 언급했었다. 여러개의 <em>Shaodw Map</em> 을 생성하는 기준은 <em>View Frustom</em> 을 <em>Depth</em> 를 기준으로 여러개로 쪼개어 각 쪼개진 <em>Frustom</em> 을 기준으로 <em>Shadow Map</em> 을 그린다.</p>

<p><em>Frustom</em> 은 보통 <em>Depth</em> 값을 정하거나 어떤 알고리즘을 사용하여 쪼갠다. 이는 다음 포스팅에서 언급할 예정이다. <em>Frustom</em> 을 쪼개주면 다음은 쪼개진 <em>Camera View Frustom</em> 의 각각의 8개의 꼭지점들을 <em>Light-Space</em> 로 변환한다. 변환된 각각 꼭지점으로 2차원의 <em>aligned axis bounding box</em> 의 위치를 구해준다. 가장 작은 X,Y 값과 가장 큰 X, Y 값을 구해주면 된다.</p>

<p><br />
<img src="/images/CSM_EffectOfCropMatrix.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>위 그림에서 XY 평면에서의 빨간색 선으로 되어있는 사각형이 언급한 <em>aligned axis bounding box</em> 를 말한다. 이 <em>AABB</em> 는 아래에서 특정한 행렬을 만들때 쓰인다.</p>

<p><a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Maps  </a> 에서는 이 <em>Light-Space</em> 로 변환하는 <em>MVP 변환</em> 에서 <em>Projection</em> 변환을 바꿔준다고 설명한다. 두개의 행렬이 나오는데, 하나는 직교 투영 행렬로(<em>orthogonal projection</em>) 나눠진 <em>Frustom</em> 의 <em>Far</em> 값과 <em>Near</em> 값을 통해 생성해준다. 그리고 나머지 하나는 <em>Crop Matrix</em> 라는 변환 행렬이다.</p>

<p>위에서 구한 <em>Light-Space</em> 의 <em>AABB</em> 값을 통해 <em>Crop Matrix</em> 를 계산한다. 아래 그림에서나오는 Mx, My 와 mx, my 는 각각 Maximum X,Y, Minimum X,Y 를 뜻한다.</p>

<p><br />
<img src="/images/CSM_CropMatrixCalc.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>이렇게 계산된 <em>Crop Matrix</em> 의 역할은 해당 <em>AABB</em> 로 <em>Shadow Map</em> 이 그려질 범위를 결정해주는 역할을 한다. 다만 범위가 아주 정확하지는 않다. 아래 그림을 보자.</p>

<p><br />
<img src="/images/CSM_FarMiddleNear.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://ogldev.atspace.co.uk/www/tutorial49/tutorial49.html">OGLdev : Cascaded Shadow Mapping</a>
</center>
<p><br /></p>

<p>위 그림과 같이 보통은 겹치는 부분이 생긴다. 사용시에는 <em>Depth</em> 에 따라서 다르게 사용하기 때문에 크게 문제는 없다. 사용시에는 <em>Depth</em> 값에 따라서 다른 텍스쳐를 가져오는 것과 텍스쳐를 샘플링할때 UV 값을 정점의 위치를 <em>Light-Space</em> 로 변환해서 변환된 정점의 위치의 X,Y 좌표를 UV 값으로 사용하면 된다. 다만 각각의 <em>Shadow Map</em> 마다 변환 행렬은 <em>Crop Matrix</em> 때문에 다르기 때문에 따로 접근해야 한다.</p>

<p>자세한 사용법을 알고 싶으면 <a href="http://developer.download.nvidia.com/SDK/10/Samples/cascaded_shadow_maps.zip">NVidia : Cascaded Shadow Map Example</a>에서 소스를 받아 보면 된다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">NVidia : Cascaded Shadow Maps  </a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416307.aspx">MSDN : Cascaded Shadow Maps</a></li>
  <li><a href="https://github.com/TheRealMJP/Shadows">Github : TheRealMJP - Shadows</a></li>
  <li><a href="http://ogldev.atspace.co.uk/www/tutorial49/tutorial49.html">OGLDev : Cascaded Shadow Mapping</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/30/what-is-shadow-mapping/">What Is Shadow Mapping</a>
          </h1>

          <p class="post-meta">Nov 30, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>※ 이 글은 <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial : shadow mapping</a> 게시물을 참고하여 쓰여졌습니다. 자세한 내용은 원문을 보는게 좋습니다.</p>

<p><em>Shadow Mapping</em> 실시간으로 그림자를 구현하기 위한 방법 중에 가장 널리 알려진 방법이다. 다른 방법들보다 구현하기 조금 쉬운편이긴 하나 이 방법은 완벽하지가 않기 때문에 방법 자체로는 완벽한 모습을 보이기 어렵고 다른 방법과 같이 사용하여 부족한 부분을 보완하여 사용해야 한다.</p>

<p>일반적으로 <em>Shadow Mapping</em> 이라 말하면 아는 사람은 머릿속에 쉽게 떠오르는 방식이 있다. 빛의 반대쪽 방향에서 충분히 멀리 떨어져 한번 오브젝트를 그린다. 이때 <em>Pixel Shader</em> 를 null 로 설정해서 <em>Depth Buffer</em> 의 데이터만 가져온다. 또는 <em>Pixel Shader</em> 의 출력을 <em>Depth</em> 로 해도 된다. 그러면 보통 아래와 비슷한 2D 텍스쳐를 얻게 된다.</p>

<p><br />
<img src="/images/OGLTuto_DepthTexture.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>검은색에 가까워질수록(0에 가까워질수록) 해당 오브젝트의 위치가 가깝고, 흰색에 가까워질수록(1에 가까워질수록) 물체가 먼것이다. 오브젝트의 <em>Depth</em> 를 렌더링할 때 정점에 사용되는 <em>MVP</em> 변환 중 <em>View</em> 변환은 임의의 위치와 빛의 방향을 계산하여 적용해준다. <em>Camera</em> 를 기준으로 한게 아닌 <em>Light</em> 의 방향을 기준으로 하여 관련된 것을 <em>Light-Space</em> 라고 명명하는 경우도 더러 있다.</p>

<p>이제 생성된 <em>Shadow Map</em> 을 사용하는 방법에 대해 알아보자.</p>

<p><br />
<img src="/images/OGLTuto_lightandshadow.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>위 그림에서 노란색으로 보이는 표면은 빛이 닿는 부분이고, 검은색으로 보이는 표면은 어떤 오브젝트에 의해 가려져 그림자가 드리운 표면이다. 해당 그림 위의 <em>Depth Buffer</em> 를 응용하여 위처럼 가려지는 표면과 안가려지는 표면을 알아낼 수 있다.</p>

<p><em>Depth Buffer</em> 는 <em>Light-Space</em> 를 기준으로 데이터를 저장하고 있다. 그리고 <em>Shader</em> 에서는 <em>Local-Space</em> 로 정점의 위치가 들어오기 때문에 <em>Depth</em> 값을 비교하려면 두 값을 같은 공간으로 맞춰주어야 한다. <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial : Shadow Mapping</a> 에서는 <em>bias</em> 행렬과 <em>Light-Space</em> 가 적용된 행렬을 합성하여 입력으로 들어온 정점 데이터를 <em>Light-Space</em> 기준으로 바꿔준다.</p>

<p>그 다음 정점의 <em>Depth</em>(<em>Z</em>) 값과 <em>Depth Buffer</em> 에서 샘플링한 <em>Depth</em>(<em>Z</em>) 값을 비교하여 현재 정점의 <em>Depth</em> 값이 더 크면(멀면) 그림자를 적용시킨다. 이러면 기본적인 <em>Shadwo Mapping</em> 의 이론은 끝이다. 아래 간단한 <em>GLSL</em> 코드가 있다.</p>

<pre><code class="language-C">vec4 ShadowCoord = DepthBiasMVP * vec4(vertexPosition_modelspace, 1);

float visibility = 1.0;

if (texture( shadowMap, ShadowCoord.xy ).z &lt; ShadowCoord.z) {
    visibility = 0.5;
}
</code></pre>

<p>정점의 위치를 변환시키고, <em>Depth</em> 값에 따라 <em>visibility</em> 값을 변경시켜 그림자를 적용시킨다. 하지만 위에서도 언급했지만 <em>Shadow Mapping</em> 자체에는 조금 문제가 있다고 언급했다. 해당 코드의 결과를 보자.</p>

<p><br />
<img src="/images/OGLTuto_1rstTry.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>위 그림은 굉장히 난장판이다. 세가지의 문제가 있는데 사진의 전체를 봐도 쉽게 알 수 있는 빛이 닿는 영역이 그림자 처리되는 것, <em>Shadow acne</em> 가 생겼다고 말한다. 그리고 왼쪽아래 구석부분에 아주 조금 빛이 들어오는 것처럼 처리되는 것이 있다. 이는 <em>Peter Panning</em> 이라고 부른다. 그리고 마지막으로 그림자와 빛이 닿는 부분의 경계가 울퉁불퉁한게 보일 것이다. 이를 계단현상, <em>aliasing</em> 이라고 부르는데 흔히 게임에서 적용되는 <em>antialiasing</em> 의 반대말이 맞다.</p>

<p>첫번째로 해결할 문제는 <em>Shadow acne</em> 다. 이 문제는 아래 그림을 보면 쉽게 이해가 된다.</p>

<p><br />
<img src="/images/OGLTuto_shadow-acne.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>사선으로 나와있는 노란색 선들은 <em>Shadow Map</em> 을 기준으로 <em>Light-Space</em> 로 변환한 정점의 <em>Depth</em> 값의 기준을 뜻한다. 그리고 표면 자체는 <em>Shadow Map</em> 의 기준이 된다. 그림의 검은색 부분은 빛이 닿는 부분임에도 불구하고 그림자로 처리되는 부분인데, 이를 없에기 위해서는 값을 비교할때 단순하게 <em>bias</em> 를 더해주면 된다.</p>

<pre><code class="language-C">float bias = 0.005;
float visibility = 1.0;

if (texture( shadowMap, ShadowCoord.xy ).z &lt; ShadowCoord.z-bias) {
    visibility = 0.5;
}
</code></pre>

<p>이렇게 적용시키면 평면에서의 <em>acne</em> 들은 제거가 가능하지만 곡면에서의 <em>acne</em> 들이 제거가 안되기 때문에 <em>bias</em> 를 조금 수정해준다.</p>

<pre><code class="language-C">float bias = 0.005*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1
bias = clamp(bias, 0,0.01);
</code></pre>

<p>이러면 <em>Shadow acne</em> 들은 제거된다.</p>

<p><br />
<img src="/images/OGLTuto_VariableBias.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>다음은 <em>Peter Panning</em> 을 언급할 차례다. <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial</a> 에서는 이 문제의 해결책으로 굉장히 단순한 방법을 제시한다. <em>Peter Panning</em> 이 생기지 않도록 충분히 두꺼운 오브젝트를 배치하는 것이다.</p>

<p><br />
<img src="/images/OGLTuto_NoPeterPanning.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>이렇게 쉽게 해결된다.</p>

<p>마지막으로 다룰 문제는 <em>aliasing</em> 이다. 이는 <em>Shadow Mapping</em> 의 고질적인 문제로써 <em>anti-alisasing</em> 기법을 통해 해결해왔다.</p>

<p>첫번째로 <em>Shadow Map</em> 을 샘플링할 때 일반적인 색을 가져오는 샘플링이 아닌 다른 방식을 사용한다. <em>Shadow Map</em> 을 한번 샘플링할 때 하드웨어에서 주변의 텍셀을 샘플링해 주변 텍셀과 비교를 수행해 모든 비교결과를 이중선형 보간을 적용한 결과를 주는 샘플링 방식을 사용한다고 한다. 만약 이중선형 보간을 사용하지 않는다면 <em>Point Sampling</em> 을 여러번 하여 결과들을 사용해 <em>PCF</em> 를 적용시켜주면 된다. 이렇게 해주면 조금 부드러운 결과가 나오게 된다.</p>

<p>하지만 이로써는 만족할만한 결과를 얻을 수 없어 주변을 여러번 샘플링해 값을 가져온다. 미리 생성된 <em>offset</em> 을 사용해 기준 <em>UV</em> 주변을 샘플링한다.</p>

<pre><code class="language-C">for (int i=0;i&lt;4;i++){
  if ( texture( shadowMap, ShadowCoord.xy + poissonDisk[i]/700.0 ).z  &lt;  ShadowCoord.z-bias ){
    visibility-=0.2;
  }
}
</code></pre>

<p>미리 생성된 <em>offset</em> 은 <em>Poisson Disc</em> 방식으로 생성된듯하다. <em>visibility</em> 변수는 색의 어두움을 결정하는 변수로 한번 <em>Depth Test</em> 에 걸리면 0.2를 줄여 0.2 ~ 1 사이의 값을 가진다.</p>

<p>이렇게 두가지 방식으로 <em>anti-aliasing</em> 을 해주면 제법 그럴듯한 결과가 나온다.</p>

<p><br />
<img src="/images/OGLTuto_SoftShadows_Wide.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>또한 <em>UV</em> 좌표에 <em>offset</em> 을 주는 방법은 꽤나 많다. 위의 방법은 랜덤으로 고정된 부분만 체크하지만 이 방법에 임의로 <em>offset</em> 돌려주는 방법도 있다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://www.opengl-tutorial.org/kr/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial : Tutorial 16 Shadow mapping</a></li>
  <li><a href="http://ogldev.atspace.co.uk/www/tutorial42/tutorial42.html">OGLdev : Percentage Closer Filtering</a></li>
  <li><a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">GPU Gems : Chapter 11. Shadow Map Antialiasing</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Supersampling#Poisson_disc">Wikipedia : SuperSampling#poisson_disc</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/29/using-compute-shader-in-unity/">Using Compute Shader In Unity</a>
          </h1>

          <p class="post-meta">Nov 29, 2017 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>Compute Shader</em> 는 <em>DirectX 11</em> 의 등장과 함께 본격적으로 쓰이기 시작했다. 지금은 <em>GPGPU</em> 의 본격적인 기능으로 CPU 에서 처리하기 힘든 계산량을 책임지는 중요한 기능으로 자리잡았다. 실시간으로 현실적인 그래픽을 구현하기 위해 요즘의 게임들은 <em>Compute Shader</em> 를 사용해서 여러 계산을 한다. 조금이라도 퍼포먼스가 필요하다면 당연히 쓰게되는 것이다.</p>

<p>사용하는 방법 자체는 간단하지만 <em>Compute Shader</em> 를 사용해 어떤 기능을 구현하는지가 중요하다. 간단하게 사용방법부터 알아보자. Unity 에서는 <em>Compute Shader</em> 를 위한 파일을 생성해야 한다.</p>

<p><img src="/images/create_computeshader.png" alt="create computeshader" class="center-image" /></p>

<p>프로젝트창에서 위 그림과 같이 생성해주면 된다. 그러면 아래와 같은 기본소스로 파일이 생성된다.</p>

<pre><code class="language-C">// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D&lt;float4&gt; Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!

	Result[id.xy] = float4(id.x &amp; id.y, (id.x &amp; 15)/15.0, (id.y &amp; 15)/15.0, 0.0);
}
</code></pre>

<p>위의 소스는 <em>HLSL</em> 로 코딩된 소스로 <em>DirectX 11</em> 을 기준으로 코딩되어 있다. <em>UnityCG</em> 파일안의 코드를 이용하면 <em>GLSL</em> 로 자동 컨버팅이 되기도 한다. 직접 <em>GLSL</em> 코드로 코딩하고 싶다면 <em>GLSLPROGRAM</em> 과 <em>ENDGLSL</em> 로 코드를 감싸주면 간단하게 해결된다.</p>

<p>내용은 간단하다. 각 텍셀별로 접근이 가능한 <em>Texture</em> 를 이용해서(<em>DirectX</em> 에서는 UAV 라고 칭한다.) <em>Texture</em> 에 값을 채운다. <em>HLSL</em> 의 자세한 문법과 사용방법은 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a> 들을 참고하길 바란다.</p>

<p>또한 쉐이더에서 뿐만아니라 <em>Unity</em> 스크립트상에서도 데이터들을 연결해주어야 한다. 사용하는 유형은 간단하다. <strong>UnityEngine.Texture</strong> 에서 파생된 텍스쳐들, <strong>UnityEngine.RenderTexture</strong>, <strong>UnityEngine.ComputeBuffer</strong> 정도면 모든 활용이 가능하다. <strong>UnityEngine.RenderTexture</strong> 에서는 <em>Cubemap</em> 도 지원하니 간단하게 쓸 수 있다. 해당 인스턴스를 넘겨주는 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;

shader.SetTexture("Result", rt);
</code></pre>

<p>코드에서의 변수명을 맞추어 넣어주거나 해쉬값을 미리 가져와 넣어주면 된다. 다른 유형의 데이터들도 이런 방법으로 넣을 수 있다. 데이터를 넣어주면 다음은 <em>Compute Shader</em> 를 실행하여 결과를 얻어야 한다. 간단하게 함수호출만 해주면 된다. 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;
int kernelIndex = shader.FindKernel("CSMain");

shader.Dispatch(kernelIndex, rt.width / 8, rt.height / 8, 1);
</code></pre>

<p>해당 <em>Compute Shader</em> 소스는 텍스쳐안에 값을 채우는 코드이기 때문에 위와같이 해주었다. <a href="https://docs.unity3d.com/ScriptReference/ComputeShader.Dispatch.html">Unity Reference : ComputeShader.Dispatch</a> 와 위의 <em>Compute Shader</em> 소스를 참고하면 알겠지만 최대 3차원의 방식으로 <em>Compute Shader</em> 의 그룹을 설정하여 계산이 가능하다.  <em>Compute Shader</em> 소스의 <em>[numthreads(8,8,1)]</em> 는 한 그룹의 <em>Thread</em> 갯수를 나타내고, <em>ComputeShader.Dispatch</em> 메소드는 몇개의 그룹을 실행시키는지 넘겨주는 메소드다. 아래 그림을 보면 조금더 쉽게 이해가 가능하다.</p>

<p><br />
<img src="https://msdn.microsoft.com/dynimg/IC520438.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN</a>
</center>
<p><br /></p>

<p><em>Compute Shader</em> 는 <em>DirectX 11</em> 이상, <em>Vulkan</em>,  <em>OpenGL 4.3</em> 이상, <em>OpenGL ES 3.0</em> 이상, <em>Metal</em> 에서 사용가능하다. 그 아래의 플랫폼은 지원하지 않는다. 또 유의해야 할점은 그래픽 드라이버별로 지원 기능이 조금씩 다를 수 있으니 기능을 유의하며 사용해야한다. <a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a> 에서 조금 참고할 수 있다.</p>

<p><a href="{ post_url 2017-08-01-using-compute-buffer-in-unity }">Using Compute Buffer in Unity</a> 에서 관련된 내용을 언급했으니 같이 보면 좋을듯 하다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a></li>
  <li><a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/18/DrawInstanced-vs-Merged-Instancing/">Drawinstanced Vs Merged Instancing</a>
          </h1>

          <p class="post-meta">Nov 18, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a> 슬라이드에 따르면 <em>DrawInstanced</em> 함수를 사용하여 인스턴싱을 하는것보다 <em>vertexID</em> 를 사용하여 인스턴싱을 하는것이 빠르다고 한다. <em>vertexID</em> 를 쓰는 방법은 굉장히 단순하다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VSOutput VS(uint id : SV_VertexID)
{
    VSOutput output;

    /*
        ...
    */

    return output;
}
</code></pre></div></div>

<p><em>SV_VertexID</em> <em>Semantic</em> 을 사용하여 값을 접근하기만 하면 된다. <em>vertexID</em> 는 말그대로 버텍스별 인덱스를 뜻한다. <em>SRV</em> 나 <em>UAV</em> 와 함께 사용하여 <em>Instancing</em> 을 하면된다.</p>

<p><br />
<img src="/images/gdc2014_vertexshadertricks_23.png" alt="Merge Instancing Performance" /></p>
<center>출처 : <a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a>
</center>
<p><br /></p>

<p>그림을 보면 AMD GPU 에서 확실히 퍼포먼스 차이가 난것을 확인할 수 있다. <del>스피커가 AMD 소속이라는 게 포인트</del></p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-3/">Hbao Plus Analysis 3</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-2/">hbao plus analysis 2</a> 글에서 <em>Horizon based ambient occlusion</em> 와 <em>Cross Bilateral Filter</em> 대해서 알아보았다. 이번 글에서는 부록의 느낌으로 <em>HLSL</em> 코드를 읽으면서 생소했던 기타 기법들에 대해서 써볼 것이다.</p>

<p>첫번째로 <em>Full Screen Triangle</em> 이라는 기법이다. 알고마면 굉장히 단순한 개념으로, 화면을 모두 덮는 한개의 삼각형을 그려서 모든 픽셀에 쉐이더를 돌릴 수 있게 해주는 기법이다. 아래 슬라이드를 보면 쉽게 이해가 갈것이다.</p>

<p><br />
<img src="/images/vertex-shader-tricks-by-bill-bilodeau-amd-at-gdc14-14-638.jpg" alt="Full Screen Triangle" class="center-image" /></p>
<center>출처 : <a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a>
</center>
<p><br /></p>

<p>단순하지만 처음 봤을 때는 조금 신박하게 느껴질 수도 있다. 두번째로는 모든 계산에 최대한 <em>HLSL Intrisic</em> 을 사용한다. 특히 벡터와 벡터사이의 거리를 계산할때 <em>dot product</em> 를 써서 하는게 정말 많았다. 어셈블리 레벨에서 달라지는것 같긴하나 정확한 이유는 알지 못했다. 추측해보면 GPU 에서 해당 명령어가 있지 않을까.. 라고 생각한다.</p>

<p>세번째도 위의 것과 비슷하다. 대부분의 데이터에 <em>MAD</em> 방식을 사용해서 계산한다. 하지만 이는 거의 공식적으로 정해진게 있다. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471418.aspx">MSDN : mad  function</a> 레퍼런스에서도 나오듯이 어떤 GPU 에서는 위에서 추측한대로 하드웨어에서 지원하는 명령어라고 한다.</p>

<blockquote>
  <p>…
Shaders can then take advantage of potential performance improvements by using a native mad instruction (versus mul + add) on some hardware.
…</p>
</blockquote>

<p>또한 <em>HBAO+</em> 소스에서 찾은 주석에는 <em>GK104</em> 부터 특정 구간에서 10% 퍼포먼스 이득이 있다고 쓰여져 있다.</p>

<p>네번째는 나누기를 절대 쓰지 않는다. 나머지 연산(mod, A % B)는 간혹 쓰이지만 나누기는 절대로 쓰이지 않았었다. 혹시라도 필요하다면 전부 <em>Constant Buffer</em> 에 CPU 에서 역수를 취해서 넘겨주는 방식으로 되어 있었다. 이도 역시 하드웨어에서 동작하는 부분을 알고 짠듯하다.</p>

<p>다섯번째는 <em>HLSL</em> 코드를 <em>cpp</em> 소스에 <em>include</em> 하여 <em>Constant Buffer</em> 값을 갱신하는 코드였다. 여태까지 예전의 <em>DirectX</em> 소스만 보거나 <em>Unity</em> 에서만 작업을 해서 그런지 이런 기능은 굉장히 낯설었다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a></li>
  <li><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471418.aspx">MSDN : mad function</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-2/">Hbao Plus Analysis 2</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/bilateral-filter/">bilateral_filter</a>
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-1/">hbao plus analysis 1</a> 글에서 <em>HBAO+</em> 에서 <em>Linearize Depth</em> 와 <em>Deinterleaved Texturing</em> 에 대해서 알아보았다. 이번 글에서는 <em>HBAO+</em> 의 핵심 알고리즘인 <em>Horizon Based Ambient Occlusion</em> 와 AO 블러에 사용되는 <em>Cross Bilateral Filter</em> 에 대해서 알아볼것이다.</p>

<h2>Horizon Based Ambient Occlusion</h2>

<p><em>Horizon Based Ambient Occlusion</em> 은 xy 평면과(horizon) Depth 값을 사용해서 <em>AO</em> 를 계산한다. 슬라이드에서 가져온 일부를 보자.</p>

<p><br />
<img src="/images/hbao_siggraph08_05.png" alt="Horizon Mapping" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Siggraph 2008 : Image-Space Horizon-Based Ambient Occlusion</a>
</center>
<p><br /></p>

<p>해당 슬라이드에서는 xy평면을 단순하게 1차원인 x축만으로 나타냈다. <em>HBAO</em> 는 그림에 나오는 <em>horizon angle</em> 을 사용하여 <em>AO</em> 값을 구한다. 자세한 방법은 아래 슬라이드를 보자.</p>

<p><br />
<img src="/images/hbao_siggraph08_12.png" alt="Horizon-Based AO" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Siggraph 2008 : Image-Space Horizon-Based Ambient Occlusion</a>
</center>
<p><br /></p>

<p>슬라이드에서는 표면의 접선을 나타내는 <em>Tangent</em> 벡터와 <em>Horizon</em> 벡터를 사용해서 <em>sin</em> 의 차이로 <em>AO</em> 를 계산한다고 설명되어 있다. <em>Horizon</em> 벡터는 <em>Depth</em> 와 화면의 좌표를 구해서 샘플링하는 위치값을 구하고 기준이 되는 위치값의 차이를 통해 구한다. <em>HBAO+</em> 코드에서는 입력을 받은 <em>Normal</em> 벡터와 <em>Horizon</em> 벡터에 <em>dot</em> 을 사용해 <em>cos</em> 값을 구하고 변환해준다. 이렇게 한번 <em>AO</em> 값을 구한다.</p>

<p>보다 정확한 <em>AO</em> 값을 구하기 위해서는 전방위로 탐색할 필요가 있다. 정해진 방향으로 샘플링을 해도 오차가 생길 수 있고 완전히 랜덤하게 방향을 정해도 부정확한 결과를 얻을 수 있다. 그래서 <em>HBAO</em> 는 랜덤하게 방향을 정하나 그 방향 벡터를 정해진 각도로 돌려주어 그나마 정확한 결과를 얻으려 한다. 슬라이드를 보고 넘어가자.</p>

<p><br />
<img src="/images/hbao_siggraph08_14.png" alt="Sampling the Depth Image" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Siggraph 2008 : Image-Space Horizon-Based Ambient Occlusion</a>
</center>
<p><br /></p>

<p>핵심적인 개념은 모두 설명했지만 만족할만한 결과를 얻기 위해 여러가지 보정 방법들이 필요하다. 그래서 <em>HBAO</em> 에서는 두가지 보정을 해주는 개념을 설명한다. <em>HBAO</em> 는 방향을 설정해주고 해당 방향으로 한번만 샘플링 하는게 아니라 여러번 샘플링 한다. 그러므로 거리에 따른 감쇠(attenuation)가 필요하다. 방법은 간단하다. <em>AO</em> 를 계산할때 구했던 <em>Horizon</em> 벡터의 크기에 따라서 <em>AO</em> 값을 줄여준다. 나머지 한가지는 <em>Horizon</em> 벡터와 <em>Tangent</em> 벡터를 이용해 구하는 실질적인 <em>AO</em> 값에 <em>Bias</em> 로 낮은 <em>AO</em> 값들을 무시하는 방법이다. <em>Bias</em> 가 없이 <em>AO</em> 를 생성하게 되면 노이즈가 생기기 때문이다. 또한 <em>Bias</em> 로 생긴 수학적 오차는 코드에서 따로 보정해주기 때문에 크게 문제는 없다.</p>

<h2>Cross Bilateral Filter</h2>

<p><em>SSAO</em> 의 결과에는 일반적으로 블러를 먹이게 된다. 대부분 근사에 기반한 계산이기 때문이다. <em>HBAO</em> 에서는 <em>Depth</em> 를 이용한 방법을 소개한다. 바로 <em>Cross Bilateral Filter</em> 다.</p>

<p><em>Cross Bilateral Filter</em> 은 <em>Gaussian Filter</em> 와 비슷한 필터로, <em>Gaussian Filter</em> 는 샘플링할 위치의 거리에 따라 점차 가중치가 줄어드는 필터라면, <em>Bilateral Filter</em> 는 위치에 따라 가중치가 줄어드는게 아닌 각 위치별로 가지고 있는 한개의 스칼라값에 차이에 따라서 가중치를 정하는 필터다. <em>Cross</em> 단어를 붙인 이유는 왼쪽과 오른쪽 방향의 필터와 위와 아래의 필터를 따로하기 때문에 <em>Cross</em> 라는 단어를 붙인 듯 하다. <em>HBAO+</em> 코드에서도 X 축과 Y 축을 기준으로 하는 블러 소스가 나누어져 있다. <em>HBAO</em> 에는 한개의 스칼라 값을 <em>Depth</em> 를 기준으로 계산한다. 그래서 크게 튀는 부분의 결과는 많이 반영하지 않아 전체적으로 뿌옇게 바뀐다.</p>

<p><br />
<img src="/images/hbao_siggraph08_28.png" alt="Sampling the Depth Image" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Siggraph 2008 : Image-Space Horizon-Based Ambient Occlusion</a>
</center>
<p><br /></p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVidia HBAO+</a></li>
  <li><a href="http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">Image-Space Horizon Based Ambient Occlusion</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Gaussian_filter">Wikipedia : Gaussian Filter</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Bilateral_filter">Wikipedia : Bilateral Filter</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-1/">Hbao Plus Analysis 1</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/linearize-depth/">linearize_depth</a>,
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/deintereaved-texturing/">deintereaved_texturing</a>
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-0/">hbao plus analysis 0</a> 글에서 <em>HBAO+</em> 을 알기위한 기본적인 개념들에 대해서 살펴보았다. 이번 글에서는 <em>HBAO+</em> 의 구조와 <em>Linearize Depth</em> 와 <em>Deinterleaved Texturing</em> 에 대해서 알아보겠다.</p>

<h2><em>HBAO+</em> Pipeline</h2>

<p><br />
<img src="/images/hbao+_pipeline_with_input_normals.png" alt="hbao+ with input normal" class="center-image" /></p>
<center>출처 : <a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a>
</center>

<p><br />
<img src="/images/hbao+_pipeline_without_input_normals.png" alt="hbao+ without input normal" class="center-image" /></p>
<center>출처 : <a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a>
</center>
<p><br /></p>

<p>그림이 두개가 있다. 하나는 <em>GBuffer</em> 를 사용할 시 <em>World-Space Normal</em> 버퍼와 <em>Depth Buffer</em> 를 넘겨주어 계산하는 방식과 입력으로 <em>Depth Buffer</em> 만 넘겨서 <em>Normal</em> 데이터를 계산하는 두가지 방식에 대한 파이프라인이다. 두가지의 차이는 <em>Normal</em> 데이터에 대한 처리방식만 다르다. 나머지 계산은 다를게 없다.</p>

<h2>Linearize Depths</h2>

<p>코드를 보면 가장 처음에 시작하는 단계는 바로 <em>Linearize Depths</em> 다. 이는 꽤나 알려진 방법이다. 하지만 필자는 <em>HBAO+</em> 를 볼때 처음 봤기에 어느 정도의 설명을 해놓아야겠다. <em>Linearize Depths</em> 를 알기 위해선 입력된 정점의 위치를 <em>Clipping-Space</em> 로 변환하는 방법이 어떻게 이루어지는지 알고 있어야 한다.</p>

<p>일반적인 오브젝트를 렌더링 할때는 <em>Shader</em> 에 입력으로 들어오는 정점의 기준 공간은 <em>Model-Space</em>(또는 <em>Local-Space</em>) <em>Position</em> 이다. 그래서 <em>MVP</em> 변환을 통해 <em>Rasterizer</em> 가 처리할 수 있도록 <em>Clipping-Space</em> 로 <em>Rasterizer</em> 로 넘어가기 전에 변환해주어야 한다.(전체적인 내용은 <a href="https://docs.google.com/presentation/d/10VzsjfifKJlRTHDlBq7e8vNBTu4D5jOWUF87KYYGwlk/edit#slide=id.g25f88339be_0_0">Model, View, Projection 변환</a> 에서 확인할 수 있다.
) 그래서 <em>Pixel Shader</em> 로 넘어간 데이터들은 픽셀별로 들어가고, 픽셀별로 들어간 정점들의 위치는 <em>Clipping-Space</em> 로 되어있다. 여기까지 이해했으면 아래 그림을 보자.</p>

<p><br />
<img src="/images/Graphics3D_ClipVolume.png" alt="Frustom vs Clipping" class="center-image" /></p>
<center>출처 : <a href="https://www.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html">3D Graphics with OpenGL Basic Theory</a>
</center>
<p><br /></p>

<p>위 그림은 <em>View Frustom</em> 과 <em>Clipping Volume</em> 을 보여준다. <em>View Frustom</em> 은 <em>Perspective</em> 방식으로 카메라가 실제로 보여주는 공간을 시각화 한것이고, <em>Clipping Volume</em> 은 <em>MVP</em> 변환에서 <em>Projection</em> 행렬을 사용할시 <em>View Frustom</em> 에서 <em>Clipping Volume</em> 으로 변환되는 볼륨을 시각화 한것이다. <em>Projection</em> 변환은 아래와 같다.</p>

<p><br />
<img src="/images/projection_matrix.png" alt="perspective projection matrix" class="center-image" /></p>
<center>출처 : <a href="https://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer
">Stackoverflow : Getting the true z value from the depth buffer</a>
</center>
<p><br /></p>

<p><em>Perspective Projection</em> 은 <em>Frustom</em> 기준 위치를 <em>Cube</em> 기준 위치로 바꾸는 연산이기 때문에 실제 좌표의 왜곡이 발생한다. 우리는 Z(Detph) 값이 어떤식으로 왜곡되는지 알아야 한다. 우선 <em>Clipping-Space</em> 로 변환할때, <em>Perspective</em> 형식의 <em>View Frustom</em> 의 <em>zNear</em>, <em>zFar</em> 사이의 Z 값을 [0~1] 값으로 매핑한다. 그러면 <em>zNear</em>, <em>zFar</em> 값을에 따라서 실제 좌표가 바뀐다. 그리고 값 자체가 실제 Z 값과 선형적으로 매핑되지 않는다. 아래 그림을 보자.</p>

<p><br />
<img src="/images/nonlinearDepth.png" alt="non linear depth" class="center-image" /></p>
<center>출처 : <a href="https://computergraphics.stackexchange.com/questions/5116/how-am-i-able-to-perform-perspective-projection-without-a-near-plane">Computer Graphics StackExchange : How am I able to perform perspective projection without a near plane?</a>
</center>
<p><br /></p>

<p>그림이 조금 헷갈릴수도 있다. 세로축의 <em>d</em> 값은 <em>Projection</em> 을 한 Z, <em>Depth</em> 값이고 가로축은 <em>World-Space</em> 의 Z 값이다. 조금 헷갈릴수도 있는 부분은 세로축의 기준값이 윗부분이 0이고 아랫부분이 1이다. 이 부분은 신경써서 봐야한다. 이해했다면 변경된 <em>Depth</em> 값은 실제 Z 값과 선형적인 관계가 아니고, 실제 Z 값으로 복원하려면 여러 연산을 해야하기에 <em>HBAO+</em> 에서는 <em>Depth</em> 값들을 <em>Linearize</em> 하는 과정을 맨 처음에 넣은 것이다. 실제 Z 값으로 복원하는 이유는 간단하다. <em>Linear</em> 하지 않은 <em>Depth</em> 값을 연산시에 사용하면 보다 부정확한 결과가 나오기 때문이다. 특히 <em>SSAO</em> 연산을 할때는 <em>Depth</em> 값이 기본이 되기 때문에 해주어야 한다.</p>

<p>이 단계에서의 결론은 간단하다. <em>Clipping-Space</em> 의 <em>Depth</em> 값을 <em>View-Space</em> 의 Z 값으로 변환하는 단계다. 처리하는 코드는 다른 단계에 비해 짧다. 만약에 넘겨준 <em>Depth</em> 데이터들이 <em>View-Space</em> 인 경우에는 옵션을 통해 처리할 수 있다.</p>

<h2>Deintereaved Texturing</h2>

<p>위의 그림에는 <em>Generate HBAO+</em> 라고 단순히 뭉뚱그려서 표현했지만 그 안에는 단순한 <em>Horizon based ambient occlusion(HBAO)</em> 계산만 있지는 않다. <em>Deintereaved Texturing</em> 이라는 테크닉과 함께 <em>HBAO</em> 를 계산한다. <em>Computer Engineering</em> 분야의 지식을 응용한 이론으로 개인적으로 이 이론을 접했을 떄 꽤나 충격이였다. 자세한 설명은 <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a> 슬라이드의 몇장과 함께 보자.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_51.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_51" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p><em>Deintereaved Texturing</em> 의 방법은 간단하다. 텍스쳐를 여러장으로 나누어 샘플링을 한 후 각각의 나눠진 텍스쳐를 샘플링한 결과를 하나로 합친다. 슬라이드에는 <em>Post-Processing</em> 을 기준으로 설명이 되어있다. 이점은 생각하면서 보자.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_52.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_52" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>한 텍스쳐를 여러장으로 나누는건 <em>Multiple Render Target</em> 을 사용해서 나눈다. 슬라이드는 4개를 기준으로 설명했지만 <em>DirectX10</em> 부터는 최대 8개까지 지원하기 때문에 16개로 나누어 샘플링한다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_53.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_53" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>다음은 나누어진 각각의 텍스쳐를 샘플링하여 원하는 알고리즘으로 결과를 낸다. 조각난 텍스쳐 한개당 한번 <em>DrawCall</em> 을 걸어준다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_54.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_54" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p><em>Deintereave</em> 를 하기전까지는 넓은 범위의 텍스쳐를 샘플링하여 캐시 효율이 많이 떨어졌지만 텍스쳐를 나누어 각각 할때마다 처리를 하게되니 캐시 효율의 이득을 얻었다. 또한 각각의 <em>DrawCall</em> 마다 텍스쳐의 용량이 조금만 필요하게 되니 대역폭의 이득도 얻게 된다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_55.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_55" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>한번의 <em>DrawCall</em> 로 나누어진 결과들을 합친다. <em>Deintereaved Texturing</em> 은 여기서 끝이다. 실제로 <em>HBAO+</em> 는 16개의 텍스쳐로 나누어 샘플링한다. <em>Multiple Render Target</em> 이 8개까지 지원되어 16개로 <em>Deintereave</em> 하려면 2번 <em>DrawCall</em> 을 해야한다. 또한 샘플링은 16번 <em>DrawCall</em> 을 하여 계산한다. 그래서 한번 <em>Deintereaved Texturing</em> 을 사용하여 <em>Post-Processing</em> 처리하려면 약 20번의 <em>DrawCall</em> 을 계산해야 한다. 절대적으로 큰 숫자가 아니기 때문에 크게 신경쓸 필요는 없어보인다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_62.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_62" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>엄청난 성과를 거둔게 보인다. 캐시 히트 확률이 굉장히 올라갔고, 시간도 많이 절약했다. <em>HBAO+</em> 의 성능향상을 시켜준 것이 이 <em>Deinterleaved Texturing</em> 인듯하다.</p>

<h2>Reconstruction of Normal</h2>

<p><em>HBAO+</em> 는 기본적으로 <em>Depth</em> 와 <em>Normal</em> 을 통해서 계산한다. 그렇기 때문에 외부에서 <em>Normal</em> 데이터를 넣어주거나 직접 만들어야 한다. 보통 <em>Deffered Rendering</em> 을 차용하는 시스템들은 간단하게 <em>GBuffer</em> 의 <em>Normal</em> 데이터만 넣어주면 된다. <em>Normal</em> 데이터를 가져오는 코드가 있으니 조금만 수정하여 사용하면 된다.</p>

<p><em>Normal</em> 데이터가 없는 경우에는 라이브러리 내에 직접 계산한다. 계산하는 픽셀을 기준으로 상하,좌우별로 <em>Depth</em> 와 화면상의 좌표계를 이용하여 <em>View-Space</em> 의 위치를 구한다음 위치가 상하, 좌우별로 가까운 픽셀의 위치 오프셋을 사용해 외적하여 <em>Normal</em> 값을 구한다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVidia HBAO+</a></li>
  <li><a href="https://developer.nvidia.com/sites/default/files/akamai/gameworks/samples/DeinterleavedTexturing.pdf">NVidia : Deintereaved Texturing</a></li>
  <li><a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a></li>
  <li><a href="http://www.gdcvault.com/play/1017623/Advanced-Visual-Effects-with-DirectX">GDCVault : Particle Shadows &amp; Cache-Efficient Post-Processing Video</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-0/">Hbao Plus Analysis 0</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>게임에서 쓰이는 실시간 렌더링에서 빛과 물체들의 상호작용을 완벽하게 현실적으로 표현하는 거의 불가능하다. 하지만 이를 위해 수십년동안 많은 엔지니어와 연구자들이 노력하여 부분적이고 제한된 환경에서의 빛과 물체의 상호작용을 현실 세계와 비슷하게 따라잡고 있다. 이번 글에서 살펴볼 것은 <em>Screen-Space Ambient Occlusion(SSAO)</em> 기반의 <em>HBAO+</em> 라는 라이브러리에 대해서 알아볼 것이다.</p>

<p><em>HBAO+</em> 는 NVidia 에서 만든 라이브러리로써, 현재 <a href="https://developer.nvidia.com/shadowworks"><em>ShadowWorks</em></a> 라는 프로젝트에 포함되어 있다. <a href="https://developer.nvidia.com/shadowworks"><em>ShadowWorks</em></a> 에는 <em>HBAO+</em> 뿐만 아니라 <em>ShadowLib</em> 이라는 그림자 렌더링을 위한 라이브러리로써 HFTS, PCSS, CSM 등 많은 기능들을 포함하고 있는 라이브러리가 있다. 현재 <em>ShadowLib</em> 은 오픈소스가 아니지만 이번에 알아볼 <em>HBAO+</em> 는 <em>Github</em> 에서 소스를 받을 수 있다. 이에 대한 자세한 사항은 <a href="https://developer.nvidia.com/gameworks-source-github">“Access GameWorks Source on Github”</a> 에서 확인할 수 있다.</p>

<h3>Ambient Occlusion?</h3>

<p><em>Ambient Occlusion</em> 이란 말은 처음 들어본 사람에게는 생소한 말이지만 한번이라도 들어본 사람들에게는 꽤나 익숙한 말일 것이다. 빠른 이해를 위해 아래 그림을 보자.</p>

<p><br />
<img src="/images/220px-AmbientOcclusion_German.jpg" alt="Wikipedia : Ambient Occlusion Image" class="center-image" /></p>
<center>출처 : <a href="https://en.wikipedia.org/wiki/Ambient_occlusion">Wikipedia : Ambient Occlusion</a>
</center>
<p><br /></p>

<p>가장 위의 이미지를 보자. 단순한 렌더링이 아니라 반사를 구현해놓아서 꽤나 사실적이다. 하지만 여기서 더욱더 사실적으로 표현이 가능하다. 중간의 이미지를 보면 <em>Ambient Occlusion</em> 이 무엇인지 쉽게 알 수 있다. 흰색 물체와 흰색 배경과 함께 아래 구석에 어두워진 것을 볼 수 있다. 이를 <em>Ambient Occlusion</em> 이라고 한다.</p>

<p>글로 간단하게 설명하자면 물체가 모이면 좁은 공간이 생기게 되고, 구석이면 구석일 수록 직접 들어오는 빛은 있으나 반사되어 오는 빛이 적어지므로 어두워진다. 이를 말하는 것이바로 <em>Ambient Occlusion</em> 이다. <em>Ambient</em> 는 주변을 뜻하고, <em>Occlusion</em> 은 무언가 가리는 것을 뜻한다. 빛을 가려서 주변에 보이는 것이 어두워지는 것을 말하는 것이다.</p>

<p>보통 <em>Ambient Occlusion</em> 은 개발시에 미리 시간을 들여 계산해 미리 저장해놓은 다음 실시간으로 저장된 데이터를 읽어서 사용하는 <em>precomputed AO</em> 방식으로 사용한다. 이유는 간단하다. 실시간으로 계산되기에는 요즘 컴퓨터로는 연산량을 버틸 수 없어서 그렇다. 월드가 복잡할수록, 넓을수록, 고퀄리티의 <em>AO</em> 를 계산할수록 시간이 대폭 증가한다. 하지만 이는 물체와 물체간의 <em>AO</em> 를 계산할때의 이야기이다.</p>

<h3>Screen-Space AO?</h3>

<p><em>Deffered Rendering</em> 이 많이 쓰이면서 이를 위한 많은 기술들이 연구되었다. <em>Deffered Rendering</em> 의 대부분의 기술들은 이름앞에 보통 <em>Screen-Space</em> 라는 단어를 달고 나왔다. <em>Screen-Space</em> 란 <em>Geometry Stage</em> 아닌 <em>Rasterizer Stage</em> 로 넘어가서 처리되는 부분을 말한다. 말 뜻대로 해석한다면 2D 이미지의 공간이라는 뜻도 되겠다. 다만 <em>Pixel Shader</em> 로 넘어간다고 해서 <em>Depth(Z value)</em> 가 사라지지는 않기 때문에 이를 온전히 2D 공간이라고도 볼 수는 없다. 실제 좌표계는 <em>Clipping-Space</em> 로 되어 있을 것이다.(x,y,z 가 -1 ~ 1 범위의 좌표로 되어있는 공간, Driver API 에 따라 조금씩 다르다.) 쉽게 이해하기 위해 아래 그림을 보자.</p>

<p><br />
<img src="/images/DeferredLighting.jpg" alt="Deffered Rendering" class="center-image" /></p>
<center>출처 : <a href="http://tower22.blogspot.kr/2010/11/from-deferred-to-inferred-part-uno.html">From Deferred to Inferred, part uno</a>
</center>
<p><br /></p>

<p>위 그림은 <em>Deffered Rendering</em> 의 중요한 특징을 나타내는 그림이다. 이 데이터들을 <em>GBuffer</em> 라고 한다. 저 결과들은 <em>Multi Render Target</em> 을 통해 한 <em>Pixel Shader</em> 에서 나온 결과물들이다. 즉 한 장면을 렌더링해서 2D 버퍼안에 데이터들을 픽셀별로 저장한 것이다. 각각 저마다 필요한 정보들을 담고 있다. 우리가 알아볼 <em>Screen-Space AO</em> 또한 이런식으로 데이터를 처리한다. 위 그림에는 나와있지 않지만 하드웨어 차원에서 <em>Depth Buffer</em> 를 지원한다. <em>Pixel Shader</em> 를 실행한 후 알아서 <em>Depth Buffer</em> 에 Z 값을 저장해준다. <em>Screen-Space AO</em> 는 <em>Depth Buffer</em> 를 이용하여 계산한다. 물론 <em>Depth Buffer</em> 뿐만아니라 <em>GBuffer</em> 에서 <em>Normal</em> 데이터까지 사용하여 할 수도 있다.</p>

<p>하지만 <em>SSAO</em> 는 정공법이 아니다. 모든 <em>AO</em> 를 표현할 수 없으며 디테일한 <em>AO</em> 밖에 표현하지 못한다. 그렇기에 이는 부가적인 방법으로 사용되어야 한다. <em>SSAO</em> 를 활용하기 가장 좋은 장면은 화면에서 작게 표시되는 오브젝트들이 조밀하게 많이 있을 떄나 그려지는 오브젝트의 디테일이 많을 때다. 이럴때 <em>SSAO</em> 를 표현하면 괜찮은 결과가 나온다.</p>

<p><br />
<img src="/images/0cf69542-8ff5-422a-8d01-f11bd65ab62e_scaled.jpg" alt="Unity Technology : SSAO" class="center-image" /></p>
<center>출처 : <a href="https://forum.unity.com/threads/ssao-pro-high-quality-screen-space-ambient-occlusion.274003/page-5">Unity Forum</a>
</center>
<center></center>
<p><br /></p>

<p>게임에서는 조금이라도 복잡한 메시를 쓸 수 밖에 없기 때문에 결국 왠만한 게임에는 <em>SSAO</em> 를 넣는 것이 괜찮은 선택이 된것이다. 하지만 초기에 제안된 <em>SSAO</em> 구현물들은 대부분 꽤나 시간을 잡아먹었었다. 그래서 시간에 따른 선택이 되었지만 <em>HBAO+</em> 와 같은 개량된 기법이 여러개 등장하여 퍼포먼스를 다른 곳에 쓸 수 있게 되었다. <a href="https://www.geforce.com/hardware/technology/hbao-plus/technology">Geforce : HBAO+ Technology</a> 에서 <em>SSAO</em> 테크닉에 따른 벤치마킹을 볼 수 있다.</p>

<p><br />
<img src="/images/hbao_bench.png" alt="benchmark" class="center-image" /></p>
<center>출처 : <a href="https://www.geforce.com/hardware/technology/hbao-plus/technology">Geforce : HBAO+ Technology</a>
</center>
<center></center>
<p><br /></p>

<p>우리가 살펴볼 것은 가장 아래에 있는 <em>HBAO+</em> 에 대한 것들이다. <em>Resolution</em> 은 <em>Depth Buffer</em> 의 해상도를 뜻한다. 당연히 큰 사이즈여야 디테일한 것까지 표현할 수 있다. 가장 왼쪽에 있는 것은 시간이다. <em>HBAO+</em> 가 2.4ms 로 조금 느리지만 그 오른쪽에 있는 <em>Occlusion Samples Per AO Pixel</em> 의 숫자와 같이 비교하면 이야기가 다르다. 이는 한 픽셀별로 몇번 다른 텍스쳐의 데이터 샘플링 숫자다. <em>HBAO</em> 는 4번만 하지만, <em>HBAO+</em> 는 이의 9배인 36번이다. 샘플링을 많이하게 되면 더욱더 사실적인 <em>SSAO</em> 를 표현할 수 있다. 샘플링 숫자에 비하면 시간은 내어줄 수 있는 자원인 것이다.</p>

<p>이 글에서는 <em>HBAO+</em> 를 분석하기 전 배경이 되는 개념에 대해서 알아보았다. 다음 <a href="/2017/11/15/hbao-plus-analysis-1/">hbao plus analysis 1</a> 에서는 <em>HBAO+</em> 라이브러리에 대한 본격적인 분석을 해보려고 한다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Ambient_occlusion">Wikipedia : Ambient Occlusion</a></li>
  <li><a href="https://developer.nvidia.com/developer-program">NVidia Developer Program</a></li>
  <li><a href="https://www.geforce.com/hardware/technology/hbao-plus/technology">Geforce : HBAO+ Technology</a></li>
  <li><a href="https://forums.geforce.co.kr/index.php?document_srl=12616&amp;mid=geforce">한국 지포스 포럼 : HBAO+</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/31/shader-pipeline-4-geometry-shader/">Shader Pipeline 4 Geometry Shader</a>
          </h1>

          <p class="post-meta">Oct 31, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>“<a href="/2017/10/31/shader-pipeline-3-fragment-shader/">Fragemnt Shader</a>” 에서 <em>Fragment Shader</em> 에 대해 알아보았다. 다음은 <em>Geometry Shader</em> 에 대해서 써보려 한다.</p>

<p><em>Geometry Shader</em> 는 쉐이더 파이프라인에서 <em>Rasterizer Stage</em> 넘어가기 전의 <em>Geometry Stage</em> 의 마지막 단계로써 이전 쉐이더에서 넘긴  <em>Primitive</em> 데이터(point, line, triangle..)를 프로그래머가 원하는 복수의 <em>Primitive</em> 데이터로 변환할 수 있다. 삼각형을 삼각형의 중심을 나타내는 점으로 변환하는 쉐이더를 보자.</p>

<pre><code class="language-C">[maxvertexcount(1)]
void geom(vertexOutput input[3], inout PointStream&lt;geometryOutput&gt; pointStream)
{
    geometryShaderOutput o;

    o.vertex = (input[0].vertex + input[1].vertex + input[2].vertex) / 3;

    pointStream.Append(o);
}
</code></pre>

<p>매우 간단한 코드다. 간략하게 설명하자면, 맨 윗줄의 <em>maxvertexcount</em> 는 해당 지오메트리 쉐이더에서 <em>Stream</em> 으로 넘길 정점별 데이터의 갯수를 뜻한다. <em>Geometry Shader</em> 한번당 <em>Stream</em> 으로 넘길 <em>maxvertexcount</em> 의 한계는 정해지지 않았지만 크기는 1024 바이트로 정해져 있기 때문에 적절하게 사용해야 겠다. 그 다음줄의 인자들에 대해서 설명하면, 첫번째 <em>vertexOutput input[3]</em> 은 정해진 프리미티브의 값들을 뜻한다. 여기서는 삼각형을 기준으로 만들었기 때문에 정점별 정보가 3개가 있다. _inout PointStream<geometryOutput> pointStream_ 은 _Geometry Shader_ 의 최종 출력을 해주는 오브젝트다. _PointStream_ 은 점 프리미티브의 데이터를 받는 _Stream_ 으로써, 프리미티브가 다르면 각자 다른것을 사용할 수 있다.([MSDN : Getting Started with the Stream-Output Stage](https://msdn.microsoft.com/en-us/library/windows/desktop/bb205122.aspx)) 부등호 안에 있는 것은 일반적으로 알려진 제너릭이나 템플릿의 형태와 같으니 안에 출력으로 넘길 구조체를 넘겨주면 된다. 함수의 내용은 삼각형을 구성하는 각 정점의 위치의 평균을 구해 하나의 정점 정보만 _Stream_ 에 넘긴다.</geometryOutput></p>

<p><em>Stream</em> 은 총 두가지의 역할을 한다. 하나는 <em>Rasterizer</em> 단계로 넘겨서 쉐이더에서 처리를 할 수 있게 하는 통로 역할을 하고, 다른 하나는 드라이버 레벨에서 데이터를 출력해주는 통로 역할을 한다. 두가지의 일을 하기 때문에 <em>Stream</em> 의 개념으로 추상화한 것인가 싶다. 그리고 하나의 <em>Geometry Shader</em> 에서 여러개의 <em>Stream</em> 으로 출력이 가능하긴 하다. 최대 4개의 <em>Stream</em> 을 사용할 수 있다. <em>Stream</em> 을 선택해서 데이터를 받아올 수도 있으며, <em>Rasterizer</em> 로 보낼수도 있다. 자세한 사항은 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471424.aspx">MSDN : How To: Index Multiple Output Streams </a> 에서 확인하면 되겠다.</p>

<p>활용할 수 있는 다른 기능이 하나 더 있다. <em>instance</em> 기능이다. 아래 코드를 보자.</p>

<pre><code class="language-C">[instance(3)]
[maxvertexcount(1)]
void geom(vertexOutput input[3], uint InstanceID : SV_GSInstanceID, inout PointStream&lt;geometryOutput&gt; pointStream)
{
    geometryShaderOutput o;

    o.vertex = input[InstanceID].vertex;

    pointStream.Append(o);
}
</code></pre>

<p>해당 코드는 삼각형의 세개의 정점 위치를 넘기는 코드다. 달라진 것은 <em>instance(3)</em> 코드가 붙고, <em>uint InstanceID : SV_GSInstanceID</em> 파라미터가 생겨 코드 안에서 이를 활용한다. <em>instance(x)</em> 에 들어가는 x 는 반복하는 횟수를 뜻하고, <em>InstanceID</em> 파라미터는 반복하는 인덱스를 뜻한다. 같은 입력을 여러번 받아서 일정한 수만큼 반복하는 것이다.  <em>instance</em> 속성에 들어가는 숫자의 한계는 32까지다.</p>

<p><em>Geometry Shader</em> 는 <em>Shader Model 4.0</em> 에서 추가되었으며 뒤에 추가적으로 알아본 <em>multiple stream</em> 과 <em>instance</em> 키워드는 <em>Shader Model 5.0</em> 에서 확장된 기능들이다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb509609.aspx">MSDN : Geometry-Shader Object</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb205122.aspx">MSDN : Getting Started with the Stream-Output Stage</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471424.aspx">MSDN : How To: Index Multiple Output Streams</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471425.aspx">MSDN : How To: Instance a Geometry Shader</a></li>
  <li><a href="https://www.gamedev.net/forums/topic/600141-limit-on-maxvertexcount-gs/">GameDev : limit on maxvertexcount() GS</a></li>
</ul>

        </div>

        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Su-Hyeok Kim - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
