<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Appocrypha</title>
  <meta name="description" content="store limitless knowledges">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Appocrypha">
  <meta name="twitter:description" content="store limitless knowledges">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/03/13/recommandation-of-gpu-skinning-in-github/">Recommandation Of Gpu Skinning In Github</a>
          </h1>

          <p class="post-meta">Mar 13, 2018 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/gpu-skinning/">gpu-skinning</a>
    
  

</p>
        </header>

        <div class="post-content">
          <p>최근 급하게 어떤 프로젝트에 투입되서 작업을 하고 있다. 다른 회사와 같이 일을 하고 있는데, 다른 회사에서 해놓은 것들이 너무 느려서 최적화를 해야했다. 결국 일반적인 잔머리로는 도저히 해결할 수 없는 상황에 봉착했다. 1년 전의 필자였다면 포기하고 안된다고 했었겠지만 다행히 약간의 노하우를 통해 해결할 수 있었다.</p>

<h2>상황과 문제?</h2>

<p>요즘 한국에서는 VR 게임/컨텐츠들이 굉장히 많이 개발되고 있다. 필자도 그 와중에 떨어진 프로젝트를 하나 받아진행하게 되었다. 개발은 주변 3D 환경을 다른 회사에서 해주고, 게임이 돌아가는 코어 시스템을 필자의 회사에서 작업하기로 되어 있었다. 게임에서의 코어 시스템은 개발을 하였으나 <em>Unity</em> 에 의존적인 코딩은 거의 진행되지 않은 상태에서 한달전 프로젝트에 투입되었다.</p>

<p>그렇게 하나하나 작업을 하면서 코어 시스템과 3D 환경을 결합하는 도중, 터무니 없는 경우를 만났다. 바로 <strong>SkinnedMeshRenderer</strong> 와 <em>Animator</em> 가 약 800 개 정도되는 상황에 부딫쳤다. 여기서는 두가지의 큰 부하가 있었다. 절대적인 <em>Vertex Skinning</em> 부하와 <em>Animator</em> 가 800개가 한꺼번에 계산되는 부하였다. <em>Vertex</em> 숫자는 <em>LOD</em> 베이커를 구해서 어떻게든 해결이 되었으나, 800개의 <em>Animator</em> 부하는 우회방법이 없었다. 즉 이는 <em>Vertex Shader</em> 나 <em>Compute Shader</em> 안에서 <em>AnimationClip</em> 의 정보들을 처리하는 정공법이 필요했다.</p>

<p>하지만 기한도 얼마 남지않아 급한 와중에 저것들을 직접 코딩할 여유는 없었다. 게다가 처음 건드려보는 부분이라서 헤멜 코스트까지 합하면 굉장히 암울했다. 혹시 오픈소스가 있나 싶어서 생각을 해보았는데 예전에 <em>SkinRenderer</em> 를 직접 구현하면서 찾아본 오픈소스 레포지토리가 하나 있었다.</p>

<h2>Github : <a href="https://github.com/chengkehan/GPUSkinning">GPUSkinning</a></h2>

<p>한 중국인이 개발한 스키닝 툴이다. 이는 두가지의 큰 기능을 담고있다. 하나는 <em>Vertex Shader</em> 에서 <em>Skinning</em> 처리를 해주는 기능과, 하나는 <em>AnimationClip</em> 들을 직접 샘플링해 바이너리 파일로 저장해 GPU 메모리에 텍스쳐의 형태로 올려두어 사용하는 기능이 있다.</p>

<p><em>Compute Shader</em> 나 <em>Vetex Shader</em> 를 사용해 <em>Skinning</em> 을 구현하는 것은 크게 어려운 것은 아니다. <em>Deformation</em>  하지만 제일 시간이 오래걸리는 부분은 <em>AnimationClip</em> 을 가공하는 부분이 제일 오래 걸리는 부분 중 하나다. 해당 레포지토리에는 그 오래걸리는 부분을 만들어 놓았다. 사실 이 부분으로만으로 꽤 큰 가치가 있다. 부가적으로 원하는 <em>bone</em> 의 위치와 회전값을 <strong>Transform</strong> 으로 만들어 <em>Hierarchy</em> 상에서 컨트롤이 가능하다.</p>

<p>조금 불편한 점도 몇가지 있다. 한번에 여러개의 샘플링이 안되고, 에디터에서 필수적으로 지원해야할 멀티 에디팅이 안된다. 후자는 간단히 코드를 수정하면 되지만 전자는 샘플링 과정에서 플레이를 해야되기 때문에 직접 수정하기엔 조금 부담스럽다. <em>Vertex Shader</em> 에 스키닝이 물려있기 때문에 <em>Skinning</em> 을 수정하려면 <em>Shader</em> 부분도 바꿔야하고, <em>LOD</em> 기능도 어설프게 들어있어 조금 애매하다.</p>

<p>더 기능을 생각하자면 IK 나 특정 본을 타겟으로 회전을 시키는 기능이 없다. 이는 <em>mecanim</em> 에서 <em>Humanoid</em> 를 타겟으로 지원하는 기능으로 이 기능까지 만들어 놓았으면 엄청 유용 했을것 같다. 다만 구현이 <em>Vertex Shader</em> 에서 되어서 다른 기능을 끼워넣기는 조금 부담스러운 것으로 생각된다.</p>

<p>굳이 단점을 생각하지 않아도 샘플링 코드와 구현만으로도 충분히 가치있는 레포지토리로 생각된다. <em>ComputeShader</em> 를 사용해서 구현했으면 더 좋았을 것 같다는 생각이 문득든다.</p>

<p>써보면서 이게 본격적으로 쓰려고 만들어진 코드는 아닌 것 같다는 생각이 들었다. 기본적인 캐싱도 안되있어서 약간의 삽질을 했었다.</p>

<p>가장 큰 문제는 <em>AnimationClip</em> 이 많으면 많을수록 에디터, 런타임 로드시에 엄청나게 로딩이 걸린다. 아마 ScriptableObject 에 Serialization 으로 저장한 정보들이 많아서 그런듯 하다. 이는 따로 텍스쳐든 뭐든 Unity 에서 직접 관리하는 리소스로 바꾸어야 겠다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://github.com/chengkehan/GPUSkinning">Github : GPUSkining</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/03/06/dualized-asset-management-of-unity/">Dualized Asset Management Of Unity</a>
          </h1>

          <p class="post-meta">Mar 6, 2018 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>Unity</em> 에서는 모든 사용자의 작업물을 <em>Assets</em> 폴더에 저장한다. 그리고 <em>Assets</em> 폴더안의 파일의 변경이 발생할 시 안의 파일들을 재가공하여 다시 로드한다. 보통 파일의 변경은 <em>assetDatabaseX</em> 바이너리 파일로 들어가게 되며, 스크립트, 바이너리의 변경은 다시 컴파일을 함으로써 현재 변경사항을 프로젝트에 적용시킨다.</p>

<p>이러한 시스템을 위해 <em>Unity</em> 에서는 모든 파일, 디렉토리에 <em>meta</em> 파일을 생성한다. 파일별 <em>meta</em> 파일에는 해당 파일의 순수한 정보가 아닌 메타 정보가 들어간다. 중요한 정보는 두개로 나뉜다.</p>

<p>하나는 <em>Unity</em> 프로젝트상에서 파일을 처음 감지했을 때, 파일의 <em>GUID</em> 를 생성한다. <em>GUID</em> 란 고유의 16진수 32글자로 이루어지는 총 512비트로 이루어지는 <em>ID</em> 로써 자동으로 생성되는 알고리즘을 가지고 있으며 겹칠 염려는 거의 없는 <em>ID</em> 알고리즘이다. 그래서 생성된 <em>GUID</em> 는 다른 곳에서 해당 파일을 참조할떄 쓰인다. 즉 파일이 삭제되서 같은 것으로 다시 생성한다고 해도 <em>GUID</em> 가 랜덤으로 결정되기 때문에 다시 연결을 해주어야 한다. 이는 <em>Unity</em> 내부에서 파일 링크를 <em>GUID</em> 로 한다는 추측을 할 수 있게 해준다. 또한 <em>Edit -&gt; Project Setting -&gt; Editor</em> 에서 <em>Asset Serialization</em> 모드가 <em>Force Text</em> 로 되어있을 시에는 <em>meta</em> 파일들을 직접 텍스트 에디터로 확인이 가능하다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fileFormatVersion: 2
guid: 5d44a238286f6904198ab78e914c229d
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData:
  assetBundleName:
</code></pre></div></div>

<p>어떤 스크립트에 딸린 <em>meta</em> 파일의 내용이다. 두번째 줄에 생성된 <em>guid</em> 가 존재한다. 이는 <em>Library/metadata</em> 디렉토리에 쓰여진 이름들과 매칭된다.</p>

<p>두번째는 바로 해당 파일의 <em>Importer</em> 정보가 들어있다. 위의 <em>meta</em> 파일은 스크립트이기 때문에 3번째 줄에 <em>MonoImporter</em> 라고 쓰여져 있으며, 파일의 성질에 따라서 <em>built-in importer</em> 가 달라진다. 바이너리 파일들은 <em>NativeImporter</em>, 텍스쳐 파일들은 <em>TextureImporter</em>, 3D 모델 파일들은 <em>ModelImporter</em> 로 자동으로 매칭된다.</p>

<p>이러한 <em>Importer</em> 정보들은 보통 해당 <em>Asset</em> 의 옵션을 세팅할 떄 쓰인다. 또한 <em>2017</em> 버젼에서는 파일의 확장자를 사용자가 직접 지정해 <em>Importer</em> 를 사용할 수도 있게 해두었다.(<a href="/2018/01/11/unity-scripted-importer/">링크</a>)</p>

<p>즉 <em>Unity</em> 에서는 새로운 파일을 감지했을 때, <em>GUID</em> 를 생성하고 파일의 확장자에 따라 <em>Importer</em> 정보를 갱신한 후, 정보를 <em>Library/metadata</em> 에 갱신하는 것으로 볼 수 있다. <em>Library/metadata</em> 에서는 <em>GUID</em> 로 된 파일과 (해당 <em>GUID</em>).info 로 파일이 구성되어 있다. 각각의 파일은 파일의 유형별로 다른 것으로 보인다.</p>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/03/04/what-is-ddx-and-ddy/">What Is Ddx And Ddy</a>
          </h1>

          <p class="post-meta">Mar 4, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>HLSL</em> 에는 <em>ddx</em> 와 <em>ddy</em> <em>intrisic</em> 이 <em>Shader Model 2.0</em> 부터 존재했다. 필자는 이를 이해하기 위해 자료를 찾아보았지만 쉽게 이해되는 것들은 거의 없었다. 이해한 것을 정리하기 위해 이글을 쓴다.</p>

<p>예전부터 <em>Pixel Shader</em> 를 처리할 때 픽셀 단위로 하나하나 처리하는게 아닌 적어도 2x2 개의 픽셀들을 한꺼번에 처리했다고 한다. 그래서 이러한 아키텍쳐를 이용한 키워드가 <em>ddx</em> 와 <em>ddy</em> 다. 기본적으로 쉐이더는 병렬로 처리되기 때문에, 4개의 <em>Pixel Shader</em> 가 한꺼번에 실행되는 것으로 생각할 수 있다. 아래 코드를 보면서 생각해보자.</p>

<pre><code class="language-hlsl">    half3 dpdx = ddx(position);
    half3 dpdy = ddy(position);
</code></pre>

<p>4개의 픽셀 쉐이더가 첫번째 라인을 실행할 때 ddx 는 들어온 파라미터의 x축, 가로의 픽셀들의 파라미터의 차이를 구해 반환한다. 이는 <em>δ/δx</em> 의 의미와 같다. 즉 x 를 기준으로 편미분을 한것이라고 한다. 마찬가지로 ddy 는 y축을 기준으로 차이를 계산해 반환하는 키워드로 생각하면 된다.</p>

<p><em>Shader Model 5.0</em> 부터는 <em>ddx_coarse/ddy_coarse</em> 와 <em>ddx_fine/ddy_fine</em> 으로 키워드가 나뉜다. 기존의 <em>ddx/ddy</em> 는 <em>ddx_coarse/ddy_coarse</em> 와 같다고 한다. <em>fine</em> 과 <em>coarse</em> 의 차이는 간단하다. 4개의 픽셀을 기준으로 각각의 차이를 전부 구하는게 <em>fine</em>, 한쪽의 차이만 구하는게 <em>coarse</em> 라고 한다. 자세한 것은 아래 참조에서 보는 것을 추천한다.</p>

<h2>참조</h2>
<ul>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509588.aspx">MSDN HLSL Intrisic : ddx</a></li>
  <li><a href="https://gamedev.stackexchange.com/questions/62648/what-does-ddx-hlsl-actually-do">gamedev.stackexchange.net : What does ddx (hlsl) actually do?</a></li>
  <li><a href="https://fgiesen.wordpress.com/2011/07/10/a-trip-through-the-graphics-pipeline-2011-part-8/#comment-1990">The ryg blog : A trip through the Graphics Pipeline 2011, part 8</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh446950.aspx">MSDN Shader Model Assembly 5.0 : deriv_rtx_fine</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh446948.aspx">MSDN Shader Model Assembly 5.0 : deriv_rtx_coarse </a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/02/19/gpu-branching-and-divergence/">Gpu Branching And Divergence</a>
          </h1>

          <p class="post-meta">Feb 19, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/gpu/">gpu</a>,
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/gpgpu/">gpgpu</a>
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>요즘은 꽤나 많은 것들을 GPU 로 처리할 수 있다. GPGPU 기술이 나온지 10년이 넘어가는 이 시점에서 꽤나 많은 것들이 GPU 로 처리되고 있다. 그 중에서도 GPGPU 를 다뤄볼 사람이라면 필수적인 상식하나가 있다. 아래 그림을 보자.</p>

<p><br />
<img src="/images/prior_simt.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://composter.com.ua/documents/Volta-Architecture-Whitepaper.pdf">NVidia : GV100 Whitepaper</a>
</center>
<p><br /></p>

<p>위 그림은 분기가 나뉘어져 있는 코드를 여러개의 스레드가 실행하는 것을 보여준다. 즉 GPU 에서의 코드 실행 모습이다. 왼쪽은 스레드의 번호로 나뉘는 간단한 분기 코드다. 이는 CPU 에서는 크게 문제가 없다. 하지만 분기가 있던 말던 모든 명령어들을(분기안의 코드들) 전부 실행시키는 것이다. 오른쪽의 그림에서 설명하는 것은 이를 실행하는 쓰레드의 모습을 나타낸다. 딱 봐도 이 그림은 처리가 비효율적일 것처럼 보인다.</p>

<p>CPU 는 한 쓰레드에서 하나의 <em>Program Conter</em> 를 가지기 때문에 분기가 나오면 조건에 맞게 단순히 포인터를 증가시키기만 한다. 하지만 <em>SIMT</em>(<em>Single Instruction Multiple Threads</em>) 의 구조를 가진 GPU 에서의 분기는 조금 다르다. 여태까지는 여러개의 쓰레드를 가진 그룹 하나당 <em>Program Counter</em> 를 가지는게 일반적이였다. 그래서 위와같이 동시에 활성화된 쓰레드들 끼리만 실행하게 되는 것이다.</p>

<p><em>Volta</em> 아키텍쳐에서는 이를 개선시켜 한 <em>Thread</em> 당 하나의 <em>Program Counter</em> 와 <em>Call-Stack</em> 을 두므로써 각 <em>Thread</em> 를 독립적으로 실행시키게 해준다고 한다. <em>SIMT</em> 의 <em>Concurrency</em> 를 고려하여 전부 한꺼번에 실행시키지는 못하지만 각각의 <em>Thread</em> 를 같은 명령별로 그룹지어 실행시키거나, 한번에 실행시키는게 아니라 각 그룹의 실행을 클럭이나 시분할로 쪼개어 실행하는 것들을 지원한다고 한다. 아래 그림을 보자.</p>

<p><br />
<img src="/images/interleaved_execution.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://composter.com.ua/documents/Volta-Architecture-Whitepaper.pdf">NVidia : GV100 Whitepaper</a>
</center>
<p><br /></p>

<p>하지만 이는 그림에서 나와 있다시피 그다지 효율적인 실행은 아니다. 결국 아직은 분기의 사용은 최소화해야될 것으로 보인다. 다만 이 기능들은 <em>Graphic Processing Unit</em> 들이 <em>Accelerator</em> 로 바뀌는 하나의 과정으로 볼 수 있을듯 하다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://composter.com.ua/documents/Volta-Architecture-Whitepaper.pdf">NVidia : GV100 Whitepaper</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/01/14/frustum-traced-shadow-with-irrelgular-z-buffer-2/">Frustum Traced Shadow With Irrelgular Z Buffer 2</a>
          </h1>

          <p class="post-meta">Jan 14, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/fts/">fts</a>
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-1/">frustum Traced Shadow with Irregular Z-Buffer 1</a> 에서 포괄적인 전체 시스템과 복잡도에 대하여 알아보았다. 이번 글에서는 시스템 구현에 관한 디테일한 사항들을 알아볼 것이다.</p>

<p>첫번째로는 <em>Irregular Z-Buffer</em> 와 <em>Sampling Rate</em> 간의 최적화다. 논문의 저자는 기본적으로 <em>32spp</em> (<em>sampling per pixel</em>) 를 제안했다. 정확히 짚자면, <em>Light-Space</em> 에서 <em>Occluder Geometry</em> 를 <em>Conservative Rasterization</em> 을 하면 <em>Visibility Test</em> 를 계산하는 것이, 한번 <em>Visibility Test</em> 를 할때 32번을 하는게 가장 신경쓰이는 부분이다. 이의 결과를 저장하기 위해 두가지 방법이 있다고 한다. 하나는 <em>μQuad</em> 를 <em>Light-Space</em> 에서 <em>IZB</em> 를 만들 떄 <em>Rasterize</em> 하는 것, 다른 방법은 32 번의 <em>Visibility Test</em> 샘플링 결과를 <em>IZB</em> 에 저장하는 것이다. 전자는 비용이 크기 때문에 안쓰고, 후자를 선택했다고 한다. 이를 <em>Sample-based insertion</em> 이라고 명명했다. 그래서 이 방식으로 <em>Prototype</em> 을 만들어 보니, <em>IZB</em> 의 중복을 위한 최적화를 했음에도 불구하고 한 픽셀당 8개 이상의 <em>IZB Node</em> 가 생성되었다고 한다.</p>

<p>그래서 고안해낸 간단한 근사(<em>approximate</em>)하는 방법을 언급한다. <em>μQuad</em> 의 <em>Normal</em> 벡터와 <em>View Ray</em>(<em>Eye Direction</em>) 벡터의 내적 값이 0에 가까워질수록(90도에 가까워질수록) <em>μQuad</em> 를 늘리는 것이다. 아래 그림의 왼쪽 그림을 보면 쉽게 이해할 수 있다.
그래서 고안해낸 간단한 근사(<em>approximate</em>)하는 방법을 언급한다. <em>μQuad</em> 의 <em>Normal</em> 벡터와 <em>View Ray</em>(<em>Eye Direction</em>) 벡터의 내적 값이 0에 가까워질수록(90도에 가까워질수록) <em>μQuad</em> 를 늘리는 것이다. 아래 그림의 왼쪽 그림을 보면 쉽게 이해할 수 있다.</p>

<p><br />
<img src="/images/fts_microquad_elongate.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>보다 정확하게 계산 방법을 설명하자면, <em>μQuad</em> 의 넓이는 표면의 방향과 상관없이 상수로 정해주고 <em>View Ray</em> 의 앞뒤 방향으로 <em>μQuad</em> 의 길이가 늘어나고, 그 방향을 따라서 1줄로 샘플링을 한다. 1차원이라고도 할 수 있겠다. 1 ~ 8 개의 샘플링을 해준다고한다. 위 그림의 오른쪽 그림을 보면 쉽게 이해할 수 있다.</p>

<p>다만 이는 단지 <em>Irregular Z-Buffer</em> 를 <em>Approximate</em>(근사) 하는 것이기 때문에 오차가 생길 수 있다. <em>μQuad</em> 가 커질수록 <em>IZB Node</em> 를 넣는 것을 놓치고, <em>Light Leak</em> 을 발생시킬 수 있다. 보통 가리는 물체가 작거나, 멀리있는 경우에 해당된다. <em>Light Leak</em> 을 없에는 방법은 몇가지가 존재하는데, 가장 쉬운 방법은 <em>IZB</em> 의 기본적인 모토인 1:1 샘플링을 맞춰주는 것이다. 하지만 이는 정확히 해주기에 어려운 경우가 있다고 한다. 그래서 다른 방법을 제시한다. <em>Conservative Rasterization</em> 은 보통 결과에서 0.5 픽셀을 늘려준다. 하지만 1 픽셀 팽창(<em>dilation</em>)을 해주는 <em>Conservative Rasterization</em> 을 사용하면 <em>Light Leak</em> 을 막을 수 있다. 원래 <em>μQuad</em> 2차원으로 샘플링을 했었으나 기준을 1차원으로 줄이면서 각각의 폴리곤의 넓이을 늘리는 방식으로 보완한 것이라고 생각하면 되겠다. 아래 그림에 적용을 한 사례가 있다.</p>

<p><br />
<img src="/images/fts_approx-insert_vs_over-conserv-raster.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>이전 글에서 언급한 복잡도는 O(<em>La</em> * <em>F</em>) 이다. 우선 평균적인 리스트의 길이는 줄어든다고 한다. 샘플링을 하는 횟수가 최소 1/4 정도 줄었기 때문이다.(8 / 32) 그리고 더 넓은 <em>Conservative Rasterization</em> 의 결과로 <em>Fragment</em> 의 갯수는 최대 60% 증가했다고 한다. 이는 성능상 엄청난 이득을 가져온다.</p>

<p>하지만 이 방법은 <em>Approximate</em> 하는 방법이란 것을 알아야 한다. 아주 극성맞은 경우와 안좋은 파라미터 설정에는 <em>Light Leak</em> 이 발생할 수 있다고 한다. 아래 그림에서 그 경우를 볼 수 있다.</p>

<p><br />
<img src="/images/fts_lightleaks.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>왼쪽의 그림은 정상적으로 그림자가 보일 때, 두번째는 정말 안좋은 경우들이 겹친 <em>Light Leak</em> 이 발생하는 경우, 세번째 경우는 세팅값을 맞춰주어 <em>Light Leak</em> 을 없엔 장면이다. 하지만 결과를 잘 모르는 경우에는 이 결과들이 맞는지 아닌지 쉽게 구별할 수 있는 정도는 아니다. 즉 아주 정확한 결과를 원하는게 아니라면 그냥 써도 된다는 말이다.</p>

<p>두번째는 데이터 구조와 메모리 레이아웃 최적화다. 가장 맨처음 이를 구현할 때는 링크드 리스트의 2D 그리드의 형태로 만들었다고 한다. 각각의 리스트의 노드는 다음노드를 가리키는 포인터와 <em>G-Buffer</em> 를 참조하기 위한 명시적인<sup id="fnref:C2"><a href="#fn:C2" class="footnote">1</a></sup> 인덱스로 구성되었다고 한다. 하지만 이 구조는 <em>GPU</em> 에서의 두가지 쓰레드 동기화를 필요로 했다. 하나는 <em>Global Node Pool</em> 에서 비어있는 노드를 찾기위한 <em>Global</em> 동기화<sup id="fnref:C1"><a href="#fn:C1" class="footnote">2</a></sup>, 나머지는 헤드 포인터(<em>Light-Space Data</em>)를 업데이트하기 위한 <em>Per-Texel</em> 동기화<sup id="fnref:C1:1"><a href="#fn:C1" class="footnote">2</a></sup>였다. 동기화를 많이 걸면 걸수록 성능상으로는 그다지 좋지않다. 그렇기 때문에 데이터 구조를 바꾸었다고 한다.</p>

<p>여러 시도 끝에 가장 성공적인 결과는 리스트의 각 노드의 크기를 줄이는 것이였다. 이를 위한 준비는 노드를 저장하기 위한 <em>Screen-Space Grid</em> 버퍼를 미리 할당한다. 그리고 각 노드들은 자신을 기준으로한 다음 노드의 오프셋을 저장한다. 이는 <em>Linked-List</em> 의 기준으로 보자면 <em>Next Pointer</em> 가 된다. 이를 논문에서는 간접적인(<em>Implcit</em>) <em>G-Buffer</em> 인덱스라고 부른다. 이렇게 계속 픽셀의 노드 정보를 참조하면서 픽셀의 위치를 <em>Linked-List</em> 의 형태로 나타낼 수 있는 것이다. 아래 중간의 그림의 노란색 화살표는 이를 간단하게 나타냈다.</p>

<p><br />
<img src="/images/fts_SimpleLayout.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>이는 <em>IZB Node</em> 의 크기도 반으로 줄이고, 위에서 언급한 두가지의 동기화 중 <em>Global</em> 동기화를 안할 수 있게 되었다. 32spp 그림자를 보여주기 위해서는 적어도 픽셀별로 8개의 노드가 필요했다. 이렇게 반으로 노드의 크기를 줄임으로써 큰 퍼포먼스 향상을 얻게 되었다.</p>

<p>세번째는 헤드 포인터를 가지고 있는 <em>Light-Space Buffer</em> 의 해상도다. 일반적인 <em>Shadow Mapping</em> 기법의 <em>Shadow Map</em> 의 해상도는 보여지는 정도를 결정하지만, 여기서의 해상도는 퍼포먼스를 결정한다.(<em>La</em>) 1920 x 1080 을 기준으로 추천하는 해상도는 1400 ~ 2500 사이라고 한다.</p>

<p>네번째로는 기존의 <em>Shadow Mapping</em> 의 잘 알려진 기법인 <em>Cascaded Shadow Mapping</em><sup id="fnref:P1"><a href="#fn:P1" class="footnote">3</a></sup> 을 이 기법에 적용시키는 것이다. 이 기법의 원리는 <em>View frustum</em> 을 원하는 갯수대로 쪼갠 후, 쪼개진 <em>frustum</em> 안의 오브젝트들의 <em>Shadow</em> 를 계산한다. 논문에서 쪼개는 방법은 <em>Sample Distribution Shadow Map</em> 과 <em>Logarithm Partitioning</em> 을 언급했다. 여기서는 쪼개진 <em>frustum</em> 마다 전부 <em>IZB</em> 를 생성한다. 이때 각각의 쪼개진 <em>frustum</em> 의 끝부분이 잘 맞도록 신경써야줘야 한다고 언급했다. 논문의 저자는 구현할때 <em>2D Texture Array</em> 를 사용하여 <em>IZB</em> 를 저장하고, 병렬로 각각의 <em>Detph Texture</em> 마다 <em>Light-Space Culling Prepass</em> 를 넣어줬다고 한다. 일반적으로 각각의 <em>Cascade</em> 를 계산할때는 한개당 하나의 <em>Pass</em> 를 사용하여 계산하는데, 여기서는 1 Pass 로 적절히 프리미티브를 나누어 성능 향상을 고려했다고 한다.</p>

<p><em>Cascade</em> 의 적용은 <em>Occluder Geometry</em> 의 <em>Rasterize</em> 퍼포먼스를 안고 가면서 <em>Thread Divergence</em> 의 시간을 줄여준다. 이는 사용시 적절한 타협점을 찾아야 한다는 뜻으로, 보통은 두개의 <em>Cascade</em> 를 사용하고, 복잡한 게임에서는 3개나 4개의 <em>Cascade</em> 를 사용하여 상황에 따라 뜀뛰는 시간을 최소화 시킨다. 아래 그림은 <em>Cascade</em> 의 효과를 증명해준다.</p>

<p><br />
<img src="/images/fts_cascaded-izb.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>다섯번째로는 <em>N dot L Culling</em> 이다. 일반적으로 <em>N dot L</em> 의 값이 음수가 되는 경우에는 0으로 클램핑하여 사용한다. 이 말은 값이 음수나 0 인 경우에는 무조건 <em>Shadow</em> 가 비춘다는 말이다. 이때는 <em>La</em> : 평균적인 <em>IZB</em> 리스트의 길이를 줄여 성능 향상을 해줄 수 있다고 한다. 보통은 10 ~ 15% 의 성능향상을 해준다고 한다.</p>

<p>여섯번째로는 <em>Early-Z</em> 의 개념을 응용한 <em>Early-Out</em> 이다. <em>Visibility Test</em> 에서 한 픽셀을 완전하게 그림자를 드리우는 경우, 다음 후속으로 같은 픽셀에 <em>Node</em> 가 추가될 필요가 없다. 그러므로 완전히 그림자 처리가 되는 부분은 <em>Node</em> 를 지워준다. 이때 <em>atomic</em> 연산을 사용하지 않는데, 최악에 경우에는 <em>Visibility Test</em> 를 다시할 수도 있다. <em>Early-Out</em> 은 추가적인 시간과 메모리를 요구함에도 불구하고 10 ~ 15% 의 성능향상을 보인다.</p>

<p>일곱번째로는 <em>Unchanged Mask</em> 를 이용한 메모리 동기화다. <em>Visibility Test</em> 는 메모리 대역폭, 처리량, 동기화로 인하여 병목이 일어난다. 픽셀 각각의 <em>Visibility Mask</em> 를 사용해 동기화를 한다. 정확히 말하면 각각의 폴리곤들이 픽셀의 가시성을 테스트 할때 <em>Race Condition</em> 을 피하기 위하여 동기화를 하여 <em>Visibility</em> 를 기록한다. 그러므로 <em>Visibility Mask</em> 는 반드시 폴리곤이 기존의 <em>Visibility</em> 를 바꿀 때만 업데이트된다. 바뀌는지 비교를 하기위해 이전에 사용한 마스크를 써야하지만, 이는 최고 14% 의 성능 향상을 보여준다고 한다.</p>

<p>마지막으로는 코드를 통한 <em>Latency Hiding</em> 이다. 단계가 복잡하여 <em>Memory Latency</em> 가 꽤나 긴편인데, GPU 에서는 이 <em>Latency</em> 를 감출 방법이 없다. 다행히 사전에 루프를 돌면서 <em>G-Buffer</em> 좌표를 계산하여 <em>Latency Hiding</em> 이 가능하다고 한다. 이는 5 ~ 15% 성능 향상을 보였다고 한다.</p>

<p>시스템 구현에 대한 디테일한 사항은 여기까지가 끝이다.</p>

<p>마지막으로 <em>Transparency Geometry</em> 를 처리하는 방법에 대해서 써보겠다. 이 기법의 <em>per-pixel</em> 테스트는 <em>Visibility Mask Buffer</em> 에 결과가 저장된다. <em>Visibility Mask Buffer</em> 의 효율적인 사용을 위해 항상 각 픽셀의 여러개의 32bit 데이터를 저장해준다고 한다. 이정도의 크기라면 단지 <em>Visibility</em> 만을 사용하는게 아니라 <em>Opacity</em> 또한 저장이 가능하다. 통상적인 가시성을 위한 투명 오브젝트의 처리 방법은 <em>Alpha to Coverage</em><sup id="fnref:C3"><a href="#fn:C3" class="footnote">4</a></sup> 를 쓴다고 한다. 그리고 여기에서도 비슷한 방법을 사용할 수 있다고한다.</p>

<p>처음에는 <em>Coverage</em> 를 계산하기 위해 <em>Visibility Test</em> 를 해준다. 그리고 해당 알파가 저장된 텍스쳐를 참조하여 투명도를 가져오고, 해당 투명도를 사용하여 <em>Alpha to Coverage</em> 를 실행하여 투명도 마스크를 얻는다. 이를 비트 AND 연산으로 합쳐서 <em>Coverage</em> 를 <em>Visibility Buffer</em> 에 저장한다.</p>

<p>이 기법에서 알파 데이터를 처리하는 방법은 두가지로 나뉜다. 적은 비용으로 <em>Aliasing</em> 을 생기게 하는 방법과 높은 비용으로 완벽하게 구현하는 방법으로 나뉜다. 적은 비용의 방식은 <em>Alpha</em> 텍스쳐의 값을 <em>IZB Node</em> 를 순회하기 전에 가져와서 계산하는 방식이다. <em>Light-Space Texel</em> 을 기준으로 계산하므로 <em>Aliasing</em> 이 생길 것으롸 예상된다. 하지만 이 논문의 저자는 구현물을 이 방식으로 구현했다고 한다. 나머지 한개의 방식은 <em>IZB Node</em> 를 하나하나 순회하면서 <em>Alpha</em> 텍스쳐의 값을 가져와 계산하는 것이다. 이는 일반적으로 생각되는 텍스쳐 샘플링의 부하와 <em>Varing</em> 부하를 생기게 한다. 이는 꽤나 큰 비용이라고 한다.</p>

<p>여기까지가 끝이다. 논문에 그 다음 내용들은 전부 퍼포먼스들의 분석밖에 없다. 다음으로 쓸 내용은 <em>HFTS</em> 에 대한 내용이다.</p>

<h2>참조</h2>
<ul>
  <li><a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a></li>
  <li><a href="https://software.intel.com/en-us/articles/sample-distribution-shadow-maps">Intel Developer Zone : Sample Distribution Shadow Maps</a></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:C2">
      <p>명시적이란 뜻은 바로 넣어서 계산할 수 있는 절대적인 위치의 텍셀 인덱스를 뜻한다. <a href="#fnref:C2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:C1">
      <p>여기서의 동기화는 <em>atomic</em> 의 개념을 말한다. 성능상의 단점은 다른 쓰레드에서 선점하는 경우에는 기다리는 것이다. <a href="#fnref:C1" class="reversefootnote">&#8617;</a> <a href="#fnref:C1:1" class="reversefootnote">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:P1">
      <p>이 블로그에서 <em>Cascaded Shadow Mapping</em> 에 대한 내용을 다루었었다. <a href="/2017/12/17/cascaded-shadow-mapping/">여기</a>에서 볼 수 있다. <a href="#fnref:P1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:C3">
      <p><a href="https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f</a> <a href="#fnref:C3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-1/">Frustum Traced Shadow With Irrelgular Z Buffer 1</a>
          </h1>

          <p class="post-meta">Jan 13, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/fts/">fts</a>
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-0/">frustum Traced Shadow with Irregular Z-Buffer 0</a> 에서 기법의 아이디어를 둘러봄으러써 대강 이 알고리즘이 무엇인지 살펴보았다. 이번 글에서는 논문에 수록된 포괄적인 전체 시스템과 복잡도에 대하여 알아볼 것이다.</p>

<h3>전체 시스템</h3>

<p><a href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-0/">이전 글</a>에서 두가지 단계에 대해서 자세한 설명을 했었다. <em>Irregular Z-Buffer</em> 를 생성하고 <em>Visibility Test</em> 를 하는 것이였다. 실제 구현된 단계는 총 6개의 단계로 이루어진다고 한다.</p>

<p>첫번째로는 <em>Eye-Space Z-Prepass</em> 를 해준다. 요즘의 엔진들이나 큰 규모가 아닌 게임이더라도 <em>Z-Prepass</em><sup id="fnref:L1"><a href="#fn:L1" class="footnote">1</a></sup> 는 거의 대부분 해준다. <em>Geometry Pass</em> 가 두번 걸리기는 하지만 <em>Fill Rate</em> 의 부하가 <em>Geometry Pass</em> 의 부하보다 많이 커서 그런 듯하다. 중요한건 단순히 언급한 <em>Eye-Space Z-Prepass</em> 를 뜻하는게 아니다. 이전에 언급한 <em>μQuad</em> 의 빠른 계산을 위해 <em>G-Buffer</em> 에 3개의 실수 값들을 넣는다. 이 3개의 실수는 실제 그려지는 카메라의 위치와 <em>Tangent Plane</em> 의 4개의 코너중에 3개의 거리를 나타낸다. 이는 <em>μQuad</em> 를 다시 계산하기에 충분하다고 한다.</p>

<p>이 방법은 <em>Visibility Test</em> 의 속도를 빠르게 하는데 도움이 되지만, 당연히 <em>G-Buffer</em> 의 공간이 부족한 경우에는 쓰지 못한다. AAA 급의 게임들은 <em>G-Buffer</em> 를 bit 단위로 최대한 아껴쓰기 경우가 많기 때문에 이와 같은 상황이 일어날 수도 있다. 이런 경우에는 명시적으로 <em>Visibility Test</em> 를 할때 <em>μQuad</em> 를 계산한다고 한다. 아래 그림은 2009년에 발매된 <em>KillZone 2</em> 의 <em>G-Buffer</em> 사용을 나타내는 PT의 한 부분이다.</p>

<p><br />
<img src="/images/killzone2_g-buffer.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://www.slideshare.net/guerrillagames/deferred-rendering-in-killzone-2-9691589">Deferred Rendering in Killzone 2</a>
</center>
<p><br /></p>

<p>두번째로는 씬의 경계를 설정해주는 것이다. <em>Shadow Mapping</em> 에서 <em>Light-Space Projection</em> 행렬은 씬에 딱 맞게 해주어야 한다.<sup id="fnref:C1"><a href="#fn:C1" class="footnote">2</a></sup> 딱 맞지 않는 경우에는 <em>IZB</em> 에 쓸모없는 텍셀을 생기게 하기 때문이다. 그래서 <em>Light-Space Projection</em> 행렬을 계산하기 위해 <em>Compute Shader</em> 와 <em>Z-Buffer</em> 를 사용하여 <em>Bounding Box</em> 를 계산한다. 이 계산은 화면의 해상도에 따라서 달라진다. 하지만 논문의 저자는 이 비용이 병목의 큰 원인이 아니기 때문에 특별한 해결 방법을 제시하지는 않는다.</p>

<p>세번째는 <em>Irregular Z-Buffer</em> 를 만드는 것이다. 이전 글에서 <em>IZB</em> 에 대한 대략적인 아이디어는 언급했었다. 더 디테일하게 이를 말해보면, 우선 <em>Eye-Space Z Buffer</em> 를 참조해 <em>Light-Space</em> 로 변환한 후에 <em>Light-Space A-Buffer</em> 의 텍셀의 <em>Linked-List</em> 에 넣는다.</p>

<p><em>IZB</em> 의 발상은 <em>Eye-Space</em> 의 픽셀과 <em>Light-Space</em> 의 텍셀이 1:1 로 매칭되지 않고 하나의 텍셀이 참조당하는 횟수가 1을 넘을때 <em>allasing</em> 이 발생하는 것에서 시작되었다. 그래서 여기서 구현된 <em>IZB</em> 는 텍셀에 <em>Linked-List</em> 의 개념을 도입하여 보다 정확히 계산할 수 있게 하였다.</p>

<p>아래 그림은 <em>IZB</em> 의 데이터를 나타낸다.</p>

<p><br />
<img src="/images/fts_depth_length_cull.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>왼쪽의 그림은 일반적인 <em>Shadow Map</em> 을 나타내고, 중간의 그림은 <em>Linked-List</em> 의 크기를 나타낸다. 흰색은 <em>Linked-List</em> 의 크기가 0인 텍셀을 나타내고, 검은색에 가까워질수록 <em>Linked-List</em> 의 크기가 점점 커지는 것을 나타낸다. 오른쪽의 그림은 필요없는 부분을 0으로 나타내고, 나머지 부분은 0 이상의 숫자를 나타내는 방식이다. 이는 아래에서 언급할 <em>Light-Space Culling Prepass</em> 에서 쓰인다.</p>

<p>픽셀별로 여러개의 가시성(가려진 정도)를 나타내는 픽셀은 여러개의 <em>IZB Node</em> 를 필요로 한다. 일반적인 <em>Shadow Map</em> 과는 다르게 <em>μQuad</em> 는 다른 <em>Light-Space Texel</em> 에 <em>Projection</em> 이 가능하다.</p>

<p>대충 생각해보면, <em>N</em> 개의 픽셀별 쉐도우가 필요하면, <em>N</em> 개의 <em>IZB Node</em> 가 필요하다. 하지만 쓸데없는 데이터를(<em>Geometry</em> 가 없는 경우) 넣지 않을 수 있으므로 <em>M</em> 개의 <em>Light-Space Texel</em> 에 <em>μQuad</em> 를 투영한다면, 우리는 min(<em>N</em>, <em>M</em>)개의 <em>IZB Node</em> 가 필요하다고 알 수 있다.</p>

<p>아래 그림은 <em>IZB</em> 를 사용하는 디테일한 구조를 나타낸다.</p>

<p><br />
<img src="/images/fts_SimpleLayout.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p><em>IZB</em> 의 데이터 구조는 <em>Light-Space A-Buffer</em> : <em>Eye-Space A-Buffer</em> 의 <em>Node</em> 를 찾아가기 위한 데이터, <em>Eye-Space A-Buffer</em> : 리스트의 크기를 나타내는 버퍼와 같다. 출력되는 결과 : <em>Visibility Buffer</em> 또한 따로 존재한다. 이게 최종적으로 그려질때 사용된다.</p>

<p>다음은 <em>Light-Space Culling Prepass</em> 다. <em>Visibility Test</em> 를 위해 <em>Geometry</em> 의 <em>Light-Space Conservative Rasterization</em> 을 하게 되는데, GPU 에서 <em>Early-Z</em> 기능을 제공한다면 쓸데없는 부분(아무것도 없는 텍셀, 가장 끝)을 컬링할 수 있다.</p>

<p>하지만 <em>Early-Z</em> 하드웨어를 사용할때는 <em>Light-Space Z-Buffer</em> 를 필요로 한다. 이는 조금 당황스러운 상황을 만든다. 그래서 이 단계에서는 반드시 스텐실 버퍼를 만들어야 한다. 위에서 언급한 쓸데없는 부분(아무것도 없는 텍셀, 가장 끝)의 <em>Depth</em> 를 0으로 세팅한다. 나머지는 0 이상의 숫자로 세팅한다.</p>

<p>논문의 저자에 따르면, 엄청 큰 씬을 제외하고는 30% ~ 50% 의 성능 향상을 보였다고 한다. 이는 <em>Conservative Rasterization</em> 으로 생성된 <em>Fragment</em> 의 절대적인 숫자를 줄이고, 아무것도 없는 리스트를 스킵하면서 길이의 다양성을 없엔 효과다.</p>

<p>컬링을 된 이후에는 픽셀별로 <em>Visibility Test</em> 를 해준다. 이때 각각의 폴리곤들은 임의의 텍셀 집합을 가리기 된다. 그리고 각각의 텍셀이 가진 리스트를 순회하면서 <em>Visibility Test</em> 를 한다. 이때 <em>atomic OR</em> 을 사용하여 <em>Visibility Buffer</em> 에 기록한다. 여기서 가장 병목이 되는 구간은 각각의 폴리곤이 임의의 서로다른 길이를 가진 텍셀의 리스트를 커버링하여 각각의 쓰레드별로 실행되는 시간이 제각각이 된다. 문제는 시간이 제각각인 경우, 가장 느린 시간을 소모한 쓰레드를 기준으로 <em>divergence</em> 하여 각각의 텍셀의 리스트의 길이 중 가장 긴 길이의 시간으로 맞춰진다. 이는 최악의 상황을 유발할 수 있다.</p>

<p>마지막으로 <em>Visibility Buffer</em> 를 사용하여 실제 오브젝트들을 렌더링하면 된다.</p>

<h3>복잡도 계산</h3>

<p>위에서도 언급햇다시피 이 기법은 <em>N</em> 번의 <em>Visibility Test</em> 한다면, 시간 복잡도는 O(<em>N</em>) 과 같다. 여기서 <em>N</em> 을 분해하면 다음과 같다. O(<em>La</em> * <em>F</em>), <em>F</em> 는 <em>Light-Space</em> 의 <em>Fragment</em> 갯수이고, <em>La</em> 는 <em>Linked-List</em> 의 평균 길이다.</p>

<p><em>La</em> 또한 다른 요소로 나타낼 수 있다. <em>Visibility Test</em> 는 <em>Eye-Space</em> 에서 한다. 그래서 <em>IZB Node</em> 의 갯수는 <em>Eye-Space</em> 의 해상도에 비례한다. 그리고 <em>Eye-Space</em> 의 데이터는 전부 <em>Light-Space</em> 에 기록되므로 <em>La</em> ≈ (<em>Eye-Space Resolution</em>) / (<em>Light-Space Resolution</em>) 으로 계산될 수 있다.</p>

<p>하지만 위에서 언급했던 것과 같이 <em>SIMT</em> 기반의 GPU 에서는 O(<em>La</em> * <em>F</em>) 가 아닌 O(<em>Lm</em> * <em>F</em>) 이 될 수 밖에 없다. <em>Lm</em> 은 <em>Linked-List</em> 의 최대 길이다. 결국 퍼포먼스를 내기 위해선 <em>Lm</em> 의 길이를 줄이는 것이 가장 중요하다는 것이 된다.</p>

<p>이번 글에서는 전체 시스템과 복잡도에 대해서 알아보았다. 다음은 더 디테일한 구현 부분의 내용을과 <em>Alpha</em> 처리에 대한 부분을 알아볼것이다.</p>

<h2>참조</h2>
<ul>
  <li><a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:L1">
      <p>https://ypchoi.gitbooks.io/rendering-techniques/content/z_prepass.html <a href="#fnref:L1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:C1">
      <p>Cascaded Shadow Map 의 Crop Matrix 를 떠올리면 된다. <a href="#fnref:C1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-0/">Frustum Traced Shadow With Irrelgular Z Buffer 0</a>
          </h1>

          <p class="post-meta">Jan 13, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/fts/">fts</a>
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/12/27/percentage-closer-soft-shadows/">Percentage-Closer Filtering Shadows</a> 에서 <em>PCF</em> 를 응용한 <em>PCSS</em> 라는 <em>Soft Shadow</em> 를 나타내는 기법에 대해서 알아보았다. 이번 글에서는 여태까지 알아본 것들에 비해 굉장히 최근에 나온 기법인 <em>frustum-Traced Shadow</em> 에 대해서 알아볼것이다.</p>

<p>해당 기법은 2015년에 <em>Siggraph</em>, <em>Interactive 3D</em> 같은 컨퍼런스에서 발표되었으며, 현재 <em>Tom Clansy’s the Division</em> 에 <em>PCSS</em> 와 혼합된 형태(<em>Hybrid frustum Traced Shadow</em>)로 적용되어 있다. <em>Frame Rate</em> 에 조금 영향을 미쳐 대부분의 게이머들은 아직은 <em>HFTS</em> 를 사용하지 않는듯 하다.(<a href="https://www.reddit.com/r/nvidia/comments/49idz3/nvidia_hfts_the_division/">Reddit : Nvidia HFTS (The Division)</a>) 하지만 컴퓨팅 파워가 늘어나는 것을 가정한다면 앞으로 하이엔드 게임의 주 옵션이 될수도 있겠다.</p>

<p>이 기법의 저자는 <em>Shadow Map</em> 처럼 따로 붙은 기법없이 <em>Aliasing</em> 이 없어야 했으며, 현세대의 GPU 와 해상도를 <em>Interactive</em> 하게 지원하는 것이 완벽한 <em>Hard Shadow</em> 를 목표로 <em>FTS</em> 를 고안했다. 가장 많이 쓰이는 <em>Shadow Map</em> 기법은 공간적(<em>Light-Space</em> 와 <em>Clipping-Space</em> 의 <em>Discretize</em> 된 결과의 차이), 일시적인(필터링이 필요한 <em>Aliasing</em>)인 문제들이 산재한다. 이는 이 기법을 고안한 시발점이였다.</p>

<p><em>FTS</em> 의 이론적인 뿌리를 정하기 위해 저자는 여태까지 존재하는 여러 기법을 언급한다. 빛을 하나의 직선단위로 시뮬레이팅 하는 <em>Ray-Tracing</em>, 볼륨을 통한 각각의 폴리곤들을 테스트 하는 <em>Shadow Volume</em>, <em>Irregular Z-Buffers</em> 를 언급했다.</p>

<p><em>Shadow Volume</em> 은 3차원상으로 <em>Shadow</em> 가 생기는 부분을 정해 그 부분을 테스트해서 <em>Shadow</em> 를 정해주는 기법이다. 이는 <em>Shadow Map</em> 보다 픽셀 단위로 처리할 수 있지만, 여러 단점이 있다고 한다. 한번에 해결되는 깔끔한 방법이 없으며, 보이지 않는 부분도 처리하기 때문에 <em>Fill-Rate</em> 를 많이 소모한다. 게다가 처리 자체가 간단하지 않기 때문에 개발자들도 많이 쓰는 기법이 아니라고 한다. 필자도 <em>Shadow Map</em> 에 대한 자료는 굉장히 많이 봤지만 <em>Shadow Volume</em> 은 거의 본적이 없다.</p>

<p><br /></p>

<p><img src="/images/NVidia_ShadowVolume.jpg" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch09.html">GPU Gems : Efficient Shadow Volume Rendering</a>
</center>
<p><br /></p>

<p><em>Ray-Tracing</em> 은 빛을 직선 단위로 시뮬레이팅을 하는 기법으로, 계산 비용 자체가 비싸기 때문에 하드웨어와 구조에 굉장히 의존적이라고 한다. 게임에서도 쓰일 수 있는 기법이 있었지만 다른 후보에 밀려났다. 바로 <em>Irregular Z-Buffer</em> 다. 현대 GPU 의 <em>Geometry</em> -&gt; <em>Rasterize</em> 구조에 맞춰 가장 걸맞는 방법이라고 한다. 자세한 설명은 아래에서 보자.</p>

<h3>Key Idea</h3>

<p>이 기법의 중요한 아이디어는 앞에서 소개한 <em>Irregular Z-Buffer</em> 와 <em>frustum-Triangle Test</em> 이 두가지다. <em>Irregular Z-Buffer</em> 는 앞서 <em>Shadow Map</em> 의 단점중에 공간적 괴리를 해결하는 데이터 구조이고, <em>frustum-Triangle Test</em> 는 논문에서 한 말을 이용하면 <em>Sub-Pixel Accurate Pixel</em> 을 구성하기 위한 시뮬레이션 테스트다. 이 두가지를 간단하게 살펴보자.</p>

<p>첫번째로는 바로 위에서 언급했던 <em>Irregular Z-Buffer</em> 다. 여기서의 <em>IZB</em> 는 우리가 알던 일반적인 <em>Buffer</em> 의 쓰임새와는 조금 다르게 쓰인다. 이 기법에서의 <em>IZB</em> 는 일반적인 <em>Shadow Map</em> 에서의 <em>Eye-Space</em> 와 <em>Light-Space</em> 의 괴리를 없에기 위해 <em>Light-Space</em> 를 기준으로 <em>Depth</em> 를 쭉 저장하는게 아닌, <em>Eye-Space</em> 의 각각 픽셀별로 표현하는 물체에 영향을 미치는 광원을 방향으로 <em>Ray</em> 를 쏜다. 그리고 <em>Light-Space</em> 를 기준으로 만든 <em>Grid</em> 버퍼에 <em>Ray</em> 가 부딫치고, 부딫친 부분에서 가장 가까운 텍셀에 데이터를 저장한다. 위에서 설명한 <em>IZB</em> 를 구성하는 방법에 대한 그림이 아래에 있다.</p>

<p><br />
<img src="/images/fts_IZB.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>간단하게 이런식으로 <em>IZB</em> 가 구성되는 것을 알 수 있다. 이제 <em>Geometry</em> 와 비교하는 <em>Visibility Test</em> 가 필요하다. 일반적인 <em>Shadow Mapping</em> 의 <em>Visibility Test</em> 와는 조금 다르다. 기존의 <em>Shadow Mapping</em> 은 정점을 <em>Light-Space</em> 로 바꾸어 <em>Z</em> 값을 비교하여 <em>Visibility Test</em> 를 한다. 하지만 이 기법에서의 <em>Visibility Test</em> 는 다르다. 위에서 언급한 것과 같이 <em>IZB</em> 를 만든다. 그 다음 <em>Occlluder Geometry</em> 들을 <em>Light-Space</em> 를 기준으로 <em>Conservative Rasterization</em> 을 해준다.<sup id="fnref:C1"><a href="#fn:C1" class="footnote">1</a></sup> 그렇게 나온 결과를 통해 <em>IZB</em> 와 함께 <em>Visibility Test</em> 를 한다. <em>Conservative Rasterization</em> 의 결과는 거의 <em>Flag</em> 로 사용될것으로 예측되고, <em>Eye-Space</em> 픽셀의 그림자 계산은 복잡한 계산을 통해 구한다. 아래는 논문에 있던 <em>IZB</em> 를 기준으로 쓰여진 수도 코드다.</p>

<p><br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Step 1: Identify pixel locations we need to shadow
G(x, y) ← RenderGBufferFromEye()

// Step 2: Add pixels to our light-space IZB data structure
for pixel p ∈ G(x, y) do
    lsTexelp ← ShadowMapXform[ GetEyeSpacePos( p ) ]
    izbNodep ← CreateIZBNode[ p ]
    AddNodeToLightSpaceList[ lsTexelp, izbNodep ]
end for

// Step 3: Test each triangle with pixels in lists it covers
for tri t ∈ SceneTriangles do
    for frag f ∈ ConservateLightSpaceRaster( t ) do
        lsTexelf ← FragmentLocationInRasterGrid[ f ]
        for node n ∈ IZBNodeList( lsTexelf ) do
            p ← GetEyeSpacePixel( n )
            visMask[p] = visMask[p] | TestVisibility[ p, t ]
        end for
    end for
end for
</code></pre></div></div>

<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>다음은 <em>Visibility Test</em> 다. 논문에서는 <em>frustum-Triangle Test</em> 라고 부르는데, 이는 조금 복잡한 과정으로 구성된다. 아래 그림을 보면서 알아보자.</p>

<p><br />
<img src="/images/fts_VisibilityTest.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>가장 처음에는 <em>μQuad</em> 라는 것을 생성한다. <em>μQuad</em> 는 <em>Tangent-Space</em> 를 기준으로 설정하며 각 픽셀별로 생성한다. 위 그림에서는 중간 그림에 구 위에있는 평면을 뜻한다. 그 다음 가리는 <em>Geometry</em> 의 폴리곤들의 각각의 <em>Edge</em> 를 사용하여 <em>Shadow Plane</em> 을 생성한다. 마지막으로 만들어진 <em>Shadow Plane</em> 을 <em>μQuad</em> 에 <em>Projection</em> 한다. 이때 가지고 있던 <em>LUT</em> 를 통해 가려짐을 계산한다. 그리고 다른 <em>Edge</em> 들도 계속해서 누적시킨다.</p>

<p>간단하게 <em>frustum-Triangle Test</em> 의 단계에 대해 설명해보았다. 이제 각각의 과정 : <em>μQuad Construction</em>, <em>Shadow Plane Construction</em>, <em>Visibility Computation</em> 에 대해 조금 더 자세히 써보겠다.</p>

<p><em>μQuad</em> 의 생성은 <em>Geometry</em> 의 <em>Tangent-Space</em> 를 기준으로 계산되는 것 빼고는 특이한 점이 없다. 하지만 생성되는 시기에 대해선 조금 특별한게 있다. 가시성을 계산할 때 생성할 수도 있지만 <em>G-Buffer</em> 를 생성할 때 미리 계산하는 것이 더 효율적이라고 한다.</p>

<p>가시성을 계산할 때 <em>ray-triangle intersection</em> 을 계산하기 보다는 앖에서 언급한 각각의 폴리곤의 <em>Shadow Volume</em> 을 각 점마다 계산한다고 한다. <em>Shadow Volume</em> 은 그림자를 생성하는 <em>Occluder Triangle</em> 을 기준으로 각각의 <em>Edge</em> 에서 뻗어나오는 직사각형 면으로 구성된다. 아래 그림을 보면 쉽게 이해할 수 있다. 그리고 <em>μQuad</em> 에서 샘플링한 각각의 점들을 기준으로 가시성을 계산한다면 한다면, 4번의 내적으로 가시성을 테스트할 수 있다는 것을 의미한다.</p>

<p><br />
<img src="/images/HFTS_frustumTracing.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/gameworks/events/  GDC2016/jstory_hfts.pdf">NVidia : Advanced Geometrically Correct Shadows for Modern Game Engines</a>
</center>
<p><br /></p>

<p>또한 그림자를 멀티샘플링 하기 위해서는 여기서 언급한 <em>Shadow Volume</em> 의 <em>Shadow Plane</em> 들을 이용한다고 한다.</p>

<p>마지막으로 <em>Visibility Computation</em> 이 남아있다. 이 부분의 대략적인 것은 위에서 언급했다. 자세한 계산방식을 말해보겠다. 위에서 언급한 <em>μQuad</em> 와 <em>Shadow Plane</em> 사용해서 해당 폴리곤들의 데이터 누적을 위해서는 <em>μQuad</em> 에서 이산화된 <em>binary</em> 샘플링이 필요하다. 논문의 저자는 32 번의 <em>Halton sampling</em><sup id="fnref:C2"><a href="#fn:C2" class="footnote">2</a></sup> 을 사용했다고 한다.</p>

<p>가시성을 계산하기 위해서는 <em>Shadow Plane</em> 을 <em>μQuad</em> 에 <em>Projection</em> 해줘야 한다. 그러면 <em>μQuad</em> 는 최대 3개의 <em>line</em> 을 얻게 된다. 논문에서는 이 <em>line</em> 을 <em>μQuad</em> 를 기준으로 극좌표계<sup id="fnref:C3"><a href="#fn:C3" class="footnote">3</a></sup> 데이터로 저장한다고 한다. 반지름과 각도가 5bit 크기로 저장된다. 해당 10bit 데이터를 사용하여 미리 계산된 테이블에서 32개의 이진 가시성 샘플을 가져온다. 결과와  bit 단위의 and 연산을 통해 <em>μQuad</em> 의 가시성을 계산할 수 있다고 한다.</p>

<p>해당 기법을 고안한 사람은 두가지의 아이디어 : <em>Irregular Z-Buffer</em> 와 <em>frustum-Triangle Test</em> 를 통해  <em>Sub-pixel Hard Shadow</em> 의 이론을 만들었다. 하지만 이 아이디어들과 구현을 위한 노력의 차이는 꽤 큰듯하다. 논문을 보면 아이디어에 대한 텍스트보다 최적화를 위한 텍스트가 2배가 될정도로 많다. 다음 글에서는 논문에서 나온 전체 과정과 디테일한 구현 사항에 대해 적어보겠다.</p>

<h2>참조</h2>

<ul>
  <li><a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Irregular_Z-buffer">Wikipedia : Irregular Z-Buffer</a></li>
  <li><a href="http://cwyman.org/videos/sig1657-chris-wyman-magic-behind-gameworks-hybrid-frustum-traced-shadows-hfts.mp4">cywman.org : HFTS Presentation Video</a></li>
  <li><a href="https://developer.nvidia.com/content/dont-be-conservative-conservative-rasterization">NVidia : Don’t be conservative with Conservative Rasterization</a></li>
  <li><a href="http://developer.download.nvidia.com/gameworks/events/GDC2016/jstory_hfts.pdf">NVidia : Advanced Geometrically Correct Shadows for Modern Game Engines</a></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:C1">
      <p>일반적으로 오브젝트를 그리는 것과 다른 <em>Conservative Rasterization</em> 을 해주는 이유는 일반적인 <em>Rasterization</em> 은 픽셀의 반이상을 차지해야 해당 픽셀을 처리해준다. 하지만 정확한 <em>Visibility</em> 를 계산하기 위해서는 폴리곤이 해당되는 모든 픽셀들을 처리해주어야 한다. <em>Conservative Rasterization</em> 은 앞에서 말한바와 같이 모든 부분을 픽셀로 처리한다. <em>Conservative Rasterization</em> 에 대한 자세한 정보는 <a href="https://developer.nvidia.com/content/dont-be-conservative-conservative-rasterization">NVidia : Don’t be conservative with Conservative Rasterization</a> 에서 확인할 수 있다. <a href="#fnref:C1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:C2">
      <p>몬테카를로 시뮬레이션과 같은 방식의 점을 생성하는 방식이다. 쉽게 말하면 랜덤하게 생성하는 것이라고 생각하면 된다. 자세한 정보는 <a href="https://en.wikipedia.org/wiki/Halton_sequence">Wikipedia : Halton sequence</a> 에서 확인할 수 있다. <a href="#fnref:C2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:C3">
      <p>여기서는 각도와 반지름(거리)를 사용하여 나나탠다. 극좌표계에 대한 자세한 정보는 <a href="https://ko.wikipedia.org/wiki/%EA%B7%B9%EC%A2%8C%ED%91%9C%EA%B3%84">위키피디아 : 극좌표계</a> 에서 확인할 수 있다. <a href="#fnref:C3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/01/11/unity-scripted-importer/">Unity Scripted Importer</a>
          </h1>

          <p class="post-meta">Jan 11, 2018 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 의 에디터 시스템은 꽤나 유연하다. 이번 글에서는 <em>AssetImporter</em> 에 대한 기능들에 대하여 알아볼 것이다.</p>

<p>Unity 의 각각의 Asset 들은 확장자의 이름에 따라서 <em>AssetImporter</em> 가 하나씩 만들어지고, 해당 <em>AssetImporter</em> 에 따라서 <em>Post-Process</em> 가 진행된다. 필자가 많이 봤던 <em>AssetImporter</em> 는 <a href="https://docs.unity3d.com/ScriptReference/TextureImporter.html"><em>TextureImporter</em></a> 와 <a href="https://docs.unity3d.com/ScriptReference/ModelImporter.html"><em>ModelImporter</em></a> 가 있었다. 확인할 당시에는 당연히 <em>AssetImporter</em> 를 커스터마이징 할 수 있겠다는 생각이 들어 찾아봤지만 전혀 없었다.(Unity 5 버젼을 사용할 때다.) 이렇게 시스템을 만들어 놓고 왜 없냐는 의문이 들었지만 이는 정말 할수있는게 없었기에 넘어갔었다.</p>

<p>그런데 이번에 Unity 2018.1 베타가 릴리즈 되면서 SRP 를 살펴보던 도중 <em>Expremental</em> 기능들 중에 <a href="https://docs.unity3d.com/2018.1/Documentation/Manual/ScriptedImporters.html"><em>ScriptedImporter</em></a> 라는 기능이 있는 것을 발견했다.</p>

<p>이 기능은 말그대로 예전의 내가 원하던 기능이였다. <em>AssetImporter</em> 클래스와 다른점은 딱 한가지다. 가상 <em>OnImportAsset</em> 메소드가 존재하는 것이다. 즉 <em>ScriptedImporter</em> 를 상속하여 <em>OnImportAsset</em> 를 구현하면 간단하게 에셋을 <em>Customize</em> 할 수 있는 것이다. 또한 에디터 기능을 지원하는 <a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporterEditor.html">ScriptedImporterEditor </a> 라는 클래스를 사용하면 에디터를 손쉽게 바꿀 수 있다. 자세한 사항은 글에서 언급된 링크를 통해 보면 된다.</p>

<h2>참조</h2>
<ul>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/Manual/ScriptedImporters.html">Unity Documentation : ScriptedImporter </a></li>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporter.html">Unity Reference : ScriptedImporter</a></li>
  <li><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Experimental.AssetImporters.ScriptedImporterEditor.html">Unity Reference : ScriptedImporterEditor </a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/27/percentage-closer-soft-shadows/">Percentage Closer Soft Shadows</a>
          </h1>

          <p class="post-meta">Dec 27, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/pcss/">pcss</a>
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/12/19/shadow-map-filtering/">Shadow Map Filtering</a> 에서 <em>PCF</em> 와 <em>VSM</em> 에 대하여 간단히 알아보았다. 이번 글에서 설명할 것은 <em>PCF</em> 를 활용한 <em>PCSS</em> 다.</p>

<p><em>PCSS</em> 는 <em>Soft Shadow</em> 를 구현하는 기법 중 하나로써 2005년에 발표되어 여태까지도 꽤나 알려진 기법이다. 우선 <em>Soft Shadow</em> 가 무엇인지 알아보자.</p>

<p><br /></p>

<p><img src="/images/soft_vs_hardshadow.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.assignmentpoint.com/science/computer/real-time-soft-shadow-rendering.html">assignmentpoint.com : Real Time Soft Shadow Rendering</a>
</center>
<p><br /></p>

<p>위와 같이 빛을 가린 물체와 거리가 멀어지면 멀어질수록 밝아지는 그림자를 <em>Soft Shadow</em> 라고 한다. 완전한 <em>Hard Shadow</em> 는 어색하기 때문에 보통 <em>PCF</em> 를 사용하여 끝부분을 부드럽게 처리했으나, 태양광 처럼 길게 그림자를 만드는 경우가 있으면 끝 부분이 가면 갈수록 부드러워져야 한다.</p>

<p><br /></p>

<p><img src="/images/tree_shadow.jpg" alt="" class="center-image" /></p>
<center>출처 : <a href="https://www.youtube.com/watch?v=Ax8G8P3tA28">Youtube
</a>
</center>
<p><br /></p>

<p>태양 빛에의해 만들어진 나무의 그림자다. 짧은 길이의 그림자는 적당히 <em>PCF</em> 로 대략 표현이 가능하나 이런 길은 그림자를 고정된 사이즈의 <em>PCF</em> 로 표현하기엔 무리가 있다. 그래서 나온것이 <em>PCSS</em> 다.</p>

<p><em>PCSS</em> 를 보기전에, 우리가 알아야할 용어들이 있다. 바로 <em>Umbra</em> 와 <em>Penumbra</em> 다.</p>

<p><br /></p>

<p><img src="/images/umbra_penumbra_antumbra.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://en.wikipedia.org/wiki/Umbra,_penumbra_and_antumbra">Wikipedia : Umbra, penumbra and antumbra </a>
</center>
<p><br /></p>

<p><em>Soft Shadow</em> 가 표현하는 부드러운 부분의 그림자는 위 그림에서도 보이듯이 <em>Penumbra</em> 라고 한다. <em>PCSS</em> 에서는 부드러운 부분의 그림자를 <em>Penumbra</em> 라고 한다. <em>PCSS</em> 에서는 <em>Penumbra</em> 의 크기를 사용하여 <em>PCF</em> 의 샘플링 범위를 정해준다. 우선 <em>PCSS</em> 의 <em>Penumbra</em> 를 계산하는 방법을 보자.</p>

<p><br /></p>

<p><img src="/images/PCSS_PenumbraSizeEstimation.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://http.download.nvidia.com/developer/presentations/2005/SIGGRAPH/Percentage_Closer_Soft_Shadows.pdf">Siggraph 2005 : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>맨위의 노란색으로 표시된 부분은 광원을 뜻하며, 일정한 범위로 빛을 비추는 <em>Area Light</em> 로 가정한 후 계산한다. W - light 는 <em>Area Light</em> 의 범위를 뜻한다. 중간에 있는 <em>Blocker</em> 는 빛을 가리는 물체를 뜻하며, d blocker 는 가리는 물체와 빛과의 거리, d receiver 는 그림자가 비추는 물체와 광원 사이의 거리를 뜻한다. 그림자를 받는 부분과 빛을 가리는 물체와 광원을 서로 평행하다고 가정해서 계산한다. 2차원의 그림을 3차원으로 바꿔보자.</p>

<p><br /></p>

<p><img src="/images/PCSS_Scheme.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>보통 <em>Pixel Shader</em> 에서 그림자의 비춘 정도를 계산하기 때문에 <em>Receiver</em> 의 작은 부분을 기준으로 그림이 그려져 있다. 작은 부분을 기준으로 <em>Area Light</em> 와의 <em>frustum</em> 과 <em>Blocker</em> 가 얼마나 충돌되는지 체크한다. 우리는 <em>Shadow Map</em> 을 사용하기 때문에 아래 그림이 조금 더 실제 계산과 비슷하다.</p>

<p><br /></p>

<p><img src="/images/PCSS_Scheme2.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a>
</center>
<p><br /></p>

<p>그래서 <em>Shadow Map</em> 의 빨간색으로 하이라이트 된 부분을 샘플링해 얼마나 가리고 있는지를 확인한다. 그러면 빛을 받는 정도를 알 수 있게 되는것이다. 해당 부분을 적당히 샘플링한 다음 평균을 구해서 <em>PCF</em> 로 샘플링하는 범위를 계산한다. 계산하여 <em>PCF</em> 에서 범위를 사용해 계산한다. 코드를 보면서 이해해보자.</p>

<p><br /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">PCSS_Shadow</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="n">float2</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="kt">float</span> <span class="n">zEye</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 1: blocker search</span>
	<span class="c1">// ------------------------</span>
	<span class="kt">float</span> <span class="n">accumBlockerDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">numBlockers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">float2</span> <span class="n">searchRegionRadiusUV</span> <span class="o">=</span> <span class="n">SearchRegionRadiusUV</span><span class="p">(</span><span class="n">zEye</span><span class="p">);</span>
	<span class="n">FindBlocker</span><span class="p">(</span><span class="n">accumBlockerDepth</span><span class="p">,</span> <span class="n">numBlockers</span><span class="p">,</span> <span class="n">g_shadowMap</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="n">searchRegionRadiusUV</span><span class="p">);</span>

	<span class="c1">// Early out if not in the penumbra</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numBlockers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">numBlockers</span> <span class="o">==</span> <span class="n">BLOCKER_SEARCH_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 2: penumbra size</span>
	<span class="c1">// ------------------------</span>
	<span class="kt">float</span> <span class="n">avgBlockerDepth</span> <span class="o">=</span> <span class="n">accumBlockerDepth</span> <span class="o">/</span> <span class="n">numBlockers</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">avgBlockerDepthWorld</span> <span class="o">=</span> <span class="n">ZClipToZEye</span><span class="p">(</span><span class="n">avgBlockerDepth</span><span class="p">);</span>
	<span class="n">float2</span> <span class="n">penumbraRadiusUV</span> <span class="o">=</span> <span class="n">PenumbraRadiusUV</span><span class="p">(</span><span class="n">zEye</span><span class="p">,</span> <span class="n">avgBlockerDepthWorld</span><span class="p">);</span>
	<span class="n">float2</span> <span class="n">filterRadiusUV</span> <span class="o">=</span> <span class="n">ProjectToLightUV</span><span class="p">(</span><span class="n">penumbraRadiusUV</span><span class="p">,</span> <span class="n">zEye</span><span class="p">);</span>

	<span class="c1">// ------------------------</span>
	<span class="c1">// STEP 3: filtering</span>
	<span class="c1">// ------------------------</span>
	<span class="k">return</span> <span class="n">PCF_Filter</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">dz_duv</span><span class="p">,</span> <span class="n">filterRadiusUV</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<center>출처 : <a href="https://github.com/NVIDIAGameWorks/D3DSamples">Github NVIDIAGameWorks : D3DSamples</a>
</center>
<p><br /></p>

<p>해당 픽셀이 어두워지는 정도를 반환하는 <em>PCSS</em> 계산 함수다. 코드의 주석에서는 계산을 세단계로 나눈다. 첫번째로는 <em>Shadow Map</em> 을 샘플링해서 얼마나 빛이 얼마나 가려지는지 계산한다. 이를 <em>STEP 1: blocker search</em> 라고 표기해놓았고, 두번째는 <em>PCF</em> 에서 샘플링할 범위를 결정하는 넓이를 계산한다. 이를 <em>STEP 2: penumbra size</em> 라고 한다. 세번째로는 <em>PCF</em> 를 계산해서 가려지는 정도를 반환한다. 자세한 코드는 출처에서 <em>SoftShadows</em> 항목을 들어가면 볼 수 있다.</p>

<p><em>PCSS</em> 의 장점은 아무래도 확실한 <em>Soft Shadow</em> 를 구현했다는 점이다. 비록 대략적으로 가정한 부분이 많지만 장면별로 잘 맞춰주기만 한다면 괜찮은 결과가 나올것 같다. 하지만 샘플링 횟수가 꽤나 된다. <em>PCF</em> 만 하더라도 가볍지는 않은 편인데, <em>Blocker</em> 를 계산하느라 더 많이 샘플링을 한다. 하지만 잘 만들어진 게임과 요즘의 GPU 에서는 아주 큰 오버헤드는 없는걸로 보인다. (<a href="https://www.reddit.com/r/nvidia/comments/49idz3/nvidia_hfts_the_division/">Redit : Nvidia HFTS (The Division)</a>)</p>

<h2>참조</h2>
<ul>
  <li><a href="https://http.download.nvidia.com/developer/presentations/2005/SIGGRAPH/Percentage_Closer_Soft_Shadows.pdf">Siggraph 2005 : Percentage-Closer Soft Shadows</a></li>
  <li><a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">NVidia : Percentage-Closer Soft Shadows</a></li>
  <li><a href="https://github.com/NVIDIAGameWorks/D3DSamples">Github NVidiaGameWorks : D3DSample</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/19/shadow-map-filtering/">Shadow Map Filtering</a>
          </h1>

          <p class="post-meta">Dec 19, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/vsm/">vsm</a>
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/11/30/what-is-shadow-mapping/">What is Shadow Mapping</a> 에서 <em>Shadow Mapping</em> 에 대한 간단한 번역 &amp; 설명을 적어놓았다. 해당 글에서 <em>PCF</em> 를 잠깐 언급했었다. 이 글에서는 <em>PCF</em> 를 포함해서 <em>Shadow Map</em> 을 필터링하는 방법에 대해서 알아보겠다.</p>

<p>첫번째는 <em>PCF</em> 다. 풀어쓰면 <em>Percentage Closer Filtering</em> 이라는 단어가 되며, <em>Shadow Map</em> 을 여러번 샘플링해 <em>Percentage</em> 를 소숫점으로 나타내서 <em>Shadow</em> 가 생긴 정도를 나타내주는 <em>Filtering</em> 기법이다. 쉽게 이해할 수 있도록 아래 그림을 보자.</p>

<p><br />
<img src="/images/PCF_Scheme.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://graphics.pixar.com/library/ShadowMaps/paper.pdf">Pixar : Rendering Antialiased Shadows with Depth Maps</a>
</center>
<p><br /></p>

<p>위의 a) 는 아무것도 필터링 하지 않을 때의 <em>ShadowMap</em> 샘플링하는 것을 보여주고, 아래 b) 는 <em>PCF</em> 를 사용해 샘플링하는 것을 보여준다. 위 그림에서 <em>Surface at z = 49.8</em> 은 그림자를 처리할 표면의 <em>Depth</em> 또는 <em>Z</em> 을 뜻한다. 그리고 <em>Light-Space</em> 를 기준으로 해당 값보다 <em>Depth</em> 값이 멀다고 판단될시에는 처리하지 않고, 가깝다고 판단될 때는 처리하는 걸로 해준다. <em>Shadow Map</em> 에서 한 부분만 샘플링해서 하는 것이 윗 부분의 그림이고, 한 부분이 아닌 근처의 여러 부분을 샘플링해서 값을 구하는 것이 <em>PCF</em> 다.</p>

<p>아래에 <em>PCF</em> 를 사용하는 코드가 있다.</p>

<p><br /></p>

<pre><code class="language-HLSL">float PCF_FILTER( float2 tex, float fragDepth )
{
    //PreShader - This should all be optimized away by the compiler
    //====================================
    float fStartOffset = BoxFilterStart( fFilterWidth );
    float texOffset = 1.0f / fTextureWidth;
    //====================================

    fragDepth -= 0.0001f;
    tex -= fStartOffset * texOffset;

    float lit = 0.0f;
		for( int i = 0; i &lt; fFilterWidth; ++i )
			for( int j = 0; j &lt; fFilterWidth; ++j )
			{
				lit += texShadowMap.SampleCmpLevelZero(
                                FILT_PCF,
                                float2( tex.x + i * texOffset, tex.y + j * texOffset ),
                                fragDepth
                              );
			}
	return lit / ( fFilterWidth * fFilterWidth );
}
</code></pre>

<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a>
</center>
<p><br /></p>

<p>자세한 코드는 위의 출처에서 코드를 구해서 보면 될듯하다. <em>Texture2D::SampleCmpLevelZero</em> 는 <em>MipMap</em> 참조 레벨은 0으로 한채 텍스쳐의 값을 샘플링하여 주어진 인자와 비교하여 <em>Sampler</em> 에 정해준 방식에 적합하면 1, 적합하지 않으면 0을 반환해준다.</p>

<p>해당 그림에서는 평균을 구하는 방법을 표기해놓았으나 다른 <em>NDF</em> 를 써서 구현할 수도 있다.(<em>Gaussian Distribution</em>) 또한 규칙적으로 샘플링하는게 아닌 <em>jitter</em> 를 사용해서 샘플링할 수도 있다고 한다. 일반적으로 <em>Poisson disk Distribution</em> 을 사용한다고 한다.</p>

<p><em>PCF</em> 의 단순한 방법으로 <em>Shadow Map</em> 을 <em>AntiAliasing</em> 할 수 있다. 하지만 <em>Shadow Map</em> 의 샘플링 횟수가 <em>PCF Kernel</em>(3x3, 5x5..) 이 커지면 커질수록 많아지기 때문에 꽤나 큰 <em>PCF Kernel</em> 에서는 샘플링 부하가 걸릴 수 있다. 성능상 단점이 크나 <em>PCF</em> 는 굉장히 많이 사용되는 기법 중에 하나라고 한다.</p>

<p>다음은 <em>Variance Shadow Map</em> 이다. 이는 <a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality"><em>Chebyshev’s Inequality</em></a> 라는 통계학의 개념을 사용해 <em>Filtering</em> 해준다. 먼저 <em>Shadow Map</em> 을 저장할 때 <em>Depth</em> 만 저장하는게 아닌 <em>Depth</em> 의 제곱값 또한 같이 저장한다. <em>Filtering</em> 에 쓰일 공식을 위해 같이 넣는다.</p>

<p>다음은 아래 코드와 같이 공식을 계산해준다.</p>

<p><br /></p>

<pre><code class="language-HLSL">float VSM_FILTER( float2 tex, float fragDepth )
{
    float lit = (float)0.0f;
    float2 moments = texShadowMap.Sample( FILT_LINEAR,    float3( tex, 0.0f ) );

    float E_x2 = moments.y;
    float Ex_2 = moments.x * moments.x;
    float variance = E_x2 - Ex_2;    
    float mD = (moments.x - fragDepth );
    float mD_2 = mD * mD;
    float p = variance / (variance + mD_2 );
    lit = max( p, fragDepth &lt;= moments.x );

    return lit;
}
</code></pre>

<center>출처 : <a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a>
</center>
<p><br /></p>

<p>눈여겨 볼것은 샘플러를 <em>Linear</em> 하게 설정해놓는 것이다.</p>

<p>하지만 <em>VSM</em> 은 큰 단점이 하나 있다. 바로 <em>Light Leaking</em> 이 일어나는 것이다. 이는 <a href="https://http.download.nvidia.com/developer/presentations/2006/gdc/2006-GDC-Variance-Shadow-Maps.pdf">GDC 2006 : Variance Shadow Map</a> 에서 참조할 수 있다. 이를 해결 하는 근본적인 방법은 없다고 한다.</p>

<p>두가지 기법의 차이는 텍스쳐 샘플링을 더 많이 하느냐, 메모리를 2배로 늘려주느냐의 차이에 있다. 속도를 따지면 <em>VSM</em> 이 빠르다고 한다. 하지만 굳이 퍼포먼스를 낼 필요가 없다면 <em>PCF</em> 를 사용하는 것도 나쁜 선택은 아닐것 같다. 선택에 대한 궁금증은 <a href="https://www.opengl.org/discussion_boards/showthread.php/177219-Shadow-filtering-PCF-better-than-VSM">OpenGL Forum : Shadow filtering: PCF better than VSM? </a> 글을 참조하길 바란다.</p>

<h2>참조</h2>
<ul>
  <li><a href="https://graphics.pixar.com/library/ShadowMaps/paper.pdf">Pixar : Rendering Antialiased Shadows with Depth Maps</a></li>
  <li><a href="https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb509697.aspx">MSDN : SampleCmpLevelZero</a></li>
  <li><a href="http://www.punkuser.net/vsm/">Variance Shadow Maps</a></li>
  <li><a href="https://http.download.nvidia.com/developer/presentations/2006/gdc/2006-GDC-Variance-Shadow-Maps.pdf">GDC 2006 : Variance Shadow Maps</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality">Wikipedia : Chebyshev’s inequality</a></li>
  <li><a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">GPU Gems : Shadow Map Antialiasing</a></li>
  <li><a href="http://developer.download.nvidia.com/SDK/10/direct3d/screenshots/samples/VarianceShadowMapping.html">NVidia : Variance Shadow Mapping Website</a></li>
  <li><a href="https://github.com/TheRealMJP/Shadows">Github : TheRealMJP - Shadows</a></li>
  <li><a href="https://www.opengl.org/discussion_boards/showthread.php/177219-Shadow-filtering-PCF-better-than-VSM">OpenGL Forum : Shadow filtering: PCF better than VSM? </a></li>
</ul>

        </div>

        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Su-Hyeok Kim - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
