<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Appocrypha</title>
  <meta name="description" content="store limitless knowledges">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Appocrypha">
  <meta name="twitter:description" content="store limitless knowledges">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/30/using-command-buffer/">Using Command Buffer</a>
          </h1>

          <p class="post-meta">Sep 30, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>일반적으로 Graphics Driver API 에서 지원하는 <em>CommandBuffer</em> 는 굉장히 낮은 드라이버 레벨의 렌더링 명령을 저장하여, GPU 에서 이 <em>CommandBuffer</em> 를 참조해 그려주는 <strong>Task Queue</strong> 의 개념이다. 하지만 Unity 에서 지원하는 <em>CommandBuffer</em> 의 개념은 비슷하지만 조금 다르다.</p>

<p>Unity 렌더링 시스템은 재미있는 기능을 많이 제공하지만 그중에서도 가장 활용할 가능성이 높은 기능은 <strong>CommandBuffer</strong> 일 것이다. 이는 일반적으로 알려진 Graphics Driver API 에서의 낮은 레벨의 명령을 저장하는 <em>CommandBuffer</em> 와는 달리 Unity 에서 사용할 수 있는 <strong>CommandBuffer</strong> 는 Unity 의 대부분의 렌더링 기능을 사용할 수 있다. <a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html">Unity Reference : Command Buffer</a> 이 링크를 보면 알겠지만 정말 많은 기능들을 <strong>CommandBuffer</strong> 에 저장할 수 있다. 이는 렌더링 스크립트를 유연하게 짤 수 있게 해주며, 파이프라인의 개념까지 건드릴 수 있게 된다.</p>

<p>그리고 이 명령을 실행하는 방법은 3가지가 있다. 하나는 <em>Camera.AddCommandBuffer</em> 메소드를 사용하는 방법이다. 이는 <strong>Camera</strong> 컴포넌트에 <strong>CommandBuffer</strong> 를 집어넣는 기능인데, 단순히 넣는게 아니라 <strong>Camera</strong> 의 렌더링 단계는 굉장히 많은 단계로 나뉘는데, 이 단계별로 시간을 정해 그릴 수도 있다. 굉장히 과정이 많기 때문에 사용자가 원하는 시점에 넣기만 하면 된다. 그러면 <strong>Camera</strong> 가 렌더링을 하는 과정에서 <strong>CommandBuffer</strong> 의 명령들을 실행할 것이다. 또한 같은 이치로 <em>Light.AddCommandBuffer</em> 메소드가 있다. <em>Camera.AddCommandBuffer</em> 와 같이 원하는 시점에 <strong>CommandBuffer</strong> 를 넘기면 된다.</p>

<p>마지막으로는 <em>Graphics.ExecuteCommandBuffer</em> 이다. 이는 즉각적으로 <strong>CommandBuffer</strong> 안의 명령들을 실행시키는 기능으로 앞에서 언급한 시스템에서 알아서 실행되는 것과는 다르다. 사용자가 실행 시점을 정하고 싶은 경우에는 이 메소드를 쓰면 될것이다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/Manual/GraphicsCommandBuffers.html">Unity Manual : Graphics Command Buffers</a></li>
  <li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html">Unity Reference : Command Buffer</a></li>
  <li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CameraEvent.html">Unity Reference : CameraEvent</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/30/multi-compiled-shader-in-unity/">Multi Compiled Shader In Unity</a>
          </h1>

          <p class="post-meta">Sep 30, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 는 렌더링을 위한 하부 시스템을 꽤나 많이 만들어 놓았다. 그 중에서도 꽤나 오래된 시스템은 <em>multi-compiled shader</em> 시스템일 것이다. 직역하면 여러개로 컴파일된 <em>Shader</em> 란 말이다. 또한 기능또한 별 차이 없다. 하지만 이를 위해 시스템에서 어떤 일을 하는지에 대해서는 알아야 한다.</p>

<p>우선 <em>multi-compiled shader</em> 에 대해서 알아야 겠다. Unity 시스템에서는 단순히 물체를 렌더링하는데 한가지 방법만 쓰이지 않는다. <strong>UnityEngine.MeshRenderer</strong> 같은 지원하는 컴포넌트를 통해 렌더링을 하는게 가장 알려진 방법이다. 또한 컴포넌트가 아닌 코드 레벨에서도 렌더링이 가능하다. <em>Graphics.DrawProcedural</em> 와 비슷한 메서드를 통해서도 렌더링이 가능하다. 또한 Unity 에서 지원하는 시스템을 사용하기 위해 분기 키워드가 아닌 전처리 옵션을 두어 사용하기도 한다.(Unity 에서는 기능 지원을 위해 전처리기 기능을 많이 쓴다.) 여기서 알아야 할 것은 Unity 시스템에서는 굉장히 많은 방법으로 다양한 렌더링을 지원하는데, 다양한 렌더링을 사용하기 위해서는 <em>Shader</em> 또한 각각 다양한 렌더링 방법에 맞추어 컴파일 될 필요가 있다. 그럴때 쓰는 것이 <em>multi-compiled shader</em> 기능이다.</p>

<p>사용자가 직접 <em>multi-compiled shader</em> 기능을 사용하는 것은 꽤나 단순하다.</p>

<pre><code class="language-C">#pragma multi_compile FANCY_STUFF_OFF FANCY_STUFF_ON
</code></pre>

<p>쉐이더 코드에서 위와 같이 사용하게 되면 <em>FANCY_STUFF_OFF</em>, <em>FANCY_STUFF_ON</em> 두가지 옵션을 통해 컴파일 하는 것을 나눌 수 있게 된다. 이 키워드는 쉐이더 바깥에서 제어가 가능하다. 모든 쉐이더의 키워드를 제어하려면 <em>Shader.EnableKeyword</em>, <em>Shader.DisableKeyword</em> 를 사용하면 되고, <strong>Material</strong> 단위로 사용하려면 <em>Material.EnableKeyword</em>, <em>Material.DisableKeyword</em> 을 사용하면 된다. 또한 Unity 시스템 내에서 이 <em>multi-compiled shader</em> 를 사용하니, 기존에 있는 것들은 사용하면 영 좋지 않은 꼴이 일어날듯 하다.</p>

<p>이런 복잡함을 만드는 시스템에는 언제나 문제가 있다. Unity 에서의 기본적인 <em>Shader</em> 컴파일은 따로 설정을 해주지 않는 이상 Runtime 에 일어난다. 정확히 Unity 시스템에서 해당 쉐이더를 사용해 렌더링을 할때 컴파일을 하게 된다. 그리고 컴파일할 <em>Shader</em> 의 양이 많으면 많을수록 이는 영 좋지않은 꼴을 보게된다. <em>multi-compiled shader</em> 는 더욱더 시간을 많이 잡아먹게 한다. 물론 이를 해결하기 위한 방법은 존재한다.</p>

<p>Unity 프로젝트 설정에서 <em>Graphics Setting</em> 에서 가능하다. 잘 찾아보면 <strong><em>Shader Preloading</em></strong> 이라는 항목이 있다. 말그대로 Runtime 에 로딩하는게 아닌 시작하자마자 로딩하는 기능이다. 다만 이 기능을 사용하려면 <em>Shader</em> 를 그대로 넣는게 아닌 다른 것을 만들어야 한다. 이는 <strong>ShaderVariantsCollection</strong> 이라는 에셋인데, Unity 에서 생성가능하다. 이 에셋은 <em>Shader</em> 의 종류를 가지고 <em>multi-compiled shader</em> 의 어떤 쉐이더를 로딩할지 결정하는 에셋이다. 이 에셋을 생성하여 <em>Shader</em> 들을 세팅한 뒤, <strong><em>Shader Preloading</em></strong> 아래에 있는 리스트에 넣어주면 응용 프로그램이 시작될 때, Unity 시스템에서 알아서 로딩한다. 미리 로딩하는게 아닌 사용자가 원할때 로딩하는 것도 가능한 것처럼 보인다. <strong>ShaderVariantsCollection</strong> 를 사용하면 사용자가 원할 떄 단순히 메소드 호출을 통해 로딩이 가능하다. <em>ShaderVariantsCollection.WarmUp</em> 이라는 메소드를 호출하면 전부 로딩을 하기 시작하는데 이때 로딩하는 개념이 조금 재미있다. Unity 시스템에서는 필요할 때 <em>Shader</em> 를 로딩한다. 이는 위에서도 언급했었는데 <em>ShaderVariantsCollection.WarmUp</em> 는 단순히 이 지연 로딩 시스템을 이용한 것 뿐이다. <em>ShaderVariantsCollection.WarmUp</em> 을 호출하면 단순한 폴리곤 한개를 렌더링하는데, <strong>ShaderVariantsCollection</strong> 이 가지고 있는 모든 쉐이더로 한번씩 렌더링을 한다. 이렇게 되면 지연 로딩 시스템이 쉐이더를 로딩하게 되는 것이다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html">Unity Manual : Making multiple shader program variants</a></li>
  <li><a href="https://docs.unity3d.com/kr/current/ScriptReference/ShaderVariantCollection.html">Unity Reference : ShaderVariantsCollection</a></li>
  <li><a href="https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html">Unity Manual : Optimizing Shader Load Time</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/29/using-rendering-to-cubemap/">Using Rendering To Cubemap</a>
          </h1>

          <p class="post-meta">Sep 29, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/09/29/using-relplacement-shader/">using replacement shader</a> 에서 <em>Camera.RenderWithShader</em> 와 같은 렌더링을 코드에서 직접해주면서 기능을 커스터마이징 할 수 있는 것을 살펴보았는데, 이 게시물에서는 비슷한 메서드인 <em>Camera.RenderToCubemap</em> 에 대해서 알아볼 것이다.</p>

<p>Unity 에서는 여러 렌더링 커스터마이징 기능을 제공하는데, 이 게시물에서는 그 중 하나인 <em>Camera.RenderToCubemap</em> 에 대해서 알아볼 것이다. 일반적으로 <em>Cubemap</em> 은 SkyBox 나 주변의 Irradiance 를 나타낼 때 쓴다. 다만 이를 직접 구현할 때의 문제점은 각 모서리별로 <em>Aliasing</em> 이 일어나는 경우다. 매우 매끄러운 표면의 Specular 에서 <em>Aliasing</em> 이 나타난 Irradiance 를 표현하면 굉장히 티가 많이 나기 때문에 이는 굉장히 신경써야할 문제다.</p>

<p>그래서 Unity 에서는 <em>Cubemap</em> 에 렌더링을 하는 기능인 <em>Camera.RenderToCubemap</em> 을 지원한다. 이를 통해 할 수 있는 것은 실시간으로 <em>Cubemap</em> 에 렌더링된 결과를 저장해 <em>Irradiance</em> 의 소스로 쓰거나, 실시간으로 바뀌는 <em>Skybox</em> 렌더링을 할 수도 있다. 사용 방법은 아래와 같다.</p>

<pre><code class="language-C#">RenderTexture cubmapRT = ...;
camera.RenderToCubemap(cubemapRT, 63);
</code></pre>

<p><em>Camera.RenderToCubemap</em> 의 두번째로 들어가는 인자는 어떤 면을 그릴건지에 대한 비트마스크다. <em>Camera.RenderToCubemap</em> 를 쓸때 주의할 점은 일부 하드웨어에서는 동작하지 않는 기능이라고 한다. 다만 특정한 하드웨어를 기술해 놓지않아서 추측하기는 어렵다. 단순히 추측할 수 있는 것은 MRT 를 지원하지 않거나 아니면 다른 <em>ComputeShader</em> 같은 기능을 사용해 일부 하드웨어에서 안된다고 하는 정도 밖에 없다.</p>

<p>위 예제에서는 RenderTexture 를 사용하였는데, 저렇게 코드에서 처리할 수도 있지만 CustomRenderTexture 를 통해 간편하게 처리할 수도 있다. CustomRenderTexture 는 업데이트 주기를 사용자 임의대로 정할 수 있으므로 꽤나 유용하게 쓰일 수 있다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/kr/current/ScriptReference/Camera.RenderToCubemap.html">Unity Reference : Camera.RenderToCubemap</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/29/using-relplacement-shader/">Using Relplacement Shader</a>
          </h1>

          <p class="post-meta">Sep 29, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 는 <em>Replacement Shader</em> 라는 렌더링 기능을 지원한다. 이는 Unity 가 Rendering 기능에서 지원하는 약간 Hack 한 테크닉이며 이 기능을 잘 사용하면 쉐이더를 바꿔치기 해서 재미있는 것들을 할 수 있다. <em>Replacement Shader</em> 는 렌더링할 MeshRenderer 들이 가지고 있는 <strong>Material</strong> 의 Shader 를 사용자가 원하는 것으로 바꾸는 기능이다. 이 기능을 통해 그림자 같은 여러 부가적인 처리를 할 수 있다.</p>

<p>사용하는 방법은 아래와 같다.</p>

<pre><code class="language-C#">Shader shader = Shader.Find("CustomShaderName");
string replacementTag = "replace";

// tag is optional. if dont need tag, insert null.
camera.RenderWithShader(shader, replacementTag);
</code></pre>

<p>위의 간단한 예제는 <em>Replacement Shader</em> 를 사용해 한번 그려주는 예제다. 단순히 <em>Camera.RenderWithShader</em> 를 사용하기 때문에 직접 값을 컨트롤할 때 사용하기 좋다. <em>Replacement Shader</em> 를 영구적으로 세팅하여 자동으로 그려주면 아래와 같이 하면된다.</p>

<pre><code class="language-C#">Shader shader = Shader.Find("CustomShaderName");
string replacementTag = "replace";

// tag is optional. if dont need tag, insert null.
camera.SetReplacementShader(shader, replacementTag);
</code></pre>

<p>사용 방법은 굉장히 단순하다. 다만 이 <em>Replacement Shader</em> 기능에서 중요한 것은 쉐이더를 단순히 치환하는 것만 포인트가 아니다. 치환된 쉐이더들은 기존 <strong>Material</strong> 이 가지고 있던 데이터들과 쉐이더 코드에서 이름만 똑같이 맞추어주면 자동으로 데이터들이 쉐이더로 들어온다. 즉 쉐이더를 갈아치우지 않고도 데이터를 공유할 수 있는 것이다. 이는 Unity 의 렌더링에서 굉장히 강력한 시스템으로 초기에는 이해하기도 힘들고 잔머리가 필요하지만 이를 잘 사용만 한다면 굉장히 유용하게 쓰일 수 있다.</p>

<p>필자는 Github 에서 OIT 예제를 보면서 처음 보았다. <a href="https://github.com/candycat1992/OIT_Lab">Github : OIT_Lab</a> 에서 OIT 를 처리하는 코드에서 구경할 수 있다. 또한 일본 Unity 지사에서 일하는 유명한 keijiro 의 <a href="https://github.com/keijiro/Skinner">Skinner</a> 에서 위치를 처리하는데 쓰이기도 한다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/kr/current/Manual/SL-ShaderReplacement.html">Unity Reference : Replaced Shaders 에서의 렌더링</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/01/using-compute-buffer-in-unity/">Using Compute Buffer In Unity</a>
          </h1>

          <p class="post-meta">Aug 1, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Unity 에서의 확실한 GPU Instancing 은 <strong>ComputeBuffer</strong> 라는 구현체에서 시작될 것이다. 이 구현체는 <strong>UnityEngine.ComputeBuffer</strong> 라는 Unity 의 구현체이며 하는 역할은 GPU 메모리를 사용하게 해주는 역할을 한다. <strong>ComputeBuffer</strong> 는 <strong>ComputeShader</strong> 와 함께 등장했다. <strong>ComputeShader</strong> 에서 데이터를 읽고 쓰는것을 요구하기 때문에 Unity 는 GPU 메모리를 사용하는 컨테이너로서 <strong>ComputeBuffer</strong> 를 구현해 놓았다. 하지만 이 <strong>ComputeBuffer</strong> 는 <strong>ComputeShader</strong> 뿐만아니라 일반 쉐이더에서도 폭넓게 사용가능하다. 이 말의 뜻은 우리가 생각하는 Unity 에서 지원하는 일반적인 메쉬 데이터를 사용하지 않아도 사용자가 직접 메쉬 데이터를 커스터마이징해서 사용할 수 있다는 이야기이다. 지원하는 플랫폼은 일반적으로 말하는 <em>Shader Model 5.0</em> 이상이다. PC 플랫폼에서는 당연히 사용 가능하다.</p>

<p>사용하는 방법 자체는 어렵지 않다. 스크립트에서 <em>size</em> 와 <em>stride</em> 를 설정해주고, 데이터의 배열을 만들어 GPU 메모리 안에 있는 데이터를 읽거나 쓸 수 있다. 메모리 단위에서 하는것처럼 보이기 때문에 크기와 타입은 맞춰주어야 한다. C# 에서는 <strong>System.Array</strong> 형으로 넣어주니 형태에 주의하기 바란다. 방법은 아래와 같다.</p>

<pre><code class="language-C#">int dataLen = ...;  // length of data
int[] dataArray = new int[dataLen];

// record data in dataArray..

ComputeShader computeShader = ...;
ComptueBuffer dataBuffer = new ComputeBuffer(dataLen, sizeof(int));
dataBuffer.SetData(dataArray);

computeShader.SetBuffer("dataBuffer", dataBuffer);
</code></pre>

<p>위 코드는 <strong>ComputeShader</strong> 에서 <strong>ComputeBuffer</strong> 를 사용하기 위해 세팅하는 코드다. 가장 맨처음에는 초기에 세팅할 정수 배열을 만들고, 그 다음 <strong>ComputeBuffer</strong> 인스턴스를 생성한다. 생성자에서 넣어주는 인자는 데이터의 길이(<em>length</em>)와 각 데이터별 크기(<em>stride</em>)이다. 그 다음 같은 크기의 배열의 데이터를 GPU 메모리로 쓴다.(<em>write</em>) 그리고 마지막으로 데이터가 세팅된 <strong>ComputeBuffer</strong> 를 <strong>ComputeShader</strong> 에 연결해준다. 이러면 <strong>ComputeShader</strong> 코드에서 <em>dataBuffer</em> 라는 변수명을 가진 변수에 <strong>ComputeBuffer</strong> 가 연결된다. 아래에 <strong>ComputeShader</strong> 코드가 있다.</p>

<pre><code class="language-HLSL">StructuredBuffer&lt;int&gt; dataBuffer;

[numthreads(8,8,1)]
void Process (uint3 id : SV_DispatchThreadID)
{
  ...
}
</code></pre>

<p>맨 처음에 있는 <em>dataBuffer</em> 에 연결된다. <a href="{ post_url 2017-07-06-structured-buffer-vs-constant-buffer }">StructuredBuffer vs ConstantBuffer</a> 에서본 <em>StructuredBuffer</em> 타입이 가능하다. 또한 <em>RWStructuredBuffer</em>, <em>ConsumeStructuredBuffer</em>, <em>AppendStructuredBuffer</em> 가능하다. 다른 렌더러 쉐이더 코드에서도 사용가능하다. 그래서 일반적으로 고려되는 파이프라인은 아래와 같다.</p>

<p><img src="/images/data-process-pipeline.png" alt="data process" class="center-image" /></p>

<p>앞의 두가지 <strong>ComputeBuffer</strong> 를 세팅하고 <strong>ComputeShader</strong> 를 실행하는 코드는 대충 보았다, 뒷 부분의 <strong>ComputeBuffer</strong> 를 통해 렌더링을 하는 것은 그다지 어렵지 않다. 중요한 것은 참신하게, 효율적으로 렌더링하는 것이다.</p>

<p><a href="https://github.com/hrmrzizon/CustomSkinningExample">Github : CustomSkinningExample</a> 에서 스키닝의 계산을 <strong>ComputeShader</strong> 로 넘겨서 계산한다. 또한 메시 데이터 전체를 <strong>ComputeBuffer</strong> 로 넘겨서 렌더링하기 때문에 꽤나 괜찮은 예가 될것이다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://docs.unity3d.com/ScriptReference/ComputeBuffer.html">Unity Reference : ComptuteBuffer</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/01/darboux-frame/">Darboux Frame</a>
          </h1>

          <p class="post-meta">Aug 1, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/math/">math</a>,
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/study/">study</a>
    
  

</p>
        </header>

        <div class="post-content">
          <p>여러 공간 법선 벡터(<em>tangent space normal</em>, <em>object space normal</em>)에 대하여 알아보던 도중 모르는 것이 하나있어 정리해볼겸 포스팅해보려 한다. <em>darboux frame</em> 이라는 놈이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/08/01/darboux-frame/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/07/30/normal-tangent-binormal/">Normal Tangent Binormal</a>
          </h1>

          <p class="post-meta">Jul 30, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/math/">math</a>,
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/study/">study</a>
    
  

</p>
        </header>

        <div class="post-content">
          <p>Graphics 를 공부하다보면 노말(normal), 탄젠트(tangent), 바이노말(binormal) 를 굉장히 많이보게 된다. 특히 노말이라는 단어는 꽤나 많이 보인다. 보통은 어떤 역할을 하는 벡터앞에 이름을 붙여서 말한다. 아래와 같이 정리된다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/07/30/normal-tangent-binormal/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/07/22/optimized-center-of-rotation/">Optimized Center Of Rotation</a>
          </h1>

          <p class="post-meta">Jul 22, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/skinning/">skinning</a>,
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/vertex-deformation/">vertex deformation</a>,
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/try/">try</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>이전 <a href="/2017/07/20/dual-quaternion-skinning/">dual quaternion skinning</a> 글에서 <em>dual quaternion skinning</em> 에 대해서 설명해 보았다. 이전 글에서는 단순히 <em>dual quaternion skinning</em> 에 대해서 알아보고 장점에 대해서 알아보았다. 단점에 대해서는 언급을 하지않았는데 사실 단점도 존재하긴 한다. 새로 소개할 방법의 논문에서 <em>dual quaternion skinning</em> 의 단점에 대해서 언급했다.</p>

<p><em>joint bulging artifact</em> 라고 하는 것인데, 90도 정도 휜 부분의 바깥쪽이 튀어나오는 현상을 말한다. 아래 그림에서 볼 수 있다.</p>

<p><img src="/images/dqs_ocor_bent.png" alt="both bent" class="center-image" /></p>

<p>왼쪽은 <em>dual quaternion skinning</em> 을 표현한 그림이고, 오른쪽은 곧 소개할 <em>optimized center of rotation</em> 방법이 적용된 스키닝이다. 각 그림의 오른쪽의 90도 휜 부분을 관찰하면 <em>dual quternion skinning</em> 이 약간 아래가 부푼 모습을 볼 수 있다. 이를 <em>joint bulging artifact</em> 라고 한다. 그리고 오른쪽 위의 확대된 그림을 보면 <em>dual quaternion skinning</em> 은 약간 움푹 들어간 것을 볼 수 있다.</p>

<p>그래서 디즈니 리서치라는 연구소에서 새로운 방법을 2016 년 Siggraph 에서 소개했다. 논문의 이름은 <em>Real-time Skeletal Skinning with Optimized Centers of Rotation</em> 이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/07/22/optimized-center-of-rotation/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/07/20/dual-quaternion-skinning/">Dual Quaternion Skinning</a>
          </h1>

          <p class="post-meta">Jul 20, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/skinning/">skinning</a>,
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/vertex-deformation/">vertex deformation</a>,
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/try/">try</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>이전 <a href="/2017/07/07/introduce-of-skinning/">Introduce of skinning</a> 글에서 Skinning 에 대한 설명과 LBS 에 관한 내용을 간단하게 다루어 보았다. 하지만 글 마지막에 해결되지 않은 문제가 하나 있었다. <em>Linear Blend Skinning</em> 의 <em>“Candy Wrapper”</em> 라는 현상이였는데, 이 글에서는 그 문제를 위해 2008년에 고안된 방법에 대해서 알아볼 것이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/07/20/dual-quaternion-skinning/">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/07/07/introduce-of-skinning/">Introduce Of Skinning</a>
          </h1>

          <p class="post-meta">Jul 7, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/skinning/">skinning</a>,
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/vertex-deformation/">vertex deformation</a>,
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/try/">try</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>2달전 쯤에 스키닝에 대한 글을 본적이 있다. 그때는 스키닝이 뭔지도 정확히 모르던 시점이였다. Unity 에서는 LBS 라는 방법으로 스키닝을 지원하는데 이 방식보다 나은 방식이 있는데 어찌하여 옛날 방식을 지원하는지에 대한 불만글이였다. 그래서 공부할 것을 찾던 필자는 Unity 에서의 커스텀 스키닝을 구현을 목표로 잡았다. 정리를 위해 하나하나 글을 남겨보도록 하겠다. 이 글에서는 간단히 스키닝의 개념에 대해서 써보도록 하겠다. 이전에 쓴 <a href="/2017/05/19/handling-rig-and-skinning/">handling rig and skinning</a> 에서도 간략하게 다루었지만 기초 지식이 없는 상태에서 급하게 쓴 글이였고, 굉장히 Unity 스러운 글이기에 다시 처음부터 써보겠다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/07/07/introduce-of-skinning/">Read on &rarr;</a>
          </p>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Su-Hyeok Kim - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
