---
layout: post
author: "Su-Hyeok Kim"
comments: true
categories:
  - unity
---

※ 필자는 Unity 가 참 마음에 듭니다. 그만큼 편협한 시각을 가지고 있을 수도 있으니 사실과 다른 부분은 댓글로 알려주시기 바랍니다.

최근에 우연한 기회로 SNS 에서 꽤나 대단한 사람을 통해 많은 정보를 들었다. 기술적인 것, 한국 게임 업계에 대한 고찰, 게임 업계의 미래 등 아무것도 몰랐던 필자에게 엄청난 정보들이 들어왔다. 그 중에서도 가장 도움이 된건 아무래도 로드맵을 제시해주고 기술에 대한 설명들이 아닐까 싶다. 그 분의 말씀중에 게임 엔진에 대한 고찰도 상당히 많이 써있었다. 대부분이 잘못된 부분에 대한 지적이였지만 미래 또한 포함되어 있었다. 그리고 그글을 보고 2년 동안 봐왔던 Unity 에 대해 극히 주관적인 생각들을 정리해 보려한다.

<!-- more -->

## 99% 의 CBD, 단순한 시스템, 수많은 가능성

Unity 의 게임 시스템은 Hierarchy 안에서 미리 저장된 Scene 의 데이터를 불러와 GameObject 들을 적재하고 로딩이 된 오브젝트들이 알아서 모든 것을 다하는 시스템이다. 모두가 알다시피 GameObject 에는 여러개의 컴포넌트가 붙어 각각의 컴포넌트가 각자의 역할을 한다. 그렇게 게임이 돌아간다. 컨텐츠 프로그래머는 컴포넌트와 Scene 의 데이터만 잘 설계해주면 된다.

아무것도 정해지지 않은 Unity 의 극한의 CBD 는 초보자에게 당황스러움을 주지만 익숙해진 사람들에게는 극한의 자유가 머릿속에 각인되어져 있다. 아주 잠깐 회사에서 받은 외주 때문에 UE4 를 잠깐 건드려봤는데 꽤나 정해진 시스템이 많았다. 물론 엔진계의 쌍두마차답게 거의 모든 게임에 적용되게 시스템을 구성해놓아서 괜찮아 보였다. 하지만 그 시스템을 학습하는 시간은 오래 걸리지 않았지만 조금 아까웠다. 반대로 Unity 의 극한의 자유가 생각났다.

그리고 Hierarchy 시스템말고도 Unity 에서 자랑하는 강력한 시스템이 있다. 바로 __ScriptableObject__ 라는 에셋 데이터 타입이다. 물론 스크립팅을 사용할 수 있어 저 이름이 붙었다. Unity 의 직렬화 시스템을 오직 한 스크립트만을 위해 사용 가능하며 스크립트별로 다른 데이터가 취급되기 때문에 사용자의 커스텀 데이터 타입을 만들 수 있는 가능성을 열어준다. 또한 Unity 에셋의 파일 시스템은 모든 에셋에 하위 에셋을 붙여서 저장이 가능하다. 이 하위 에셋 시스템과 __ScriptableObject__ 시스템을 사용하면 모든 데이터를 사용자 마음대로 저장이 가능하다.

렌더링 쪽에서도 꽤나 여러가지를 할 수 있도록 가능성을 열어놓았다. __CommandBuffer__ 라는 놈이 있다. 어느정도 렌더링 파이프라인 안에서 사용자가 하고싶은 렌더링을 마음대로 하게 해주는 _명령(Command)_ 를 저장해 여러가지를 할 수 있다. 또한 Unity 시스템의 Mesh 인스턴스를 통한 렌더링 뿐만 아니라 데이터를 직접 저장해서 그릴 수도 있다. 또한 _Indirect Rendering_ 을 지원해 최적의 효율을 뽑을 수 있다. 이는 Graphics API 들에서 지원하는 기능을 그대로 가져온 것이지만 커스터마이징이 유연한 Unity 에서는 꽤나 강력한 시너지를 구성한다.

## 엉성한 기능, 상세하게 정리되지 않은 레퍼런스, 어려운 최적화

위에서 말한 하락세는 한가지 시스템에서 도드라지게 나타난다. 바로 지형 시스템이다. Unity 에서는 DrawCall 을 자체적으로 최적화해서 Batching Count 라고 따로 숫자가 있다. 결국 DrawCall 과 같은 개념이다. 근데 Terrain 에 있는게 많을 수록 Batching Count 가 기하급수적으로 늘어난다. 물론 필자가 충분한 사전조사는 하지 않았었다. 하지만 꽤나 많은 사람이 같은 문제를 겪는걸로 봐서는 고질적인 문제인듯 하다. 그리고 아직도 안고쳐졌다.

Unity 의 웹 레퍼런스는 굉장히 별로다. 상세한 설명이 없이 그냥 단문으로 구성된 페이지도 간혹가다 있다. 물론 단문으로만 쓸 수도 있는 것도 있지만 그렇지 않은것들도 꽤나 많아 짜증을 유발한다. 또한 _Graphics.DrawProceduralIndirect_ 메서드를 사용하기 위해 래퍼런스를 보는데 _Indirect Rendering_ 구성에 중요한 데이터들을 표로 정리하지 않고 그냥 텍스트로만 정리해놓아서 조금 헷갈렸다. 이게 그대로 메모리 값을 복사하는 것이기 때문에 순서를 잘 맞춰주어야 하는데 성의없이 써놓은게 너무 아쉬웠다. 그리고 해당 API 의 단점도 안쓰여있어 써보기 전에는 아무것도 모른다. 이는 Unity 엔지니어들이 그다지 효율적으로 관리되지 않는 것으로 보인다.

Terrain 도 그렇지만 Unity 에서 3D 게임을 만들면서 최적화를 하려면 굉장히 어렵다. 물론 지식이 없는것도 문제지만 그것을 유도해주는 레퍼런스나 가이드는 거의 없다. 또한 처음부터 제대로 만들려면 결국 전부다 뜯어 고쳐야 한다. 위에서 말한 데이터 커스터마이징을 통해 메시 데이터를 전부 합쳐 _Graphics.DrawProceduralIndirect_ 를 사용해 _Batching Count_ 를 줄이는 것은 이전에 기하급수적으로 증가한 _Batching Count_ 의 성능과 비교했을 떄 하늘과 땅 차이다. 또한 __Terrain__ 도 _Batching Count_ 가 너무 커서 사용이 불가능해 결국 데이터를 추출해 메시 데이터를 커스터마이징 한것처럼 결국 처음부터 다해야 한다. 특히나 바람에 흔들리는 물리 시스템이 있는 풀이나 나무를 움직이는 기술은 __GPU Gems__ 나 __GPU Pro__ 에 나올법한 기술들을 바탕으로 구현해야하기 때문에 문외한들에게는 답이 없다.

이건 물론 기본적인 소양이겠지만 스크립트에서 GC 를 최대한 안일으키는게 게임 프로그래머의 중요한 역량이기 때문에 C# 의 쓰레기 메모리가 생기는 요인들을 거의 다 파악하고 있어야 한다. 이는 프로그래머에게 크나큰 고통을 안겨준다. 필자도 처음 이 사실을 알았을 때 굉장히 좌절했었다. 또한 퍼포먼스가 안나오는 플랫폼에서는 꽤 많은 갯수의 __Update__ 구문의 실행이 취약하다는 것도 놀라운 사실이었다.

## 결론

다행히 Unity 는 미래가 어둡지는 않을 것 같다. 여태까지는 엔진의 기능이 하락세를 걷고 있었지만 하나 하나 고쳐가는 중이다. 아마 2017 버젼이 몇개 더 릴리즈 되면 꽤나 안정화가 되어 많은 가능성이 열릴 듯 하다. 물론 구멍이 있는 기능들이 모두다 고쳐질라면 꽤나 시간은 걸릴 듯 하지만 말이다.
