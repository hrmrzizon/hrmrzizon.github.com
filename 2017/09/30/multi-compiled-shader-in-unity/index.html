<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Multi Compiled Shader In Unity</title>
  <meta name="description" content="Unity 는 렌더링을 위한 하부 시스템을 꽤나 많이 만들어 놓았다. 그 중에서도 꽤나 오래된 시스템은 multi-compiled shader 시스템일 것이다. 직역하면 여러개로 컴파일된 Shader 란 말이다. 또한 기능또한 별 차이 없다. 하지만 이를 위해 시스템에서 어떤 일을 하는지에 대해서는 알아야 한다. 우선 multi-compiled shader 에 대해서 알아야 겠다. Unity 시스템에서는 단순히 물체를 렌더링하는데 한가지 방법만 쓰이지 않는다. UnityEngine.MeshRenderer 같은 지원하는 컴포넌트를 통해 렌더링을 하는게 가장 알려진 방법이다. 또한 컴포넌트가 아닌 코드 레벨에서도 렌더링이 가능하다. Graphics.DrawProcedural 와 비슷한 메서드를 통해서도 렌더링이 가능하다. 또한 Unity 에서 지원하는 시스템을 사용하기 위해 분기 키워드가 아닌 전처리 옵션을 두어 사용하기도 한다.(Unity 에서는 기능 지원을 위해 전처리기 기능을 많이 쓴다.) 여기서 알아야 할 것은 Unity 시스템에서는 굉장히 많은 방법으로 다양한 렌더링을 지원하는데, 다양한 렌더링을 사용하기 위해서는 Shader 또한 각각 다양한 렌더링 방법에 맞추어 컴파일 될 필요가 있다. 그럴때 쓰는 것이 multi-compiled shader 기능이다. 사용자가 직접 multi-compiled shader 기능을 사용하는 것은 꽤나 단순하다. #pragma multi_compile FANCY_STUFF_OFF FANCY_STUFF_ON 쉐이더 코드에서 위와 같이 사용하게 되면 FANCY_STUFF_OFF, FANCY_STUFF_ON 두가지 옵션을 통해 컴파일 하는 것을 나눌 수 있게 된다. 이 키워드는 쉐이더 바깥에서 제어가 가능하다. 모든 쉐이더의 키워드를 제어하려면 Shader.EnableKeyword, Shader.DisableKeyword 를 사용하면 되고, Material 단위로 사용하려면 Material.EnableKeyword, Material.DisableKeyword 을 사용하면 된다. 또한 Unity 시스템 내에서 이 multi-compiled shader 를 사용하니, 기존에 있는 것들은 사용하면 영 좋지 않은 꼴이 일어날듯 하다. 이런 복잡함을 만드는 시스템에는 언제나 문제가 있다. Unity 에서의 기본적인 Shader 컴파일은 따로 설정을 해주지 않는 이상 Runtime 에 일어난다. 정확히 Unity 시스템에서 해당 쉐이더를 사용해 렌더링을 할때 컴파일을 하게 된다. 그리고 컴파일할 Shader 의 양이 많으면 많을수록 이는 영 좋지않은 꼴을 보게된다. multi-compiled shader 는 더욱더 시간을 많이 잡아먹게 한다. 물론 이를 해결하기 위한 방법은 존재한다. Unity 프로젝트 설정에서 Graphics Setting 에서 가능하다. 잘 찾아보면 Shader Preloading 이라는 항목이 있다. 말그대로 Runtime 에 로딩하는게 아닌 시작하자마자 로딩하는 기능이다. 다만 이 기능을 사용하려면 Shader 를 그대로 넣는게 아닌 다른 것을 만들어야 한다. 이는 ShaderVariantsCollection 이라는 에셋인데, Unity 에서 생성가능하다. 이 에셋은 Shader 의 종류를 가지고 multi-compiled shader 의 어떤 쉐이더를 로딩할지 결정하는 에셋이다. 이 에셋을 생성하여 Shader 들을 세팅한 뒤, Shader Preloading 아래에 있는 리스트에 넣어주면 응용 프로그램이 시작될 때, Unity 시스템에서 알아서 로딩한다. 미리 로딩하는게 아닌 사용자가 원할때 로딩하는 것도 가능한 것처럼 보인다. ShaderVariantsCollection 를 사용하면 사용자가 원할 떄 단순히 메소드 호출을 통해 로딩이 가능하다. ShaderVariantsCollection.WarmUp 이라는 메소드를 호출하면 전부 로딩을 하기 시작하는데 이때 로딩하는 개념이 조금 재미있다. Unity 시스템에서는 필요할 때 Shader 를 로딩한다. 이는 위에서도 언급했었는데 ShaderVariantsCollection.WarmUp 는 단순히 이 지연 로딩 시스템을 이용한 것 뿐이다. ShaderVariantsCollection.WarmUp 을 호출하면 단순한 폴리곤 한개를 렌더링하는데, ShaderVariantsCollection 이 가지고 있는 모든 쉐이더로 한번씩 렌더링을 한다. 이렇게 되면 지연 로딩 시스템이 쉐이더를 로딩하게 되는 것이다. 참조 자료 Unity Manual : Making multiple shader program variants Unity Reference : ShaderVariantsCollection Unity Manual : Optimizing Shader Load Time">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/2017/09/30/multi-compiled-shader-in-unity/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Multi Compiled Shader In Unity">
  <meta name="twitter:description" content="Unity 는 렌더링을 위한 하부 시스템을 꽤나 많이 만들어 놓았다. 그 중에서도 꽤나 오래된 시스템은 multi-compiled shader 시스템일 것이다. 직역하면 여러개로 컴파일된 Shader 란 말이다. 또한 기능또한 별 차이 없다. 하지만 이를 위해 시스템에서 어떤 일을 하는지에 대해서는 알아야 한다. 우선 multi-compiled sha...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Multi Compiled Shader In Unity</h1>
    
    <p class="post-meta"><time datetime="2017-09-30T00:00:00+00:00" itemprop="datePublished">Sep 30, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/builtin/">builtin</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Unity 는 렌더링을 위한 하부 시스템을 꽤나 많이 만들어 놓았다. 그 중에서도 꽤나 오래된 시스템은 <em>multi-compiled shader</em> 시스템일 것이다. 직역하면 여러개로 컴파일된 <em>Shader</em> 란 말이다. 또한 기능또한 별 차이 없다. 하지만 이를 위해 시스템에서 어떤 일을 하는지에 대해서는 알아야 한다.</p>

<p>우선 <em>multi-compiled shader</em> 에 대해서 알아야 겠다. Unity 시스템에서는 단순히 물체를 렌더링하는데 한가지 방법만 쓰이지 않는다. <strong>UnityEngine.MeshRenderer</strong> 같은 지원하는 컴포넌트를 통해 렌더링을 하는게 가장 알려진 방법이다. 또한 컴포넌트가 아닌 코드 레벨에서도 렌더링이 가능하다. <em>Graphics.DrawProcedural</em> 와 비슷한 메서드를 통해서도 렌더링이 가능하다. 또한 Unity 에서 지원하는 시스템을 사용하기 위해 분기 키워드가 아닌 전처리 옵션을 두어 사용하기도 한다.(Unity 에서는 기능 지원을 위해 전처리기 기능을 많이 쓴다.) 여기서 알아야 할 것은 Unity 시스템에서는 굉장히 많은 방법으로 다양한 렌더링을 지원하는데, 다양한 렌더링을 사용하기 위해서는 <em>Shader</em> 또한 각각 다양한 렌더링 방법에 맞추어 컴파일 될 필요가 있다. 그럴때 쓰는 것이 <em>multi-compiled shader</em> 기능이다.</p>

<p>사용자가 직접 <em>multi-compiled shader</em> 기능을 사용하는 것은 꽤나 단순하다.</p>

<pre><code class="language-C">#pragma multi_compile FANCY_STUFF_OFF FANCY_STUFF_ON
</code></pre>

<p>쉐이더 코드에서 위와 같이 사용하게 되면 <em>FANCY_STUFF_OFF</em>, <em>FANCY_STUFF_ON</em> 두가지 옵션을 통해 컴파일 하는 것을 나눌 수 있게 된다. 이 키워드는 쉐이더 바깥에서 제어가 가능하다. 모든 쉐이더의 키워드를 제어하려면 <em>Shader.EnableKeyword</em>, <em>Shader.DisableKeyword</em> 를 사용하면 되고, <strong>Material</strong> 단위로 사용하려면 <em>Material.EnableKeyword</em>, <em>Material.DisableKeyword</em> 을 사용하면 된다. 또한 Unity 시스템 내에서 이 <em>multi-compiled shader</em> 를 사용하니, 기존에 있는 것들은 사용하면 영 좋지 않은 꼴이 일어날듯 하다.</p>

<p>이런 복잡함을 만드는 시스템에는 언제나 문제가 있다. Unity 에서의 기본적인 <em>Shader</em> 컴파일은 따로 설정을 해주지 않는 이상 Runtime 에 일어난다. 정확히 Unity 시스템에서 해당 쉐이더를 사용해 렌더링을 할때 컴파일을 하게 된다. 그리고 컴파일할 <em>Shader</em> 의 양이 많으면 많을수록 이는 영 좋지않은 꼴을 보게된다. <em>multi-compiled shader</em> 는 더욱더 시간을 많이 잡아먹게 한다. 물론 이를 해결하기 위한 방법은 존재한다.</p>

<p>Unity 프로젝트 설정에서 <em>Graphics Setting</em> 에서 가능하다. 잘 찾아보면 <strong><em>Shader Preloading</em></strong> 이라는 항목이 있다. 말그대로 Runtime 에 로딩하는게 아닌 시작하자마자 로딩하는 기능이다. 다만 이 기능을 사용하려면 <em>Shader</em> 를 그대로 넣는게 아닌 다른 것을 만들어야 한다. 이는 <strong>ShaderVariantsCollection</strong> 이라는 에셋인데, Unity 에서 생성가능하다. 이 에셋은 <em>Shader</em> 의 종류를 가지고 <em>multi-compiled shader</em> 의 어떤 쉐이더를 로딩할지 결정하는 에셋이다. 이 에셋을 생성하여 <em>Shader</em> 들을 세팅한 뒤, <strong><em>Shader Preloading</em></strong> 아래에 있는 리스트에 넣어주면 응용 프로그램이 시작될 때, Unity 시스템에서 알아서 로딩한다. 미리 로딩하는게 아닌 사용자가 원할때 로딩하는 것도 가능한 것처럼 보인다. <strong>ShaderVariantsCollection</strong> 를 사용하면 사용자가 원할 떄 단순히 메소드 호출을 통해 로딩이 가능하다. <em>ShaderVariantsCollection.WarmUp</em> 이라는 메소드를 호출하면 전부 로딩을 하기 시작하는데 이때 로딩하는 개념이 조금 재미있다. Unity 시스템에서는 필요할 때 <em>Shader</em> 를 로딩한다. 이는 위에서도 언급했었는데 <em>ShaderVariantsCollection.WarmUp</em> 는 단순히 이 지연 로딩 시스템을 이용한 것 뿐이다. <em>ShaderVariantsCollection.WarmUp</em> 을 호출하면 단순한 폴리곤 한개를 렌더링하는데, <strong>ShaderVariantsCollection</strong> 이 가지고 있는 모든 쉐이더로 한번씩 렌더링을 한다. 이렇게 되면 지연 로딩 시스템이 쉐이더를 로딩하게 되는 것이다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html">Unity Manual : Making multiple shader program variants</a></li>
  <li><a href="https://docs.unity3d.com/kr/current/ScriptReference/ShaderVariantCollection.html">Unity Reference : ShaderVariantsCollection</a></li>
  <li><a href="https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html">Unity Manual : Optimizing Shader Load Time</a></li>
</ul>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://zizon.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Su-Hyeok Kim - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
